# About

Unlike a traditional ROS package, a webapp is usually deployed along with many other components. Here is an example of how a web deployment might looks like
![](https://www.fullstackpython.com/img/visuals/full-stack-python-map.png)
Credits: https://www.fullstackpython.com

`rmf-web` only provides the application, as you can see in the diagram, a full web deployment consists of many, many other components. There is no single way to "run" `rmf-web` as you would normally expect from a desktop application. Each deployment will be different, depending on the environment that you are running, the licenses you can use, the SaaS that you are using, the cloud infrastructure (or lack of) and many other factors, and the application itself is only one of the component among the sea of many software used in a modern webapp deployment.

This repo serves as an example deployment of `rmf-web` that can work in an airgapped network. Meaning that we will not be using any SaaS and public cloud infrastructure.

# Software Stack

In this example, we will be using the following software

rmf-web:
* ros2-bridge
* dashboard

others:
* kubernetes
* minikube
* keycloak
* nginx
* postgres

**NOTE: If you are following this example to management your own deployment, you must make sure that you have the proper license to use the softwares used in this example.**

# Setting Up

## RMF

`rmf-web` needs RMF to provide it's functions, while you could technically deploy `rmf-web` without RMF, doing that would not be useful and you wouldn't be able to do anything with it.

For this example we will be using [rmf_demos](https://github.com/open-rmf/rmf_demos) as a local "deployment" of RMF, check that you have a working installation with

```bash
ros2 launch rmf_demos office.launch.xml
```

## kubernetes

Normally, your cloud provider will provide a kubernetes cluster, for this example, we will be using `minikube` to create our own cluster.

```bash
./start-minikube.sh
```

This will download `minikube` to `.bin/minikube` and start a cluster.

To stop the minikube cluster, run

```bash
.bin/minikube stop
```

## DNS

In a real deployment, you would buy a domain and configure your dns provider to point it to your public ip. Since we don't have a domain in this example we will be using the `/etc/hosts` file to resolve the domain.

```bash
if grep -q 'example.com' /etc/hosts; then
  sudo sed "s/.*example.com.*/$(.bin/minikube ip) example.com/" /etc/hosts -i
else
  echo "$(.bin/minikube ip) example.com" | sudo tee -a /etc/hosts
fi
```

This will create an entry in `/etc/hosts` to point `example.com` to the minikube cluster.

Check that it works by pinging it

```bash
ping example.com
```

## SSL Certificate

In a real deployment, you will get a verified cert, but for this example, we will be using the default certs generated by minikube and keycloak. These are self-signed cert so you will get security warnings from the browser when you visit the urls, for the purpose of this example, you will need to proceed with the security exception.

# Keycloak

## Deploying

In this example, we will be using [Keycloak](https://www.keycloak.org/) do user management and authentication. It is an open source identity and access management, released under the Apache 2.0 license.

There is a kubernetes resource file to deploy keycloak along with postgres for its database.

```bash
.bin/minikube kubectl -- apply -f k8s/keycloak.yaml
```

This requires internet connection, see [Deploying in an airgapped network](#Deploying-in-an-airgapped-network) if you are in an airgap network. tldr:

```bash
# connected to internet
docker pull quay.io/keycloak/keycloak:12.0.4

# connected to airgap network
.bin/minikube load quay.io/keycloak/keycloak:12.0.4
.bin/minikube kubectl -- apply -f k8s/keycloak.yaml
```

Use kubectl to wait for keycloak to be ready

```bash
.bin/minikube kubectl -- get deployment
```

When keycloak is ready, test it out by going to https://example.com/auth. The superuser created by this deployment is `user=admin,password=admin`.

## Configuration

For this example, we will

1. Create a `rmf-web` realm.
1. Create a `dashboard` client.
1. Create an example user with user=example password=example.

For brevity, you can use the provided script to automate the process.

```bash
node keycloak-tools/bootstrap-keycloak.js
```

You may check out the keycloak docs if you would like to learn more about it's features.

## Get the JWT Public Key

Keycloak implements the openid-connect standard, by default the JWT is signed with an auto generated RSA key. We will need the cert so that `rmf-web` backend services and verify the token. You can use the admin console to get it or use the provided script

```bash
node keycloak-tools/get-cert.js > jwt-cert.pem
```

If you wish to, you may check the cert with

```bash
openssl x509 -in jwt-cert.pem -noout -text
```

## Add the cert to kubernetes

In order to use the cert, we will add it as a configmap to kubernetes

```bash
.bin/minikube kubectl -- create configmap jwt-cert --from-file=jwt-cert.pem
```

# ros2-bridge

## Build minimal RMF image

We will need a minimal base image containing all the RMF messages. This image will be used to build the ros2-bridge image.

How you get this image will vary depending what version of RMF, and what extensions you are deploying it with. It is important that ros2-bridge is using the exact same message definitions as used by the deployment of RMF. For this example, we assume that you built rmf_demos from source using the main branch, so we will build the messages from source as well.

Get RMF source code

```bash
mkdir -p rmf_ws
cd rmf_ws
wget https://raw.githubusercontent.com/open-rmf/rmf/main/rmf.repos
mkdir -p src
vcs import src < rmf.repos
```

build the image

```bash
docker build -t rmf-web/builder -f docker/builder.dockerfile ws/rmf/src
```

## Build ros2-bridge image

Get rmf-web source

```bash
git clone --depth 1 https://github.com/open-rmf/rmf-web ws/rmf-web
```

build the image

```bash
docker build -t rmf-web/ros2-bridge -f docker/ros2-bridge.dockerfile ws/rmf-web
```

"publish" the image, in a normal deployment, you would publish this to your docker registry, since we don't have a registry for this example, we will push the image directly to minikube

```bash
.bin/minikube image load rmf-web/ros2-bridge
```

deploy it

```bash
.bin/minikube kubectl -- apply -f k8s/ros2-bridge.yaml
```

# dashboard

build the image

```bash
docker build -t rmf-web/dashboard -f docker/dashboard.dockerfile ws/rmf-web
```

"publish" the image

```bash
.bin/minikube image load rmf-web/dashboard
```

deploy it

```bash
.bin/minikube kubectl -- apply -f k8s/dashboard.yaml
```

# Test the deployment

Go to https://example.com/dashboard, if everything works, you should see a log in screen, use user=example, password=example.

After that, you should be presented with the dashboard, you have successfully deployed `rmf-web`! ðŸŽ‰

# Troubleshooting

## Deploying in an airgapped network

There are certain parts that requires an internet connection to fetch the docker images and source codes, in order to deploy from within an airgapped network, you can use obtain the images some way, and push them directly to minikube. For example

when you have internet, run this to get the keycloak image
```bash
docker pull quay.io/keycloak/keycloak:12.0.4
```

now, connect to the airgapped network and push the image to minikube
```bash
.bin/minikube load quay.io/keycloak/keycloak:12.0.4
```

now you can deploy keycloak without require access to the internet

If connection to the internet from the same PC is not possible, you can use `docker save` to save the image into a tarball, then transfer it to the minikube PC through whatever method possible (thumbdrives, cds etc) and use `docker load` to load the image. Then you can use `.bin/minikube load` to push it into minikube.


## Updating the deployment

If you make changes to the images, you will need to publish the new image and update the kubernetes resources.
Since we are pushing the images directly to minikube, we can't tell kubernetes to pull the new image as our image doesn't actually exist in the registry. In order to tell kubernetes to use the new image, you need to delete the current deployment and re-deploy again.

```bash
.bin/minikube kubectl -- delete -f <path-to-k8s-file>
.bin/minikube kubectl -- apply -f <path-to-k8s-file>
```

## Get a shell into the container

It can be very useful to get a shell into the pod, kubernetes allow you to do this easily.

```bash
.bin/minikube kubectl -- get pods
.bin/minikube kubectl -- exec -it <pod> -- bash
```

# Further work

This examples shows a deployment of RMF in an 