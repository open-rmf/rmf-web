/* tslint:disable */
/* eslint-disable */
/**
 * RMF API Server
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 *
 * @export
 * @enum {string}
 */

export const Action = {
  Waiting: 'waiting',
  Cancel: 'cancel',
  Override: 'override',
  Resume: 'resume',
} as const;

export type Action = (typeof Action)[keyof typeof Action];

/**
 *
 * @export
 * @interface Activity
 */
export interface Activity {
  /**
   * The category of this activity. There must not be any duplicate activity categories per fleet.
   * @type {string}
   * @memberof Activity
   */
  category: string;
  /**
   * Details about the behavior of the activity.
   * @type {string}
   * @memberof Activity
   */
  detail: string;
  /**
   *
   * @type {object}
   * @memberof Activity
   */
  description_schema?: object | null;
}
/**
 *
 * @export
 * @interface ActivityDiscovery
 */
export interface ActivityDiscovery {
  /**
   *
   * @type {Array<Datum>}
   * @memberof ActivityDiscovery
   */
  data?: Array<Datum> | null;
}
/**
 *
 * @export
 * @interface ActivityDiscoveryRequest
 */
export interface ActivityDiscoveryRequest {
  /**
   * Indicate that this is an activity discovery request
   * @type {string}
   * @memberof ActivityDiscoveryRequest
   */
  type: ActivityDiscoveryRequestTypeEnum;
}

export const ActivityDiscoveryRequestTypeEnum = {
  ActivitiyDiscoveryRequest: 'activitiy_discovery_request',
} as const;

export type ActivityDiscoveryRequestTypeEnum =
  (typeof ActivityDiscoveryRequestTypeEnum)[keyof typeof ActivityDiscoveryRequestTypeEnum];

/**
 *
 * @export
 * @interface AddExceptDateRequest
 */
export interface AddExceptDateRequest {
  /**
   *
   * @type {string}
   * @memberof AddExceptDateRequest
   */
  except_date: string;
}
/**
 *
 * @export
 * @interface AffineImage
 */
export interface AffineImage {
  /**
   *
   * @type {string}
   * @memberof AffineImage
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof AffineImage
   */
  x_offset: number;
  /**
   *
   * @type {number}
   * @memberof AffineImage
   */
  y_offset: number;
  /**
   *
   * @type {number}
   * @memberof AffineImage
   */
  yaw: number;
  /**
   *
   * @type {number}
   * @memberof AffineImage
   */
  scale: number;
  /**
   *
   * @type {string}
   * @memberof AffineImage
   */
  encoding: string;
  /**
   *
   * @type {string}
   * @memberof AffineImage
   */
  data: string;
}
/**
 *
 * @export
 * @interface AlertParameter
 */
export interface AlertParameter {
  /**
   *
   * @type {string}
   * @memberof AlertParameter
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof AlertParameter
   */
  value: string;
}
/**
 *
 * @export
 * @interface AlertRequest
 */
export interface AlertRequest {
  /**
   *
   * @type {string}
   * @memberof AlertRequest
   */
  id: string;
  /**
   *
   * @type {number}
   * @memberof AlertRequest
   */
  unix_millis_alert_time: number;
  /**
   *
   * @type {string}
   * @memberof AlertRequest
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof AlertRequest
   */
  subtitle: string;
  /**
   *
   * @type {string}
   * @memberof AlertRequest
   */
  message: string;
  /**
   *
   * @type {boolean}
   * @memberof AlertRequest
   */
  display: boolean;
  /**
   *
   * @type {ApiServerModelsAlertsAlertRequestTier}
   * @memberof AlertRequest
   */
  tier: ApiServerModelsAlertsAlertRequestTier;
  /**
   *
   * @type {Array<string>}
   * @memberof AlertRequest
   */
  responses_available: Array<string>;
  /**
   *
   * @type {Array<AlertParameter>}
   * @memberof AlertRequest
   */
  alert_parameters: Array<AlertParameter>;
  /**
   *
   * @type {string}
   * @memberof AlertRequest
   */
  task_id: string | null;
}

/**
 *
 * @export
 * @interface AlertResponse
 */
export interface AlertResponse {
  /**
   *
   * @type {string}
   * @memberof AlertResponse
   */
  id: string;
  /**
   *
   * @type {number}
   * @memberof AlertResponse
   */
  unix_millis_response_time: number;
  /**
   *
   * @type {string}
   * @memberof AlertResponse
   */
  response: string;
}
/**
 *
 * @export
 * @enum {string}
 */

export const ApiServerModelsAlertsAlertRequestTier = {
  Info: 'info',
  Warning: 'warning',
  Error: 'error',
} as const;

export type ApiServerModelsAlertsAlertRequestTier =
  (typeof ApiServerModelsAlertsAlertRequestTier)[keyof typeof ApiServerModelsAlertsAlertRequestTier];

/**
 *
 * @export
 * @enum {string}
 */

export const ApiServerModelsDeliveryAlertsDeliveryAlertCategory = {
  Missing: 'missing',
  Wrong: 'wrong',
  Obstructed: 'obstructed',
  Cancelled: 'cancelled',
} as const;

export type ApiServerModelsDeliveryAlertsDeliveryAlertCategory =
  (typeof ApiServerModelsDeliveryAlertsDeliveryAlertCategory)[keyof typeof ApiServerModelsDeliveryAlertsDeliveryAlertCategory];

/**
 *
 * @export
 * @enum {string}
 */

export const ApiServerModelsDeliveryAlertsDeliveryAlertTier = {
  Warning: 'warning',
  Error: 'error',
} as const;

export type ApiServerModelsDeliveryAlertsDeliveryAlertTier =
  (typeof ApiServerModelsDeliveryAlertsDeliveryAlertTier)[keyof typeof ApiServerModelsDeliveryAlertsDeliveryAlertTier];

/**
 *
 * @export
 * @enum {string}
 */

export const ApiServerModelsRmfApiLogEntryTier = {
  Uninitialized: 'uninitialized',
  Info: 'info',
  Warning: 'warning',
  Error: 'error',
} as const;

export type ApiServerModelsRmfApiLogEntryTier =
  (typeof ApiServerModelsRmfApiLogEntryTier)[keyof typeof ApiServerModelsRmfApiLogEntryTier];

/**
 *
 * @export
 * @enum {string}
 */

export const ApiServerModelsRmfApiRobotStateStatus = {
  Uninitialized: 'uninitialized',
  Offline: 'offline',
  Shutdown: 'shutdown',
  Idle: 'idle',
  Charging: 'charging',
  Working: 'working',
  Error: 'error',
} as const;

export type ApiServerModelsRmfApiRobotStateStatus =
  (typeof ApiServerModelsRmfApiRobotStateStatus)[keyof typeof ApiServerModelsRmfApiRobotStateStatus];

/**
 *
 * @export
 * @enum {string}
 */

export const ApiServerModelsRmfApiTaskStateStatus = {
  Uninitialized: 'uninitialized',
  Blocked: 'blocked',
  Error: 'error',
  Failed: 'failed',
  Queued: 'queued',
  Standby: 'standby',
  Underway: 'underway',
  Delayed: 'delayed',
  Skipped: 'skipped',
  Canceled: 'canceled',
  Killed: 'killed',
  Completed: 'completed',
} as const;

export type ApiServerModelsRmfApiTaskStateStatus =
  (typeof ApiServerModelsRmfApiTaskStateStatus)[keyof typeof ApiServerModelsRmfApiTaskStateStatus];

/**
 *
 * @export
 * @interface AssignedTo
 */
export interface AssignedTo {
  /**
   *
   * @type {string}
   * @memberof AssignedTo
   */
  group: string;
  /**
   *
   * @type {string}
   * @memberof AssignedTo
   */
  name: string;
}
/**
 *
 * @export
 * @interface Assignment
 */
export interface Assignment {
  /**
   *
   * @type {string}
   * @memberof Assignment
   */
  fleet_name?: string | null;
  /**
   *
   * @type {string}
   * @memberof Assignment
   */
  expected_robot_name?: string | null;
}
/**
 *
 * @export
 * @interface BeaconState
 */
export interface BeaconState {
  /**
   *
   * @type {string}
   * @memberof BeaconState
   */
  id: string;
  /**
   *
   * @type {boolean}
   * @memberof BeaconState
   */
  online: boolean;
  /**
   *
   * @type {string}
   * @memberof BeaconState
   */
  category: string;
  /**
   *
   * @type {boolean}
   * @memberof BeaconState
   */
  activated: boolean;
  /**
   *
   * @type {string}
   * @memberof BeaconState
   */
  level: string;
}
/**
 *
 * @export
 * @interface Booking
 */
export interface Booking {
  /**
   * The unique identifier for this task
   * @type {string}
   * @memberof Booking
   */
  id: string;
  /**
   *
   * @type {number}
   * @memberof Booking
   */
  unix_millis_earliest_start_time?: number | null;
  /**
   *
   * @type {number}
   * @memberof Booking
   */
  unix_millis_request_time?: number | null;
  /**
   *
   * @type {Priority}
   * @memberof Booking
   */
  priority?: Priority | null;
  /**
   *
   * @type {Array<string>}
   * @memberof Booking
   */
  labels?: Array<string> | null;
  /**
   *
   * @type {string}
   * @memberof Booking
   */
  requester?: string | null;
}
/**
 *
 * @export
 * @interface BuildingMap
 */
export interface BuildingMap {
  /**
   *
   * @type {string}
   * @memberof BuildingMap
   */
  name: string;
  /**
   *
   * @type {Array<Level>}
   * @memberof BuildingMap
   */
  levels: Array<Level>;
  /**
   *
   * @type {Array<Lift>}
   * @memberof BuildingMap
   */
  lifts: Array<Lift>;
}
/**
 *
 * @export
 * @interface CancelTaskRequest
 */
export interface CancelTaskRequest {
  /**
   * Indicate that this is a task cancellation request
   * @type {string}
   * @memberof CancelTaskRequest
   */
  type: CancelTaskRequestTypeEnum;
  /**
   * Specify the task ID to cancel
   * @type {string}
   * @memberof CancelTaskRequest
   */
  task_id: string;
  /**
   *
   * @type {Array<string>}
   * @memberof CancelTaskRequest
   */
  labels?: Array<string> | null;
}

export const CancelTaskRequestTypeEnum = {
  CancelTaskRequest: 'cancel_task_request',
} as const;

export type CancelTaskRequestTypeEnum =
  (typeof CancelTaskRequestTypeEnum)[keyof typeof CancelTaskRequestTypeEnum];

/**
 *
 * @export
 * @interface Cancellation
 */
export interface Cancellation {
  /**
   * The time that the cancellation request arrived
   * @type {number}
   * @memberof Cancellation
   */
  unix_millis_request_time: number;
  /**
   * Labels to describe the cancel request, items can be a single value like `dashboard` or a key-value pair like `app=dashboard`, in the case of a single value, it will be interpreted as a key-value pair with an empty string value.
   * @type {Array<string>}
   * @memberof Cancellation
   */
  labels: Array<string>;
}
/**
 *
 * @export
 * @interface Commission
 */
export interface Commission {
  /**
   *
   * @type {boolean}
   * @memberof Commission
   */
  dispatch_tasks?: boolean | null;
  /**
   *
   * @type {boolean}
   * @memberof Commission
   */
  direct_tasks?: boolean | null;
  /**
   *
   * @type {boolean}
   * @memberof Commission
   */
  idle_behavior?: boolean | null;
}
/**
 *
 * @export
 * @interface Data
 */
export interface Data {
  /**
   *
   * @type {string}
   * @memberof Data
   */
  fleet_name?: string | null;
  /**
   *
   * @type {Array<Task>}
   * @memberof Data
   */
  tasks?: Array<Task> | null;
}
/**
 *
 * @export
 * @interface Datum
 */
export interface Datum {
  /**
   * Name of the fleet that supports these activities
   * @type {string}
   * @memberof Datum
   */
  fleet_name: string;
  /**
   * List of activities that the fleet supports
   * @type {Array<Activity>}
   * @memberof Datum
   */
  activities: Array<Activity>;
}
/**
 *
 * @export
 * @interface DeliveryAlert
 */
export interface DeliveryAlert {
  /**
   *
   * @type {string}
   * @memberof DeliveryAlert
   */
  id: string;
  /**
   *
   * @type {ApiServerModelsDeliveryAlertsDeliveryAlertCategory}
   * @memberof DeliveryAlert
   */
  category: ApiServerModelsDeliveryAlertsDeliveryAlertCategory;
  /**
   *
   * @type {ApiServerModelsDeliveryAlertsDeliveryAlertTier}
   * @memberof DeliveryAlert
   */
  tier: ApiServerModelsDeliveryAlertsDeliveryAlertTier;
  /**
   *
   * @type {Action}
   * @memberof DeliveryAlert
   */
  action: Action;
  /**
   *
   * @type {string}
   * @memberof DeliveryAlert
   */
  task_id: string;
  /**
   *
   * @type {string}
   * @memberof DeliveryAlert
   */
  message: string;
}

/**
 * Detailed information about a task, phase, or event
 * @export
 * @interface Detail
 */
export interface Detail {}
/**
 * Detailed information about the issue
 * @export
 * @interface Detail1
 */
export interface Detail1 {}
/**
 *
 * @export
 * @interface Dispatch
 */
export interface Dispatch {
  /**
   *
   * @type {Status2}
   * @memberof Dispatch
   */
  status: Status2;
  /**
   *
   * @type {Assignment}
   * @memberof Dispatch
   */
  assignment?: Assignment | null;
  /**
   *
   * @type {Array<Error>}
   * @memberof Dispatch
   */
  errors?: Array<Error> | null;
}

/**
 *
 * @export
 * @interface DispatchTaskRequest
 */
export interface DispatchTaskRequest {
  /**
   * Indicate that this is a task dispatch request
   * @type {string}
   * @memberof DispatchTaskRequest
   */
  type: DispatchTaskRequestTypeEnum;
  /**
   *
   * @type {TaskRequest}
   * @memberof DispatchTaskRequest
   */
  request: TaskRequest;
}

export const DispatchTaskRequestTypeEnum = {
  DispatchTaskRequest: 'dispatch_task_request',
} as const;

export type DispatchTaskRequestTypeEnum =
  (typeof DispatchTaskRequestTypeEnum)[keyof typeof DispatchTaskRequestTypeEnum];

/**
 *
 * @export
 * @interface Dispenser
 */
export interface Dispenser {
  /**
   *
   * @type {string}
   * @memberof Dispenser
   */
  guid: string;
}
/**
 *
 * @export
 * @interface DispenserState
 */
export interface DispenserState {
  /**
   *
   * @type {Time}
   * @memberof DispenserState
   */
  time: Time;
  /**
   *
   * @type {string}
   * @memberof DispenserState
   */
  guid: string;
  /**
   *
   * @type {number}
   * @memberof DispenserState
   */
  mode: number;
  /**
   *
   * @type {Array<string>}
   * @memberof DispenserState
   */
  request_guid_queue: Array<string>;
  /**
   *
   * @type {number}
   * @memberof DispenserState
   */
  seconds_remaining: number;
}
/**
 *
 * @export
 * @interface Door
 */
export interface Door {
  /**
   *
   * @type {string}
   * @memberof Door
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof Door
   */
  v1_x: number;
  /**
   *
   * @type {number}
   * @memberof Door
   */
  v1_y: number;
  /**
   *
   * @type {number}
   * @memberof Door
   */
  v2_x: number;
  /**
   *
   * @type {number}
   * @memberof Door
   */
  v2_y: number;
  /**
   *
   * @type {number}
   * @memberof Door
   */
  door_type: number;
  /**
   *
   * @type {number}
   * @memberof Door
   */
  motion_range: number;
  /**
   *
   * @type {number}
   * @memberof Door
   */
  motion_direction: number;
}
/**
 *
 * @export
 * @interface DoorMode
 */
export interface DoorMode {
  /**
   *
   * @type {number}
   * @memberof DoorMode
   */
  value: number;
}
/**
 *
 * @export
 * @interface DoorRequest
 */
export interface DoorRequest {
  /**
   * https://github.com/open-rmf/rmf_internal_msgs/blob/main/rmf_door_msgs/msg/DoorMode.msg
   * @type {number}
   * @memberof DoorRequest
   */
  mode: number;
}
/**
 *
 * @export
 * @interface DoorState
 */
export interface DoorState {
  /**
   *
   * @type {Time}
   * @memberof DoorState
   */
  door_time: Time;
  /**
   *
   * @type {string}
   * @memberof DoorState
   */
  door_name: string;
  /**
   *
   * @type {DoorMode}
   * @memberof DoorState
   */
  current_mode: DoorMode;
}
/**
 *
 * @export
 * @interface EventStateInput
 */
export interface EventStateInput {
  /**
   *
   * @type {number}
   * @memberof EventStateInput
   */
  id: number;
  /**
   *
   * @type {StatusInput}
   * @memberof EventStateInput
   */
  status?: StatusInput | null;
  /**
   *
   * @type {string}
   * @memberof EventStateInput
   */
  name?: string | null;
  /**
   *
   * @type {Detail}
   * @memberof EventStateInput
   */
  detail?: Detail | null;
  /**
   *
   * @type {Array<number>}
   * @memberof EventStateInput
   */
  deps?: Array<number> | null;
}

/**
 *
 * @export
 * @interface EventStateOutput
 */
export interface EventStateOutput {
  /**
   *
   * @type {number}
   * @memberof EventStateOutput
   */
  id: number;
  /**
   *
   * @type {ApiServerModelsRmfApiTaskStateStatus}
   * @memberof EventStateOutput
   */
  status?: ApiServerModelsRmfApiTaskStateStatus | null;
  /**
   *
   * @type {string}
   * @memberof EventStateOutput
   */
  name?: string | null;
  /**
   *
   * @type {Detail}
   * @memberof EventStateOutput
   */
  detail?: Detail | null;
  /**
   *
   * @type {Array<number>}
   * @memberof EventStateOutput
   */
  deps?: Array<number> | null;
}

/**
 *
 * @export
 * @interface FireAlarmTriggerState
 */
export interface FireAlarmTriggerState {
  /**
   *
   * @type {number}
   * @memberof FireAlarmTriggerState
   */
  unix_millis_time: number;
  /**
   *
   * @type {boolean}
   * @memberof FireAlarmTriggerState
   */
  trigger: boolean;
}
/**
 *
 * @export
 * @interface FleetLog
 */
export interface FleetLog {
  /**
   *
   * @type {string}
   * @memberof FleetLog
   */
  name?: string | null;
  /**
   *
   * @type {Array<LogEntry>}
   * @memberof FleetLog
   */
  log?: Array<LogEntry> | null;
  /**
   *
   * @type {{ [key: string]: Array<LogEntry>; }}
   * @memberof FleetLog
   */
  robots?: { [key: string]: Array<LogEntry> } | null;
}
/**
 *
 * @export
 * @interface FleetState
 */
export interface FleetState {
  /**
   *
   * @type {string}
   * @memberof FleetState
   */
  name?: string | null;
  /**
   *
   * @type {{ [key: string]: RobotState; }}
   * @memberof FleetState
   */
  robots?: { [key: string]: RobotState } | null;
}
/**
 *
 * @export
 * @interface Graph
 */
export interface Graph {
  /**
   *
   * @type {string}
   * @memberof Graph
   */
  name: string;
  /**
   *
   * @type {Array<GraphNode>}
   * @memberof Graph
   */
  vertices: Array<GraphNode>;
  /**
   *
   * @type {Array<GraphEdge>}
   * @memberof Graph
   */
  edges: Array<GraphEdge>;
  /**
   *
   * @type {Array<Param>}
   * @memberof Graph
   */
  params: Array<Param>;
}
/**
 *
 * @export
 * @interface GraphEdge
 */
export interface GraphEdge {
  /**
   *
   * @type {number}
   * @memberof GraphEdge
   */
  v1_idx: number;
  /**
   *
   * @type {number}
   * @memberof GraphEdge
   */
  v2_idx: number;
  /**
   *
   * @type {Array<Param>}
   * @memberof GraphEdge
   */
  params: Array<Param>;
  /**
   *
   * @type {number}
   * @memberof GraphEdge
   */
  edge_type: number;
}
/**
 *
 * @export
 * @interface GraphNode
 */
export interface GraphNode {
  /**
   *
   * @type {number}
   * @memberof GraphNode
   */
  x: number;
  /**
   *
   * @type {number}
   * @memberof GraphNode
   */
  y: number;
  /**
   *
   * @type {string}
   * @memberof GraphNode
   */
  name: string;
  /**
   *
   * @type {Array<Param>}
   * @memberof GraphNode
   */
  params: Array<Param>;
}
/**
 *
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
  /**
   *
   * @type {Array<ValidationError>}
   * @memberof HTTPValidationError
   */
  detail?: Array<ValidationError>;
}
/**
 *
 * @export
 * @interface Ingestor
 */
export interface Ingestor {
  /**
   *
   * @type {string}
   * @memberof Ingestor
   */
  guid: string;
}
/**
 *
 * @export
 * @interface IngestorState
 */
export interface IngestorState {
  /**
   *
   * @type {Time}
   * @memberof IngestorState
   */
  time: Time;
  /**
   *
   * @type {string}
   * @memberof IngestorState
   */
  guid: string;
  /**
   *
   * @type {number}
   * @memberof IngestorState
   */
  mode: number;
  /**
   *
   * @type {Array<string>}
   * @memberof IngestorState
   */
  request_guid_queue: Array<string>;
  /**
   *
   * @type {number}
   * @memberof IngestorState
   */
  seconds_remaining: number;
}
/**
 *
 * @export
 * @interface Interruption
 */
export interface Interruption {
  /**
   * The time that the interruption request arrived
   * @type {number}
   * @memberof Interruption
   */
  unix_millis_request_time: number;
  /**
   * Labels to describe the purpose of the interruption, items can be a single value like `dashboard` or a key-value pair like `app=dashboard`, in the case of a single value, it will be interpreted as a key-value pair with an empty string value.
   * @type {Array<string>}
   * @memberof Interruption
   */
  labels: Array<string>;
  /**
   *
   * @type {ResumedBy}
   * @memberof Interruption
   */
  resumed_by?: ResumedBy | null;
}
/**
 *
 * @export
 * @interface Issue
 */
export interface Issue {
  /**
   *
   * @type {string}
   * @memberof Issue
   */
  category?: string | null;
  /**
   *
   * @type {Detail1}
   * @memberof Issue
   */
  detail?: Detail1 | null;
}
/**
 *
 * @export
 * @interface Killed
 */
export interface Killed {
  /**
   * The time that the cancellation request arrived
   * @type {number}
   * @memberof Killed
   */
  unix_millis_request_time: number;
  /**
   * Labels to describe the kill request, items can be a single value like `dashboard` or a key-value pair like `app=dashboard`, in the case of a single value, it will be interpreted as a key-value pair with an empty string value.
   * @type {Array<string>}
   * @memberof Killed
   */
  labels: Array<string>;
}
/**
 *
 * @export
 * @interface Level
 */
export interface Level {
  /**
   *
   * @type {string}
   * @memberof Level
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof Level
   */
  elevation: number;
  /**
   *
   * @type {Array<AffineImage>}
   * @memberof Level
   */
  images: Array<AffineImage>;
  /**
   *
   * @type {Array<Place>}
   * @memberof Level
   */
  places: Array<Place>;
  /**
   *
   * @type {Array<Door>}
   * @memberof Level
   */
  doors: Array<Door>;
  /**
   *
   * @type {Array<Graph>}
   * @memberof Level
   */
  nav_graphs: Array<Graph>;
  /**
   *
   * @type {Graph}
   * @memberof Level
   */
  wall_graph: Graph;
}
/**
 *
 * @export
 * @interface Lift
 */
export interface Lift {
  /**
   *
   * @type {string}
   * @memberof Lift
   */
  name: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Lift
   */
  levels: Array<string>;
  /**
   *
   * @type {Array<Door>}
   * @memberof Lift
   */
  doors: Array<Door>;
  /**
   *
   * @type {Graph}
   * @memberof Lift
   */
  wall_graph: Graph;
  /**
   *
   * @type {number}
   * @memberof Lift
   */
  ref_x: number;
  /**
   *
   * @type {number}
   * @memberof Lift
   */
  ref_y: number;
  /**
   *
   * @type {number}
   * @memberof Lift
   */
  ref_yaw: number;
  /**
   *
   * @type {number}
   * @memberof Lift
   */
  width: number;
  /**
   *
   * @type {number}
   * @memberof Lift
   */
  depth: number;
}
/**
 *
 * @export
 * @interface LiftRequest
 */
export interface LiftRequest {
  /**
   * https://github.com/open-rmf/rmf_internal_msgs/blob/main/rmf_lift_msgs/msg/LiftRequest.msg
   * @type {number}
   * @memberof LiftRequest
   */
  request_type: number;
  /**
   * https://github.com/open-rmf/rmf_internal_msgs/blob/main/rmf_lift_msgs/msg/LiftRequest.msg
   * @type {number}
   * @memberof LiftRequest
   */
  door_mode: number;
  /**
   *
   * @type {string}
   * @memberof LiftRequest
   */
  destination: string;
  /**
   * By default the node name of the API server is used, this field allows publishing the same request to additional session IDs
   * @type {Array<string>}
   * @memberof LiftRequest
   */
  additional_session_ids?: Array<string>;
}
/**
 *
 * @export
 * @interface LiftState
 */
export interface LiftState {
  /**
   *
   * @type {Time}
   * @memberof LiftState
   */
  lift_time: Time;
  /**
   *
   * @type {string}
   * @memberof LiftState
   */
  lift_name: string;
  /**
   *
   * @type {Array<string>}
   * @memberof LiftState
   */
  available_floors: Array<string>;
  /**
   *
   * @type {string}
   * @memberof LiftState
   */
  current_floor: string;
  /**
   *
   * @type {string}
   * @memberof LiftState
   */
  destination_floor: string;
  /**
   *
   * @type {number}
   * @memberof LiftState
   */
  door_state: number;
  /**
   *
   * @type {number}
   * @memberof LiftState
   */
  motion_state: number;
  /**
   *
   * @type {Array<number>}
   * @memberof LiftState
   */
  available_modes: Array<number>;
  /**
   *
   * @type {number}
   * @memberof LiftState
   */
  current_mode: number;
  /**
   *
   * @type {string}
   * @memberof LiftState
   */
  session_id: string;
}
/**
 *
 * @export
 * @interface Location2D
 */
export interface Location2D {
  /**
   *
   * @type {string}
   * @memberof Location2D
   */
  map: string;
  /**
   *
   * @type {number}
   * @memberof Location2D
   */
  x: number;
  /**
   *
   * @type {number}
   * @memberof Location2D
   */
  y: number;
  /**
   *
   * @type {number}
   * @memberof Location2D
   */
  yaw: number;
}
/**
 *
 * @export
 * @interface LocationInner
 */
export interface LocationInner {}
/**
 *
 * @export
 * @interface LogEntry
 */
export interface LogEntry {
  /**
   * Sequence number for this entry. Each entry has a unique sequence number which monotonically increase, until integer overflow causes a wrap around.
   * @type {number}
   * @memberof LogEntry
   */
  seq: number;
  /**
   * The importance level of the log entry
   * @type {ApiServerModelsRmfApiLogEntryTier}
   * @memberof LogEntry
   */
  tier: ApiServerModelsRmfApiLogEntryTier;
  /**
   *
   * @type {number}
   * @memberof LogEntry
   */
  unix_millis_time: number;
  /**
   * The text of the log entry
   * @type {string}
   * @memberof LogEntry
   */
  text: string;
}

/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
  /**
   *
   * @type {number}
   * @memberof ModelError
   */
  code?: number | null;
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  category?: string | null;
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  detail?: string | null;
}
/**
 *
 * @export
 * @interface MutexGroups
 */
export interface MutexGroups {
  /**
   *
   * @type {Array<string>}
   * @memberof MutexGroups
   */
  locked?: Array<string> | null;
  /**
   *
   * @type {Array<string>}
   * @memberof MutexGroups
   */
  requesting?: Array<string> | null;
}
/**
 *
 * @export
 * @interface Pagination
 */
export interface Pagination {
  /**
   *
   * @type {number}
   * @memberof Pagination
   */
  limit: number;
  /**
   *
   * @type {number}
   * @memberof Pagination
   */
  offset: number;
  /**
   *
   * @type {Array<string>}
   * @memberof Pagination
   */
  order_by: Array<string>;
}
/**
 *
 * @export
 * @interface Param
 */
export interface Param {
  /**
   *
   * @type {string}
   * @memberof Param
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof Param
   */
  type: number;
  /**
   *
   * @type {number}
   * @memberof Param
   */
  value_int: number;
  /**
   *
   * @type {number}
   * @memberof Param
   */
  value_float: number;
  /**
   *
   * @type {string}
   * @memberof Param
   */
  value_string: string;
  /**
   *
   * @type {boolean}
   * @memberof Param
   */
  value_bool: boolean;
}
/**
 *
 * @export
 * @enum {string}
 */

export const Period = {
  Monday: 'monday',
  Tuesday: 'tuesday',
  Wednesday: 'wednesday',
  Thursday: 'thursday',
  Friday: 'friday',
  Saturday: 'saturday',
  Sunday: 'sunday',
  Day: 'day',
  Hour: 'hour',
  Minute: 'minute',
} as const;

export type Period = (typeof Period)[keyof typeof Period];

/**
 *
 * @export
 * @interface Permission
 */
export interface Permission {
  /**
   *
   * @type {string}
   * @memberof Permission
   */
  authz_grp: string;
  /**
   *
   * @type {string}
   * @memberof Permission
   */
  action: string;
}
/**
 *
 * @export
 * @interface PhaseInput
 */
export interface PhaseInput {
  /**
   *
   * @type {number}
   * @memberof PhaseInput
   */
  id: number;
  /**
   * The category of this task or phase
   * @type {string}
   * @memberof PhaseInput
   */
  category?: string;
  /**
   *
   * @type {Detail}
   * @memberof PhaseInput
   */
  detail?: Detail | null;
  /**
   *
   * @type {number}
   * @memberof PhaseInput
   */
  unix_millis_start_time?: number | null;
  /**
   *
   * @type {number}
   * @memberof PhaseInput
   */
  unix_millis_finish_time?: number | null;
  /**
   * An estimate, in milliseconds, of how long the subject will take to complete
   * @type {number}
   * @memberof PhaseInput
   */
  original_estimate_millis?: number;
  /**
   * An estimate, in milliseconds, of how long the subject will take to complete
   * @type {number}
   * @memberof PhaseInput
   */
  estimate_millis?: number;
  /**
   *
   * @type {number}
   * @memberof PhaseInput
   */
  final_event_id?: number;
  /**
   *
   * @type {{ [key: string]: EventStateInput; }}
   * @memberof PhaseInput
   */
  events?: { [key: string]: EventStateInput } | null;
  /**
   *
   * @type {{ [key: string]: SkipPhaseRequest; }}
   * @memberof PhaseInput
   */
  skip_requests?: { [key: string]: SkipPhaseRequest } | null;
}
/**
 *
 * @export
 * @interface PhaseOutput
 */
export interface PhaseOutput {
  /**
   *
   * @type {number}
   * @memberof PhaseOutput
   */
  id: number;
  /**
   * The category of this task or phase
   * @type {string}
   * @memberof PhaseOutput
   */
  category?: string;
  /**
   *
   * @type {Detail}
   * @memberof PhaseOutput
   */
  detail?: Detail | null;
  /**
   *
   * @type {number}
   * @memberof PhaseOutput
   */
  unix_millis_start_time?: number | null;
  /**
   *
   * @type {number}
   * @memberof PhaseOutput
   */
  unix_millis_finish_time?: number | null;
  /**
   * An estimate, in milliseconds, of how long the subject will take to complete
   * @type {number}
   * @memberof PhaseOutput
   */
  original_estimate_millis?: number;
  /**
   * An estimate, in milliseconds, of how long the subject will take to complete
   * @type {number}
   * @memberof PhaseOutput
   */
  estimate_millis?: number;
  /**
   *
   * @type {number}
   * @memberof PhaseOutput
   */
  final_event_id?: number;
  /**
   *
   * @type {{ [key: string]: EventStateOutput; }}
   * @memberof PhaseOutput
   */
  events?: { [key: string]: EventStateOutput } | null;
  /**
   *
   * @type {{ [key: string]: SkipPhaseRequest; }}
   * @memberof PhaseOutput
   */
  skip_requests?: { [key: string]: SkipPhaseRequest } | null;
}
/**
 *
 * @export
 * @interface Phases
 */
export interface Phases {
  /**
   *
   * @type {Array<LogEntry>}
   * @memberof Phases
   */
  log?: Array<LogEntry> | null;
  /**
   *
   * @type {{ [key: string]: Array<LogEntry>; }}
   * @memberof Phases
   */
  events?: { [key: string]: Array<LogEntry> } | null;
}
/**
 *
 * @export
 * @interface Place
 */
export interface Place {
  /**
   *
   * @type {string}
   * @memberof Place
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof Place
   */
  x: number;
  /**
   *
   * @type {number}
   * @memberof Place
   */
  y: number;
  /**
   *
   * @type {number}
   * @memberof Place
   */
  yaw: number;
  /**
   *
   * @type {number}
   * @memberof Place
   */
  position_tolerance: number;
  /**
   *
   * @type {number}
   * @memberof Place
   */
  yaw_tolerance: number;
}
/**
 *
 * @export
 * @interface PostMakeAdmin
 */
export interface PostMakeAdmin {
  /**
   *
   * @type {boolean}
   * @memberof PostMakeAdmin
   */
  admin: boolean;
}
/**
 *
 * @export
 * @interface PostRoles
 */
export interface PostRoles {
  /**
   *
   * @type {string}
   * @memberof PostRoles
   */
  name: string;
}
/**
 *
 * @export
 * @interface PostScheduledTaskRequest
 */
export interface PostScheduledTaskRequest {
  /**
   *
   * @type {TaskRequest}
   * @memberof PostScheduledTaskRequest
   */
  task_request: TaskRequest;
  /**
   *
   * @type {Array<ScheduledTaskScheduleInput>}
   * @memberof PostScheduledTaskRequest
   */
  schedules: Array<ScheduledTaskScheduleInput>;
  /**
   *
   * @type {string}
   * @memberof PostScheduledTaskRequest
   */
  start_from?: string | null;
  /**
   *
   * @type {string}
   * @memberof PostScheduledTaskRequest
   */
  until?: string | null;
  /**
   * A list of dates which the schedule should be skipped, this is based on the server date. The time portion will be discarded, it is only used to convert the date to the server timezone.
   * @type {Array<string>}
   * @memberof PostScheduledTaskRequest
   */
  except_dates?: Array<string>;
}
/**
 *
 * @export
 * @interface PostUsers
 */
export interface PostUsers {
  /**
   *
   * @type {string}
   * @memberof PostUsers
   */
  username: string;
  /**
   *
   * @type {boolean}
   * @memberof PostUsers
   */
  is_admin?: boolean;
}
/**
 * Priority information about this task
 * @export
 * @interface Priority
 */
export interface Priority {}
/**
 *
 * @export
 * @interface Result
 */
export interface Result {
  /**
   *
   * @type {boolean}
   * @memberof Result
   */
  success: boolean;
  /**
   *
   * @type {Array<Error>}
   * @memberof Result
   */
  errors?: Array<Error> | null;
}
/**
 *
 * @export
 * @interface Result1
 */
export interface Result1 {
  /**
   *
   * @type {boolean}
   * @memberof Result1
   */
  success: boolean;
}
/**
 *
 * @export
 * @interface Result2
 */
export interface Result2 {
  /**
   *
   * @type {boolean}
   * @memberof Result2
   */
  success: boolean;
  /**
   *
   * @type {Array<Error>}
   * @memberof Result2
   */
  errors?: Array<Error> | null;
}
/**
 *
 * @export
 * @interface ResumedBy
 */
export interface ResumedBy {
  /**
   *
   * @type {number}
   * @memberof ResumedBy
   */
  unix_millis_request_time?: number | null;
  /**
   * Labels to describe the resume request, items can be a single value like `dashboard` or a key-value pair like `app=dashboard`, in the case of a single value, it will be interpreted as a key-value pair with an empty string value.
   * @type {Array<string>}
   * @memberof ResumedBy
   */
  labels: Array<string>;
}
/**
 *
 * @export
 * @interface Rio
 */
export interface Rio {
  /**
   *
   * @type {string}
   * @memberof Rio
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Rio
   */
  type: string;
  /**
   *
   * @type {object}
   * @memberof Rio
   */
  data: object;
}
/**
 *
 * @export
 * @interface RobotCommissionResponse
 */
export interface RobotCommissionResponse {
  /**
   *
   * @type {Result}
   * @memberof RobotCommissionResponse
   */
  commission: Result;
  /**
   *
   * @type {Result}
   * @memberof RobotCommissionResponse
   */
  pending_dispatch_tasks_policy?: Result | null;
  /**
   *
   * @type {Result}
   * @memberof RobotCommissionResponse
   */
  pending_direct_tasks_policy?: Result | null;
}
/**
 *
 * @export
 * @interface RobotState
 */
export interface RobotState {
  /**
   *
   * @type {string}
   * @memberof RobotState
   */
  name?: string | null;
  /**
   *
   * @type {ApiServerModelsRmfApiRobotStateStatus}
   * @memberof RobotState
   */
  status?: ApiServerModelsRmfApiRobotStateStatus | null;
  /**
   *
   * @type {string}
   * @memberof RobotState
   */
  task_id?: string | null;
  /**
   *
   * @type {number}
   * @memberof RobotState
   */
  unix_millis_time?: number | null;
  /**
   *
   * @type {Location2D}
   * @memberof RobotState
   */
  location?: Location2D | null;
  /**
   *
   * @type {number}
   * @memberof RobotState
   */
  battery?: number | null;
  /**
   *
   * @type {Array<Issue>}
   * @memberof RobotState
   */
  issues?: Array<Issue> | null;
  /**
   *
   * @type {Commission}
   * @memberof RobotState
   */
  commission?: Commission | null;
  /**
   *
   * @type {MutexGroups}
   * @memberof RobotState
   */
  mutex_groups?: MutexGroups | null;
}

/**
 *
 * @export
 * @interface RobotTaskRequest
 */
export interface RobotTaskRequest {
  /**
   * Indicate that this is a direct task request
   * @type {string}
   * @memberof RobotTaskRequest
   */
  type: string;
  /**
   * The name of the robot
   * @type {string}
   * @memberof RobotTaskRequest
   */
  robot: string;
  /**
   * The fleet the robot belongs to
   * @type {string}
   * @memberof RobotTaskRequest
   */
  fleet: string;
  /**
   *
   * @type {TaskRequest}
   * @memberof RobotTaskRequest
   */
  request: TaskRequest;
}
/**
 * Response to a robot task request
 * @export
 * @interface RobotTaskResponseInput
 */
export interface RobotTaskResponseInput {
  /**
   *
   * @type {boolean}
   * @memberof RobotTaskResponseInput
   */
  success: boolean | null;
  /**
   *
   * @type {TaskStateInput}
   * @memberof RobotTaskResponseInput
   */
  state: TaskStateInput;
  /**
   *
   * @type {Array<Error>}
   * @memberof RobotTaskResponseInput
   */
  errors?: Array<Error> | null;
}
/**
 * Response to a robot task request
 * @export
 * @interface RobotTaskResponseOutput
 */
export interface RobotTaskResponseOutput {
  /**
   *
   * @type {boolean}
   * @memberof RobotTaskResponseOutput
   */
  success: boolean | null;
  /**
   *
   * @type {TaskStateOutput}
   * @memberof RobotTaskResponseOutput
   */
  state: TaskStateOutput;
  /**
   *
   * @type {Array<Error>}
   * @memberof RobotTaskResponseOutput
   */
  errors?: Array<Error> | null;
}
/**
 *
 * @export
 * @interface ScheduledTask
 */
export interface ScheduledTask {
  /**
   *
   * @type {number}
   * @memberof ScheduledTask
   */
  id: number;
  /**
   *
   * @type {TaskRequest}
   * @memberof ScheduledTask
   */
  task_request: TaskRequest;
  /**
   *
   * @type {string}
   * @memberof ScheduledTask
   */
  created_by: string;
  /**
   *
   * @type {Array<ScheduledTaskScheduleOutput>}
   * @memberof ScheduledTask
   */
  schedules: Array<ScheduledTaskScheduleOutput>;
  /**
   *
   * @type {string}
   * @memberof ScheduledTask
   */
  last_ran: string | null;
  /**
   *
   * @type {string}
   * @memberof ScheduledTask
   */
  start_from: string | null;
  /**
   *
   * @type {string}
   * @memberof ScheduledTask
   */
  until: string | null;
  /**
   *
   * @type {Array<string>}
   * @memberof ScheduledTask
   */
  except_dates: Array<string>;
}
/**
 *
 * @export
 * @interface ScheduledTaskScheduleInput
 */
export interface ScheduledTaskScheduleInput {
  /**
   *
   * @type {number}
   * @memberof ScheduledTaskScheduleInput
   */
  every?: number | null;
  /**
   *
   * @type {Period}
   * @memberof ScheduledTaskScheduleInput
   */
  period: Period;
  /**
   *
   * @type {string}
   * @memberof ScheduledTaskScheduleInput
   */
  at: string;
}

/**
 *
 * @export
 * @interface ScheduledTaskScheduleOutput
 */
export interface ScheduledTaskScheduleOutput {
  /**
   *
   * @type {number}
   * @memberof ScheduledTaskScheduleOutput
   */
  every: number | null;
  /**
   *
   * @type {Period}
   * @memberof ScheduledTaskScheduleOutput
   */
  period: Period;
  /**
   *
   * @type {string}
   * @memberof ScheduledTaskScheduleOutput
   */
  at: string;
}

/**
 * Template for defining a response message that only indicates success and describes any errors
 * @export
 * @interface SimpleResponse
 */
export interface SimpleResponse {
  /**
   * The request failed
   * @type {boolean}
   * @memberof SimpleResponse
   */
  success: boolean;
  /**
   * If the request failed, these error messages will explain why
   * @type {Array<Error>}
   * @memberof SimpleResponse
   */
  errors: Array<Error>;
}
/**
 *
 * @export
 * @interface SimpleResponse1
 */
export interface SimpleResponse1 {
  /**
   * The request was successful
   * @type {boolean}
   * @memberof SimpleResponse1
   */
  success: boolean;
}
/**
 *
 * @export
 * @interface SimpleResponse2
 */
export interface SimpleResponse2 {
  /**
   * The request failed
   * @type {boolean}
   * @memberof SimpleResponse2
   */
  success: boolean;
  /**
   * If the request failed, these error messages will explain why
   * @type {Array<Error>}
   * @memberof SimpleResponse2
   */
  errors: Array<Error>;
}
/**
 *
 * @export
 * @interface SkipPhaseRequest
 */
export interface SkipPhaseRequest {
  /**
   * The time that the skip request arrived
   * @type {number}
   * @memberof SkipPhaseRequest
   */
  unix_millis_request_time: number;
  /**
   * Labels to describe the purpose of the skip request, items can be a single value like `dashboard` or a key-value pair like `app=dashboard`, in the case of a single value, it will be interpreted as a key-value pair with an empty string value.
   * @type {Array<string>}
   * @memberof SkipPhaseRequest
   */
  labels: Array<string>;
  /**
   *
   * @type {Undo}
   * @memberof SkipPhaseRequest
   */
  undo?: Undo | null;
}
/**
 * Response to a request for a phase to be skipped
 * @export
 * @interface SkipPhaseResponse
 */
export interface SkipPhaseResponse {
  /**
   * The request failed
   * @type {boolean}
   * @memberof SkipPhaseResponse
   */
  success: boolean;
  /**
   * A token for the request. The value of this token is unique within the scope of this request and can be used by other requests to reference this request.
   * @type {string}
   * @memberof SkipPhaseResponse
   */
  token: string;
  /**
   * Any error messages explaining why the request failed.
   * @type {Array<Error>}
   * @memberof SkipPhaseResponse
   */
  errors: Array<Error>;
}
/**
 *
 * @export
 * @enum {string}
 */

export const Status2 = {
  Queued: 'queued',
  Selected: 'selected',
  Dispatched: 'dispatched',
  FailedToAssign: 'failed_to_assign',
  CanceledInFlight: 'canceled_in_flight',
} as const;

export type Status2 = (typeof Status2)[keyof typeof Status2];

/**
 *
 * @export
 * @enum {string}
 */

export const StatusInput = {
  Uninitialized: 'uninitialized',
  Blocked: 'blocked',
  Error: 'error',
  Failed: 'failed',
  Queued: 'queued',
  Standby: 'standby',
  Underway: 'underway',
  Delayed: 'delayed',
  Skipped: 'skipped',
  Canceled: 'canceled',
  Killed: 'killed',
  Completed: 'completed',
} as const;

export type StatusInput = (typeof StatusInput)[keyof typeof StatusInput];

/**
 *
 * @export
 * @interface Task
 */
export interface Task {
  /**
   * The category of this task. There must not be any duplicate task categories per fleet.
   * @type {string}
   * @memberof Task
   */
  category: string;
  /**
   * Details about the behavior of the task.
   * @type {string}
   * @memberof Task
   */
  detail: string;
  /**
   *
   * @type {object}
   * @memberof Task
   */
  description_schema?: object | null;
}
/**
 * Response to a request to cancel a task
 * @export
 * @interface TaskCancelResponse
 */
export interface TaskCancelResponse {
  /**
   * The request failed
   * @type {boolean}
   * @memberof TaskCancelResponse
   */
  success: boolean;
  /**
   * If the request failed, these error messages will explain why
   * @type {Array<Error>}
   * @memberof TaskCancelResponse
   */
  errors: Array<Error>;
}
/**
 *
 * @export
 * @interface TaskDiscovery
 */
export interface TaskDiscovery {
  /**
   * Indicate that this is an task discovery update
   * @type {string}
   * @memberof TaskDiscovery
   */
  type: TaskDiscoveryTypeEnum;
  /**
   *
   * @type {Data}
   * @memberof TaskDiscovery
   */
  data: Data;
}

export const TaskDiscoveryTypeEnum = {
  TaskDiscoveryUpdate: 'task_discovery_update',
} as const;

export type TaskDiscoveryTypeEnum =
  (typeof TaskDiscoveryTypeEnum)[keyof typeof TaskDiscoveryTypeEnum];

/**
 *
 * @export
 * @interface TaskDiscoveryRequest
 */
export interface TaskDiscoveryRequest {
  /**
   * Indicate that this is a task discovery request
   * @type {string}
   * @memberof TaskDiscoveryRequest
   */
  type: TaskDiscoveryRequestTypeEnum;
}

export const TaskDiscoveryRequestTypeEnum = {
  TaskDiscoveryRequest: 'task_discovery_request',
} as const;

export type TaskDiscoveryRequestTypeEnum =
  (typeof TaskDiscoveryRequestTypeEnum)[keyof typeof TaskDiscoveryRequestTypeEnum];

/**
 *
 * @export
 * @interface TaskDispatchResponse1Input
 */
export interface TaskDispatchResponse1Input {
  /**
   *
   * @type {boolean}
   * @memberof TaskDispatchResponse1Input
   */
  success: boolean;
  /**
   *
   * @type {TaskStateInput}
   * @memberof TaskDispatchResponse1Input
   */
  state: TaskStateInput;
}
/**
 *
 * @export
 * @interface TaskDispatchResponse1Output
 */
export interface TaskDispatchResponse1Output {
  /**
   *
   * @type {boolean}
   * @memberof TaskDispatchResponse1Output
   */
  success: boolean;
  /**
   *
   * @type {TaskStateOutput}
   * @memberof TaskDispatchResponse1Output
   */
  state: TaskStateOutput;
}
/**
 *
 * @export
 * @interface TaskDispatchResponse2
 */
export interface TaskDispatchResponse2 {
  /**
   *
   * @type {boolean}
   * @memberof TaskDispatchResponse2
   */
  success?: boolean | null;
  /**
   *
   * @type {Array<Error>}
   * @memberof TaskDispatchResponse2
   */
  errors?: Array<Error> | null;
}
/**
 * Response to a task dispatch request
 * @export
 * @interface TaskDispatchResponseInput
 */
export interface TaskDispatchResponseInput {
  /**
   *
   * @type {boolean}
   * @memberof TaskDispatchResponseInput
   */
  success: boolean | null;
  /**
   *
   * @type {TaskStateInput}
   * @memberof TaskDispatchResponseInput
   */
  state: TaskStateInput;
  /**
   *
   * @type {Array<Error>}
   * @memberof TaskDispatchResponseInput
   */
  errors?: Array<Error> | null;
}
/**
 * Response to a task dispatch request
 * @export
 * @interface TaskDispatchResponseOutput
 */
export interface TaskDispatchResponseOutput {
  /**
   *
   * @type {boolean}
   * @memberof TaskDispatchResponseOutput
   */
  success: boolean | null;
  /**
   *
   * @type {TaskStateOutput}
   * @memberof TaskDispatchResponseOutput
   */
  state: TaskStateOutput;
  /**
   *
   * @type {Array<Error>}
   * @memberof TaskDispatchResponseOutput
   */
  errors?: Array<Error> | null;
}
/**
 *
 * @export
 * @interface TaskEventLog
 */
export interface TaskEventLog {
  /**
   *
   * @type {string}
   * @memberof TaskEventLog
   */
  task_id: string;
  /**
   *
   * @type {Array<LogEntry>}
   * @memberof TaskEventLog
   */
  log?: Array<LogEntry> | null;
  /**
   *
   * @type {{ [key: string]: Phases; }}
   * @memberof TaskEventLog
   */
  phases?: { [key: string]: Phases } | null;
}
/**
 *
 * @export
 * @interface TaskFavorite
 */
export interface TaskFavorite {
  /**
   *
   * @type {string}
   * @memberof TaskFavorite
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof TaskFavorite
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof TaskFavorite
   */
  unix_millis_earliest_start_time: number;
  /**
   *
   * @type {object}
   * @memberof TaskFavorite
   */
  priority: object | null;
  /**
   *
   * @type {string}
   * @memberof TaskFavorite
   */
  category: string;
  /**
   *
   * @type {object}
   * @memberof TaskFavorite
   */
  description: object | null;
  /**
   *
   * @type {string}
   * @memberof TaskFavorite
   */
  user: string;
  /**
   *
   * @type {string}
   * @memberof TaskFavorite
   */
  task_definition_id: string;
}
/**
 *
 * @export
 * @interface TaskInterruptionRequest
 */
export interface TaskInterruptionRequest {
  /**
   * Indicate that this is a task interruption request
   * @type {string}
   * @memberof TaskInterruptionRequest
   */
  type: TaskInterruptionRequestTypeEnum;
  /**
   * Specify the task ID to interrupt
   * @type {string}
   * @memberof TaskInterruptionRequest
   */
  task_id: string;
  /**
   *
   * @type {Array<string>}
   * @memberof TaskInterruptionRequest
   */
  labels?: Array<string> | null;
}

export const TaskInterruptionRequestTypeEnum = {
  InterruptTaskRequest: 'interrupt_task_request',
} as const;

export type TaskInterruptionRequestTypeEnum =
  (typeof TaskInterruptionRequestTypeEnum)[keyof typeof TaskInterruptionRequestTypeEnum];

/**
 * Response to a request for a task to be interrupted
 * @export
 * @interface TaskInterruptionResponse
 */
export interface TaskInterruptionResponse {
  /**
   * The request failed
   * @type {boolean}
   * @memberof TaskInterruptionResponse
   */
  success: boolean;
  /**
   * A token for the request. The value of this token is unique within the scope of this request and can be used by other requests to reference this request.
   * @type {string}
   * @memberof TaskInterruptionResponse
   */
  token: string;
  /**
   * Any error messages explaining why the request failed.
   * @type {Array<Error>}
   * @memberof TaskInterruptionResponse
   */
  errors: Array<Error>;
}
/**
 *
 * @export
 * @interface TaskKillRequest
 */
export interface TaskKillRequest {
  /**
   * Indicate that this is a task kill request
   * @type {string}
   * @memberof TaskKillRequest
   */
  type: TaskKillRequestTypeEnum;
  /**
   * Specify the task ID to kill
   * @type {string}
   * @memberof TaskKillRequest
   */
  task_id: string;
  /**
   *
   * @type {Array<string>}
   * @memberof TaskKillRequest
   */
  labels?: Array<string> | null;
}

export const TaskKillRequestTypeEnum = {
  KillTaskRequest: 'kill_task_request',
} as const;

export type TaskKillRequestTypeEnum =
  (typeof TaskKillRequestTypeEnum)[keyof typeof TaskKillRequestTypeEnum];

/**
 * Response to a request to kill a task
 * @export
 * @interface TaskKillResponse
 */
export interface TaskKillResponse {
  /**
   * The request failed
   * @type {boolean}
   * @memberof TaskKillResponse
   */
  success: boolean;
  /**
   * If the request failed, these error messages will explain why
   * @type {Array<Error>}
   * @memberof TaskKillResponse
   */
  errors: Array<Error>;
}
/**
 *
 * @export
 * @interface TaskPhaseSkipRequest
 */
export interface TaskPhaseSkipRequest {
  /**
   * Indicate that this is a phase skip request
   * @type {string}
   * @memberof TaskPhaseSkipRequest
   */
  type: TaskPhaseSkipRequestTypeEnum;
  /**
   * Specify the task ID whose phase should be skipped
   * @type {string}
   * @memberof TaskPhaseSkipRequest
   */
  task_id: string;
  /**
   * Specify the phase that should be skipped
   * @type {number}
   * @memberof TaskPhaseSkipRequest
   */
  phase_id: number;
  /**
   *
   * @type {Array<string>}
   * @memberof TaskPhaseSkipRequest
   */
  labels?: Array<string> | null;
}

export const TaskPhaseSkipRequestTypeEnum = {
  SkipPhaseRequest: 'skip_phase_request',
} as const;

export type TaskPhaseSkipRequestTypeEnum =
  (typeof TaskPhaseSkipRequestTypeEnum)[keyof typeof TaskPhaseSkipRequestTypeEnum];

/**
 *
 * @export
 * @interface TaskRequest
 */
export interface TaskRequest {
  /**
   *
   * @type {number}
   * @memberof TaskRequest
   */
  unix_millis_earliest_start_time?: number | null;
  /**
   *
   * @type {number}
   * @memberof TaskRequest
   */
  unix_millis_request_time?: number | null;
  /**
   *
   * @type {object}
   * @memberof TaskRequest
   */
  priority?: object | null;
  /**
   *
   * @type {string}
   * @memberof TaskRequest
   */
  category: string;
  /**
   * A description of the task. This must match a schema supported by a fleet for the category of this task request.
   * @type {any}
   * @memberof TaskRequest
   */
  description: any;
  /**
   *
   * @type {Array<string>}
   * @memberof TaskRequest
   */
  labels?: Array<string> | null;
  /**
   *
   * @type {string}
   * @memberof TaskRequest
   */
  requester?: string | null;
  /**
   *
   * @type {string}
   * @memberof TaskRequest
   */
  fleet_name?: string | null;
}
/**
 *
 * @export
 * @interface TaskResumeRequest
 */
export interface TaskResumeRequest {
  /**
   *
   * @type {string}
   * @memberof TaskResumeRequest
   */
  type?: TaskResumeRequestTypeEnum | null;
  /**
   *
   * @type {string}
   * @memberof TaskResumeRequest
   */
  for_task?: string | null;
  /**
   *
   * @type {Array<string>}
   * @memberof TaskResumeRequest
   */
  for_tokens?: Array<string> | null;
  /**
   *
   * @type {Array<string>}
   * @memberof TaskResumeRequest
   */
  labels?: Array<string> | null;
}

export const TaskResumeRequestTypeEnum = {
  ResumeTaskRequest: 'resume_task_request',
} as const;

export type TaskResumeRequestTypeEnum =
  (typeof TaskResumeRequestTypeEnum)[keyof typeof TaskResumeRequestTypeEnum];

/**
 * Response to a request to resume a task
 * @export
 * @interface TaskResumeResponse
 */
export interface TaskResumeResponse {
  /**
   * The request failed
   * @type {boolean}
   * @memberof TaskResumeResponse
   */
  success: boolean;
  /**
   * If the request failed, these error messages will explain why
   * @type {Array<Error>}
   * @memberof TaskResumeResponse
   */
  errors: Array<Error>;
}
/**
 *
 * @export
 * @interface TaskRewindRequest
 */
export interface TaskRewindRequest {
  /**
   * Indicate that this is a task rewind request
   * @type {string}
   * @memberof TaskRewindRequest
   */
  type: TaskRewindRequestTypeEnum;
  /**
   * Specify the ID of the task that should rewind
   * @type {string}
   * @memberof TaskRewindRequest
   */
  task_id: string;
  /**
   * Specify the phase that should be rewound to. The task will restart at the beginning of this phase.
   * @type {number}
   * @memberof TaskRewindRequest
   */
  phase_id: number;
}

export const TaskRewindRequestTypeEnum = {
  RewindTaskRequest: 'rewind_task_request',
} as const;

export type TaskRewindRequestTypeEnum =
  (typeof TaskRewindRequestTypeEnum)[keyof typeof TaskRewindRequestTypeEnum];

/**
 * Response to a request to rewind a task
 * @export
 * @interface TaskRewindResponse
 */
export interface TaskRewindResponse {
  /**
   * The request failed
   * @type {boolean}
   * @memberof TaskRewindResponse
   */
  success: boolean;
  /**
   * If the request failed, these error messages will explain why
   * @type {Array<Error>}
   * @memberof TaskRewindResponse
   */
  errors: Array<Error>;
}
/**
 *
 * @export
 * @interface TaskStateInput
 */
export interface TaskStateInput {
  /**
   *
   * @type {Booking}
   * @memberof TaskStateInput
   */
  booking: Booking;
  /**
   * The category of this task or phase
   * @type {string}
   * @memberof TaskStateInput
   */
  category?: string;
  /**
   *
   * @type {Detail}
   * @memberof TaskStateInput
   */
  detail?: Detail | null;
  /**
   *
   * @type {number}
   * @memberof TaskStateInput
   */
  unix_millis_start_time?: number | null;
  /**
   *
   * @type {number}
   * @memberof TaskStateInput
   */
  unix_millis_finish_time?: number | null;
  /**
   * An estimate, in milliseconds, of how long the subject will take to complete
   * @type {number}
   * @memberof TaskStateInput
   */
  original_estimate_millis?: number;
  /**
   * An estimate, in milliseconds, of how long the subject will take to complete
   * @type {number}
   * @memberof TaskStateInput
   */
  estimate_millis?: number;
  /**
   *
   * @type {AssignedTo}
   * @memberof TaskStateInput
   */
  assigned_to?: AssignedTo | null;
  /**
   *
   * @type {StatusInput}
   * @memberof TaskStateInput
   */
  status?: StatusInput | null;
  /**
   *
   * @type {Dispatch}
   * @memberof TaskStateInput
   */
  dispatch?: Dispatch | null;
  /**
   *
   * @type {{ [key: string]: PhaseInput; }}
   * @memberof TaskStateInput
   */
  phases?: { [key: string]: PhaseInput } | null;
  /**
   *
   * @type {Array<number>}
   * @memberof TaskStateInput
   */
  completed?: Array<number> | null;
  /**
   *
   * @type {number}
   * @memberof TaskStateInput
   */
  active?: number;
  /**
   *
   * @type {Array<number>}
   * @memberof TaskStateInput
   */
  pending?: Array<number> | null;
  /**
   *
   * @type {{ [key: string]: Interruption; }}
   * @memberof TaskStateInput
   */
  interruptions?: { [key: string]: Interruption } | null;
  /**
   *
   * @type {Cancellation}
   * @memberof TaskStateInput
   */
  cancellation?: Cancellation | null;
  /**
   *
   * @type {Killed}
   * @memberof TaskStateInput
   */
  killed?: Killed | null;
}

/**
 *
 * @export
 * @interface TaskStateOutput
 */
export interface TaskStateOutput {
  /**
   *
   * @type {Booking}
   * @memberof TaskStateOutput
   */
  booking: Booking;
  /**
   * The category of this task or phase
   * @type {string}
   * @memberof TaskStateOutput
   */
  category?: string;
  /**
   *
   * @type {Detail}
   * @memberof TaskStateOutput
   */
  detail?: Detail | null;
  /**
   *
   * @type {number}
   * @memberof TaskStateOutput
   */
  unix_millis_start_time?: number | null;
  /**
   *
   * @type {number}
   * @memberof TaskStateOutput
   */
  unix_millis_finish_time?: number | null;
  /**
   * An estimate, in milliseconds, of how long the subject will take to complete
   * @type {number}
   * @memberof TaskStateOutput
   */
  original_estimate_millis?: number;
  /**
   * An estimate, in milliseconds, of how long the subject will take to complete
   * @type {number}
   * @memberof TaskStateOutput
   */
  estimate_millis?: number;
  /**
   *
   * @type {AssignedTo}
   * @memberof TaskStateOutput
   */
  assigned_to?: AssignedTo | null;
  /**
   *
   * @type {ApiServerModelsRmfApiTaskStateStatus}
   * @memberof TaskStateOutput
   */
  status?: ApiServerModelsRmfApiTaskStateStatus | null;
  /**
   *
   * @type {Dispatch}
   * @memberof TaskStateOutput
   */
  dispatch?: Dispatch | null;
  /**
   *
   * @type {{ [key: string]: PhaseOutput; }}
   * @memberof TaskStateOutput
   */
  phases?: { [key: string]: PhaseOutput } | null;
  /**
   *
   * @type {Array<number>}
   * @memberof TaskStateOutput
   */
  completed?: Array<number> | null;
  /**
   *
   * @type {number}
   * @memberof TaskStateOutput
   */
  active?: number;
  /**
   *
   * @type {Array<number>}
   * @memberof TaskStateOutput
   */
  pending?: Array<number> | null;
  /**
   *
   * @type {{ [key: string]: Interruption; }}
   * @memberof TaskStateOutput
   */
  interruptions?: { [key: string]: Interruption } | null;
  /**
   *
   * @type {Cancellation}
   * @memberof TaskStateOutput
   */
  cancellation?: Cancellation | null;
  /**
   *
   * @type {Killed}
   * @memberof TaskStateOutput
   */
  killed?: Killed | null;
}

/**
 *
 * @export
 * @interface Time
 */
export interface Time {
  /**
   *
   * @type {number}
   * @memberof Time
   */
  sec: number;
  /**
   *
   * @type {number}
   * @memberof Time
   */
  nanosec: number;
}
/**
 * Template for defining a response message that provides a token upon success or errors upon failure
 * @export
 * @interface TokenResponse
 */
export interface TokenResponse {
  /**
   * The request failed
   * @type {boolean}
   * @memberof TokenResponse
   */
  success: boolean;
  /**
   * A token for the request. The value of this token is unique within the scope of this request and can be used by other requests to reference this request.
   * @type {string}
   * @memberof TokenResponse
   */
  token: string;
  /**
   * Any error messages explaining why the request failed.
   * @type {Array<Error>}
   * @memberof TokenResponse
   */
  errors: Array<Error>;
}
/**
 *
 * @export
 * @interface TokenResponse1
 */
export interface TokenResponse1 {
  /**
   * The request was successful
   * @type {boolean}
   * @memberof TokenResponse1
   */
  success: boolean;
  /**
   * A token for the request. The value of this token is unique within the scope of this request and can be used by other requests to reference this request.
   * @type {string}
   * @memberof TokenResponse1
   */
  token: string;
}
/**
 *
 * @export
 * @interface TokenResponse2
 */
export interface TokenResponse2 {
  /**
   * The request failed
   * @type {boolean}
   * @memberof TokenResponse2
   */
  success: boolean;
  /**
   * Any error messages explaining why the request failed.
   * @type {Array<Error>}
   * @memberof TokenResponse2
   */
  errors: Array<Error>;
}
/**
 *
 * @export
 * @interface Undo
 */
export interface Undo {
  /**
   * The time that the undo skip request arrived
   * @type {number}
   * @memberof Undo
   */
  unix_millis_request_time: number;
  /**
   * Labels to describe the undo skip request, items can be a single value like `dashboard` or a key-value pair like `app=dashboard`, in the case of a single value, it will be interpreted as a key-value pair with an empty string value.
   * @type {Array<string>}
   * @memberof Undo
   */
  labels: Array<string>;
}
/**
 *
 * @export
 * @interface UndoPhaseSkipRequest
 */
export interface UndoPhaseSkipRequest {
  /**
   *
   * @type {string}
   * @memberof UndoPhaseSkipRequest
   */
  type?: UndoPhaseSkipRequestTypeEnum | null;
  /**
   *
   * @type {string}
   * @memberof UndoPhaseSkipRequest
   */
  for_task?: string | null;
  /**
   *
   * @type {Array<string>}
   * @memberof UndoPhaseSkipRequest
   */
  for_tokens?: Array<string> | null;
  /**
   *
   * @type {Array<string>}
   * @memberof UndoPhaseSkipRequest
   */
  labels?: Array<string> | null;
}

export const UndoPhaseSkipRequestTypeEnum = {
  UndoPhaseSkipRequest: 'undo_phase_skip_request',
} as const;

export type UndoPhaseSkipRequestTypeEnum =
  (typeof UndoPhaseSkipRequestTypeEnum)[keyof typeof UndoPhaseSkipRequestTypeEnum];

/**
 * Response to an undo phase skip request
 * @export
 * @interface UndoPhaseSkipResponse
 */
export interface UndoPhaseSkipResponse {
  /**
   * The request failed
   * @type {boolean}
   * @memberof UndoPhaseSkipResponse
   */
  success: boolean;
  /**
   * If the request failed, these error messages will explain why
   * @type {Array<Error>}
   * @memberof UndoPhaseSkipResponse
   */
  errors: Array<Error>;
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {string}
   * @memberof User
   */
  username: string;
  /**
   *
   * @type {boolean}
   * @memberof User
   */
  is_admin: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof User
   */
  roles: Array<string>;
}
/**
 *
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
  /**
   *
   * @type {Array<LocationInner>}
   * @memberof ValidationError
   */
  loc: Array<LocationInner>;
  /**
   *
   * @type {string}
   * @memberof ValidationError
   */
  msg: string;
  /**
   *
   * @type {string}
   * @memberof ValidationError
   */
  type: string;
}

/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Add a permission to a role
     * @summary Add Role Permission
     * @param {string} role
     * @param {Permission} permission
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addRolePermissionAdminRolesRolePermissionsPost: async (
      role: string,
      permission: Permission,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'role' is not null or undefined
      assertParamExists('addRolePermissionAdminRolesRolePermissionsPost', 'role', role);
      // verify required parameter 'permission' is not null or undefined
      assertParamExists('addRolePermissionAdminRolesRolePermissionsPost', 'permission', permission);
      const localVarPath = `/admin/roles/{role}/permissions`.replace(
        `{${'role'}}`,
        encodeURIComponent(String(role)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        permission,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Add role to a user
     * @summary Add User Role
     * @param {string} username
     * @param {PostRoles} postRoles
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUserRoleAdminUsersUsernameRolesPost: async (
      username: string,
      postRoles: PostRoles,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists('addUserRoleAdminUsersUsernameRolesPost', 'username', username);
      // verify required parameter 'postRoles' is not null or undefined
      assertParamExists('addUserRoleAdminUsersUsernameRolesPost', 'postRoles', postRoles);
      const localVarPath = `/admin/users/{username}/roles`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        postRoles,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a new role
     * @summary Create Role
     * @param {PostRoles} postRoles
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRoleAdminRolesPost: async (
      postRoles: PostRoles,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'postRoles' is not null or undefined
      assertParamExists('createRoleAdminRolesPost', 'postRoles', postRoles);
      const localVarPath = `/admin/roles`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        postRoles,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a user
     * @summary Create User
     * @param {PostUsers} postUsers
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUserAdminUsersPost: async (
      postUsers: PostUsers,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'postUsers' is not null or undefined
      assertParamExists('createUserAdminUsersPost', 'postUsers', postUsers);
      const localVarPath = `/admin/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        postUsers,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a role
     * @summary Delete Role
     * @param {string} role
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRoleAdminRolesRoleDelete: async (
      role: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'role' is not null or undefined
      assertParamExists('deleteRoleAdminRolesRoleDelete', 'role', role);
      const localVarPath = `/admin/roles/{role}`.replace(
        `{${'role'}}`,
        encodeURIComponent(String(role)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a user  This only performs a soft delete, while the user is deleted from the app database, it still exists in the idp so they can still log in, the user will then be re-created with the default permissions.
     * @summary Delete User
     * @param {string} username
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserAdminUsersUsernameDelete: async (
      username: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists('deleteUserAdminUsersUsernameDelete', 'username', username);
      const localVarPath = `/admin/users/{username}`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Remove role from a user
     * @summary Delete User Role
     * @param {string} username
     * @param {string} role
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserRoleAdminUsersUsernameRolesRoleDelete: async (
      username: string,
      role: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists('deleteUserRoleAdminUsersUsernameRolesRoleDelete', 'username', username);
      // verify required parameter 'role' is not null or undefined
      assertParamExists('deleteUserRoleAdminUsersUsernameRolesRoleDelete', 'role', role);
      const localVarPath = `/admin/users/{username}/roles/{role}`
        .replace(`{${'username'}}`, encodeURIComponent(String(username)))
        .replace(`{${'role'}}`, encodeURIComponent(String(role)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get all permissions of a role
     * @summary Get Role Permissions
     * @param {string} role
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRolePermissionsAdminRolesRolePermissionsGet: async (
      role: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'role' is not null or undefined
      assertParamExists('getRolePermissionsAdminRolesRolePermissionsGet', 'role', role);
      const localVarPath = `/admin/roles/{role}/permissions`.replace(
        `{${'role'}}`,
        encodeURIComponent(String(role)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get all roles
     * @summary Get Roles
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRolesAdminRolesGet: async (
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/admin/roles`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a user
     * @summary Get User
     * @param {string} username
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserAdminUsersUsernameGet: async (
      username: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists('getUserAdminUsersUsernameGet', 'username', username);
      const localVarPath = `/admin/users/{username}`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Search users
     * @summary Get Users
     * @param {string | null} [username] filters username that starts with the value
     * @param {boolean | null} [isAdmin]
     * @param {number | null} [limit] defaults to 100
     * @param {number | null} [offset] defaults to 0
     * @param {string | null} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersAdminUsersGet: async (
      username?: string | null,
      isAdmin?: boolean | null,
      limit?: number | null,
      offset?: number | null,
      orderBy?: string | null,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/admin/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (username !== undefined) {
        localVarQueryParameter['username'] = username;
      }

      if (isAdmin !== undefined) {
        localVarQueryParameter['is_admin'] = isAdmin;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['order_by'] = orderBy;
      }

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Make or remove admin privilege from a user
     * @summary Make Admin
     * @param {string} username
     * @param {PostMakeAdmin} postMakeAdmin
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    makeAdminAdminUsersUsernameMakeAdminPost: async (
      username: string,
      postMakeAdmin: PostMakeAdmin,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists('makeAdminAdminUsersUsernameMakeAdminPost', 'username', username);
      // verify required parameter 'postMakeAdmin' is not null or undefined
      assertParamExists('makeAdminAdminUsersUsernameMakeAdminPost', 'postMakeAdmin', postMakeAdmin);
      const localVarPath = `/admin/users/{username}/make_admin`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        postMakeAdmin,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a permission from a role
     * @summary Remove Role Permission
     * @param {string} role
     * @param {Permission} permission
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeRolePermissionAdminRolesRolePermissionsRemovePost: async (
      role: string,
      permission: Permission,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'role' is not null or undefined
      assertParamExists('removeRolePermissionAdminRolesRolePermissionsRemovePost', 'role', role);
      // verify required parameter 'permission' is not null or undefined
      assertParamExists(
        'removeRolePermissionAdminRolesRolePermissionsRemovePost',
        'permission',
        permission,
      );
      const localVarPath = `/admin/roles/{role}/permissions/remove`.replace(
        `{${'role'}}`,
        encodeURIComponent(String(role)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        permission,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Set the roles of a user
     * @summary Set User Roles
     * @param {string} username
     * @param {Array<PostRoles>} postRoles
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserRolesAdminUsersUsernameRolesPut: async (
      username: string,
      postRoles: Array<PostRoles>,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists('setUserRolesAdminUsersUsernameRolesPut', 'username', username);
      // verify required parameter 'postRoles' is not null or undefined
      assertParamExists('setUserRolesAdminUsersUsernameRolesPut', 'postRoles', postRoles);
      const localVarPath = `/admin/users/{username}/roles`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        postRoles,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration);
  return {
    /**
     * Add a permission to a role
     * @summary Add Role Permission
     * @param {string} role
     * @param {Permission} permission
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addRolePermissionAdminRolesRolePermissionsPost(
      role: string,
      permission: Permission,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.addRolePermissionAdminRolesRolePermissionsPost(
          role,
          permission,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.addRolePermissionAdminRolesRolePermissionsPost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Add role to a user
     * @summary Add User Role
     * @param {string} username
     * @param {PostRoles} postRoles
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addUserRoleAdminUsersUsernameRolesPost(
      username: string,
      postRoles: PostRoles,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.addUserRoleAdminUsersUsernameRolesPost(
          username,
          postRoles,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.addUserRoleAdminUsersUsernameRolesPost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Create a new role
     * @summary Create Role
     * @param {PostRoles} postRoles
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRoleAdminRolesPost(
      postRoles: PostRoles,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createRoleAdminRolesPost(
        postRoles,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.createRoleAdminRolesPost']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Create a user
     * @summary Create User
     * @param {PostUsers} postUsers
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createUserAdminUsersPost(
      postUsers: PostUsers,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createUserAdminUsersPost(
        postUsers,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.createUserAdminUsersPost']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Delete a role
     * @summary Delete Role
     * @param {string} role
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteRoleAdminRolesRoleDelete(
      role: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRoleAdminRolesRoleDelete(
        role,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.deleteRoleAdminRolesRoleDelete']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Delete a user  This only performs a soft delete, while the user is deleted from the app database, it still exists in the idp so they can still log in, the user will then be re-created with the default permissions.
     * @summary Delete User
     * @param {string} username
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUserAdminUsersUsernameDelete(
      username: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserAdminUsersUsernameDelete(
        username,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.deleteUserAdminUsersUsernameDelete']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Remove role from a user
     * @summary Delete User Role
     * @param {string} username
     * @param {string} role
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUserRoleAdminUsersUsernameRolesRoleDelete(
      username: string,
      role: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteUserRoleAdminUsersUsernameRolesRoleDelete(
          username,
          role,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.deleteUserRoleAdminUsersUsernameRolesRoleDelete']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get all permissions of a role
     * @summary Get Role Permissions
     * @param {string} role
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRolePermissionsAdminRolesRolePermissionsGet(
      role: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Permission>>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getRolePermissionsAdminRolesRolePermissionsGet(
          role,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.getRolePermissionsAdminRolesRolePermissionsGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get all roles
     * @summary Get Roles
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRolesAdminRolesGet(
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRolesAdminRolesGet(
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.getRolesAdminRolesGet']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get a user
     * @summary Get User
     * @param {string} username
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserAdminUsersUsernameGet(
      username: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAdminUsersUsernameGet(
        username,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.getUserAdminUsersUsernameGet']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Search users
     * @summary Get Users
     * @param {string | null} [username] filters username that starts with the value
     * @param {boolean | null} [isAdmin]
     * @param {number | null} [limit] defaults to 100
     * @param {number | null} [offset] defaults to 0
     * @param {string | null} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsersAdminUsersGet(
      username?: string | null,
      isAdmin?: boolean | null,
      limit?: number | null,
      offset?: number | null,
      orderBy?: string | null,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersAdminUsersGet(
        username,
        isAdmin,
        limit,
        offset,
        orderBy,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.getUsersAdminUsersGet']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Make or remove admin privilege from a user
     * @summary Make Admin
     * @param {string} username
     * @param {PostMakeAdmin} postMakeAdmin
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async makeAdminAdminUsersUsernameMakeAdminPost(
      username: string,
      postMakeAdmin: PostMakeAdmin,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.makeAdminAdminUsersUsernameMakeAdminPost(
          username,
          postMakeAdmin,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.makeAdminAdminUsersUsernameMakeAdminPost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Delete a permission from a role
     * @summary Remove Role Permission
     * @param {string} role
     * @param {Permission} permission
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeRolePermissionAdminRolesRolePermissionsRemovePost(
      role: string,
      permission: Permission,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.removeRolePermissionAdminRolesRolePermissionsRemovePost(
          role,
          permission,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.removeRolePermissionAdminRolesRolePermissionsRemovePost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Set the roles of a user
     * @summary Set User Roles
     * @param {string} username
     * @param {Array<PostRoles>} postRoles
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setUserRolesAdminUsersUsernameRolesPut(
      username: string,
      postRoles: Array<PostRoles>,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.setUserRolesAdminUsersUsernameRolesPut(
          username,
          postRoles,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.setUserRolesAdminUsersUsernameRolesPut']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AdminApiFp(configuration);
  return {
    /**
     * Add a permission to a role
     * @summary Add Role Permission
     * @param {string} role
     * @param {Permission} permission
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addRolePermissionAdminRolesRolePermissionsPost(
      role: string,
      permission: Permission,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .addRolePermissionAdminRolesRolePermissionsPost(role, permission, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Add role to a user
     * @summary Add User Role
     * @param {string} username
     * @param {PostRoles} postRoles
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUserRoleAdminUsersUsernameRolesPost(
      username: string,
      postRoles: PostRoles,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .addUserRoleAdminUsersUsernameRolesPost(username, postRoles, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a new role
     * @summary Create Role
     * @param {PostRoles} postRoles
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRoleAdminRolesPost(
      postRoles: PostRoles,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .createRoleAdminRolesPost(postRoles, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a user
     * @summary Create User
     * @param {PostUsers} postUsers
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUserAdminUsersPost(
      postUsers: PostUsers,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .createUserAdminUsersPost(postUsers, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete a role
     * @summary Delete Role
     * @param {string} role
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRoleAdminRolesRoleDelete(
      role: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .deleteRoleAdminRolesRoleDelete(role, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete a user  This only performs a soft delete, while the user is deleted from the app database, it still exists in the idp so they can still log in, the user will then be re-created with the default permissions.
     * @summary Delete User
     * @param {string} username
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserAdminUsersUsernameDelete(
      username: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .deleteUserAdminUsersUsernameDelete(username, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Remove role from a user
     * @summary Delete User Role
     * @param {string} username
     * @param {string} role
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserRoleAdminUsersUsernameRolesRoleDelete(
      username: string,
      role: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .deleteUserRoleAdminUsersUsernameRolesRoleDelete(username, role, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get all permissions of a role
     * @summary Get Role Permissions
     * @param {string} role
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRolePermissionsAdminRolesRolePermissionsGet(
      role: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<Array<Permission>> {
      return localVarFp
        .getRolePermissionsAdminRolesRolePermissionsGet(role, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get all roles
     * @summary Get Roles
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRolesAdminRolesGet(
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .getRolesAdminRolesGet(authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a user
     * @summary Get User
     * @param {string} username
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserAdminUsersUsernameGet(
      username: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<User> {
      return localVarFp
        .getUserAdminUsersUsernameGet(username, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Search users
     * @summary Get Users
     * @param {string | null} [username] filters username that starts with the value
     * @param {boolean | null} [isAdmin]
     * @param {number | null} [limit] defaults to 100
     * @param {number | null} [offset] defaults to 0
     * @param {string | null} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersAdminUsersGet(
      username?: string | null,
      isAdmin?: boolean | null,
      limit?: number | null,
      offset?: number | null,
      orderBy?: string | null,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .getUsersAdminUsersGet(username, isAdmin, limit, offset, orderBy, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Make or remove admin privilege from a user
     * @summary Make Admin
     * @param {string} username
     * @param {PostMakeAdmin} postMakeAdmin
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    makeAdminAdminUsersUsernameMakeAdminPost(
      username: string,
      postMakeAdmin: PostMakeAdmin,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .makeAdminAdminUsersUsernameMakeAdminPost(username, postMakeAdmin, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete a permission from a role
     * @summary Remove Role Permission
     * @param {string} role
     * @param {Permission} permission
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeRolePermissionAdminRolesRolePermissionsRemovePost(
      role: string,
      permission: Permission,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .removeRolePermissionAdminRolesRolePermissionsRemovePost(
          role,
          permission,
          authorization,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Set the roles of a user
     * @summary Set User Roles
     * @param {string} username
     * @param {Array<PostRoles>} postRoles
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserRolesAdminUsersUsernameRolesPut(
      username: string,
      postRoles: Array<PostRoles>,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .setUserRolesAdminUsersUsernameRolesPut(username, postRoles, authorization, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
  /**
   * Add a permission to a role
   * @summary Add Role Permission
   * @param {string} role
   * @param {Permission} permission
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public addRolePermissionAdminRolesRolePermissionsPost(
    role: string,
    permission: Permission,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .addRolePermissionAdminRolesRolePermissionsPost(role, permission, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Add role to a user
   * @summary Add User Role
   * @param {string} username
   * @param {PostRoles} postRoles
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public addUserRoleAdminUsersUsernameRolesPost(
    username: string,
    postRoles: PostRoles,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .addUserRoleAdminUsersUsernameRolesPost(username, postRoles, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a new role
   * @summary Create Role
   * @param {PostRoles} postRoles
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public createRoleAdminRolesPost(
    postRoles: PostRoles,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .createRoleAdminRolesPost(postRoles, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a user
   * @summary Create User
   * @param {PostUsers} postUsers
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public createUserAdminUsersPost(
    postUsers: PostUsers,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .createUserAdminUsersPost(postUsers, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete a role
   * @summary Delete Role
   * @param {string} role
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public deleteRoleAdminRolesRoleDelete(
    role: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .deleteRoleAdminRolesRoleDelete(role, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete a user  This only performs a soft delete, while the user is deleted from the app database, it still exists in the idp so they can still log in, the user will then be re-created with the default permissions.
   * @summary Delete User
   * @param {string} username
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public deleteUserAdminUsersUsernameDelete(
    username: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .deleteUserAdminUsersUsernameDelete(username, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Remove role from a user
   * @summary Delete User Role
   * @param {string} username
   * @param {string} role
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public deleteUserRoleAdminUsersUsernameRolesRoleDelete(
    username: string,
    role: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .deleteUserRoleAdminUsersUsernameRolesRoleDelete(username, role, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get all permissions of a role
   * @summary Get Role Permissions
   * @param {string} role
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public getRolePermissionsAdminRolesRolePermissionsGet(
    role: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .getRolePermissionsAdminRolesRolePermissionsGet(role, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get all roles
   * @summary Get Roles
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public getRolesAdminRolesGet(authorization?: string | null, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .getRolesAdminRolesGet(authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a user
   * @summary Get User
   * @param {string} username
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public getUserAdminUsersUsernameGet(
    username: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .getUserAdminUsersUsernameGet(username, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Search users
   * @summary Get Users
   * @param {string | null} [username] filters username that starts with the value
   * @param {boolean | null} [isAdmin]
   * @param {number | null} [limit] defaults to 100
   * @param {number | null} [offset] defaults to 0
   * @param {string | null} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public getUsersAdminUsersGet(
    username?: string | null,
    isAdmin?: boolean | null,
    limit?: number | null,
    offset?: number | null,
    orderBy?: string | null,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .getUsersAdminUsersGet(username, isAdmin, limit, offset, orderBy, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Make or remove admin privilege from a user
   * @summary Make Admin
   * @param {string} username
   * @param {PostMakeAdmin} postMakeAdmin
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public makeAdminAdminUsersUsernameMakeAdminPost(
    username: string,
    postMakeAdmin: PostMakeAdmin,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .makeAdminAdminUsersUsernameMakeAdminPost(username, postMakeAdmin, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete a permission from a role
   * @summary Remove Role Permission
   * @param {string} role
   * @param {Permission} permission
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public removeRolePermissionAdminRolesRolePermissionsRemovePost(
    role: string,
    permission: Permission,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .removeRolePermissionAdminRolesRolePermissionsRemovePost(
        role,
        permission,
        authorization,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Set the roles of a user
   * @summary Set User Roles
   * @param {string} username
   * @param {Array<PostRoles>} postRoles
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public setUserRolesAdminUsersUsernameRolesPut(
    username: string,
    postRoles: Array<PostRoles>,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .setUserRolesAdminUsersUsernameRolesPut(username, postRoles, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * AlertsApi - axios parameter creator
 * @export
 */
export const AlertsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Creates a new alert.
     * @summary Create New Alert
     * @param {AlertRequest} alertRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNewAlertAlertsRequestPost: async (
      alertRequest: AlertRequest,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'alertRequest' is not null or undefined
      assertParamExists('createNewAlertAlertsRequestPost', 'alertRequest', alertRequest);
      const localVarPath = `/alerts/request`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        alertRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Gets an alert based on the alert ID.
     * @summary Get Alert
     * @param {string} alertId
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAlertAlertsRequestAlertIdGet: async (
      alertId: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'alertId' is not null or undefined
      assertParamExists('getAlertAlertsRequestAlertIdGet', 'alertId', alertId);
      const localVarPath = `/alerts/request/{alert_id}`.replace(
        `{${'alert_id'}}`,
        encodeURIComponent(String(alertId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Gets the response to the alert based on the alert ID.
     * @summary Get Alert Response
     * @param {string} alertId
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAlertResponseAlertsRequestAlertIdResponseGet: async (
      alertId: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'alertId' is not null or undefined
      assertParamExists('getAlertResponseAlertsRequestAlertIdResponseGet', 'alertId', alertId);
      const localVarPath = `/alerts/request/{alert_id}/response`.replace(
        `{${'alert_id'}}`,
        encodeURIComponent(String(alertId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns all the alerts associated to a task ID. Provides the option to only return alerts that have not been responded to yet.
     * @summary Get Alerts Of Task
     * @param {string} taskId
     * @param {boolean} [unresponded]
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAlertsOfTaskAlertsRequestsTaskTaskIdGet: async (
      taskId: string,
      unresponded?: boolean,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskId' is not null or undefined
      assertParamExists('getAlertsOfTaskAlertsRequestsTaskTaskIdGet', 'taskId', taskId);
      const localVarPath = `/alerts/requests/task/{task_id}`.replace(
        `{${'task_id'}}`,
        encodeURIComponent(String(taskId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (unresponded !== undefined) {
        localVarQueryParameter['unresponded'] = unresponded;
      }

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns the list of alert IDs that have yet to be responded to, while a response was required.
     * @summary Get Unresponded Alerts
     * @param {string | null} [authorization]
     * @param {Pagination} [pagination]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUnrespondedAlertsAlertsUnrespondedRequestsGet: async (
      authorization?: string | null,
      pagination?: Pagination,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/alerts/unresponded_requests`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        pagination,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Responds to an existing alert. The response must be one of the available responses listed in the alert.
     * @summary Respond To Alert
     * @param {string} alertId
     * @param {string} response
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    respondToAlertAlertsRequestAlertIdRespondPost: async (
      alertId: string,
      response: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'alertId' is not null or undefined
      assertParamExists('respondToAlertAlertsRequestAlertIdRespondPost', 'alertId', alertId);
      // verify required parameter 'response' is not null or undefined
      assertParamExists('respondToAlertAlertsRequestAlertIdRespondPost', 'response', response);
      const localVarPath = `/alerts/request/{alert_id}/respond`.replace(
        `{${'alert_id'}}`,
        encodeURIComponent(String(alertId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (response !== undefined) {
        localVarQueryParameter['response'] = response;
      }

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AlertsApi - functional programming interface
 * @export
 */
export const AlertsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AlertsApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new alert.
     * @summary Create New Alert
     * @param {AlertRequest} alertRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createNewAlertAlertsRequestPost(
      alertRequest: AlertRequest,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertRequest>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createNewAlertAlertsRequestPost(
        alertRequest,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AlertsApi.createNewAlertAlertsRequestPost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Gets an alert based on the alert ID.
     * @summary Get Alert
     * @param {string} alertId
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAlertAlertsRequestAlertIdGet(
      alertId: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertRequest>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAlertAlertsRequestAlertIdGet(
        alertId,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AlertsApi.getAlertAlertsRequestAlertIdGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Gets the response to the alert based on the alert ID.
     * @summary Get Alert Response
     * @param {string} alertId
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAlertResponseAlertsRequestAlertIdResponseGet(
      alertId: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertResponse>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAlertResponseAlertsRequestAlertIdResponseGet(
          alertId,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AlertsApi.getAlertResponseAlertsRequestAlertIdResponseGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns all the alerts associated to a task ID. Provides the option to only return alerts that have not been responded to yet.
     * @summary Get Alerts Of Task
     * @param {string} taskId
     * @param {boolean} [unresponded]
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAlertsOfTaskAlertsRequestsTaskTaskIdGet(
      taskId: string,
      unresponded?: boolean,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AlertRequest>>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAlertsOfTaskAlertsRequestsTaskTaskIdGet(
          taskId,
          unresponded,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AlertsApi.getAlertsOfTaskAlertsRequestsTaskTaskIdGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns the list of alert IDs that have yet to be responded to, while a response was required.
     * @summary Get Unresponded Alerts
     * @param {string | null} [authorization]
     * @param {Pagination} [pagination]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUnrespondedAlertsAlertsUnrespondedRequestsGet(
      authorization?: string | null,
      pagination?: Pagination,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AlertRequest>>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUnrespondedAlertsAlertsUnrespondedRequestsGet(
          authorization,
          pagination,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AlertsApi.getUnrespondedAlertsAlertsUnrespondedRequestsGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Responds to an existing alert. The response must be one of the available responses listed in the alert.
     * @summary Respond To Alert
     * @param {string} alertId
     * @param {string} response
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async respondToAlertAlertsRequestAlertIdRespondPost(
      alertId: string,
      response: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertResponse>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.respondToAlertAlertsRequestAlertIdRespondPost(
          alertId,
          response,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AlertsApi.respondToAlertAlertsRequestAlertIdRespondPost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * AlertsApi - factory interface
 * @export
 */
export const AlertsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AlertsApiFp(configuration);
  return {
    /**
     * Creates a new alert.
     * @summary Create New Alert
     * @param {AlertRequest} alertRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNewAlertAlertsRequestPost(
      alertRequest: AlertRequest,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<AlertRequest> {
      return localVarFp
        .createNewAlertAlertsRequestPost(alertRequest, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Gets an alert based on the alert ID.
     * @summary Get Alert
     * @param {string} alertId
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAlertAlertsRequestAlertIdGet(
      alertId: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<AlertRequest> {
      return localVarFp
        .getAlertAlertsRequestAlertIdGet(alertId, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Gets the response to the alert based on the alert ID.
     * @summary Get Alert Response
     * @param {string} alertId
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAlertResponseAlertsRequestAlertIdResponseGet(
      alertId: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<AlertResponse> {
      return localVarFp
        .getAlertResponseAlertsRequestAlertIdResponseGet(alertId, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns all the alerts associated to a task ID. Provides the option to only return alerts that have not been responded to yet.
     * @summary Get Alerts Of Task
     * @param {string} taskId
     * @param {boolean} [unresponded]
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAlertsOfTaskAlertsRequestsTaskTaskIdGet(
      taskId: string,
      unresponded?: boolean,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<Array<AlertRequest>> {
      return localVarFp
        .getAlertsOfTaskAlertsRequestsTaskTaskIdGet(taskId, unresponded, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns the list of alert IDs that have yet to be responded to, while a response was required.
     * @summary Get Unresponded Alerts
     * @param {string | null} [authorization]
     * @param {Pagination} [pagination]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUnrespondedAlertsAlertsUnrespondedRequestsGet(
      authorization?: string | null,
      pagination?: Pagination,
      options?: any,
    ): AxiosPromise<Array<AlertRequest>> {
      return localVarFp
        .getUnrespondedAlertsAlertsUnrespondedRequestsGet(authorization, pagination, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Responds to an existing alert. The response must be one of the available responses listed in the alert.
     * @summary Respond To Alert
     * @param {string} alertId
     * @param {string} response
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    respondToAlertAlertsRequestAlertIdRespondPost(
      alertId: string,
      response: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<AlertResponse> {
      return localVarFp
        .respondToAlertAlertsRequestAlertIdRespondPost(alertId, response, authorization, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AlertsApi - object-oriented interface
 * @export
 * @class AlertsApi
 * @extends {BaseAPI}
 */
export class AlertsApi extends BaseAPI {
  /**
   * Creates a new alert.
   * @summary Create New Alert
   * @param {AlertRequest} alertRequest
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AlertsApi
   */
  public createNewAlertAlertsRequestPost(
    alertRequest: AlertRequest,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return AlertsApiFp(this.configuration)
      .createNewAlertAlertsRequestPost(alertRequest, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Gets an alert based on the alert ID.
   * @summary Get Alert
   * @param {string} alertId
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AlertsApi
   */
  public getAlertAlertsRequestAlertIdGet(
    alertId: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return AlertsApiFp(this.configuration)
      .getAlertAlertsRequestAlertIdGet(alertId, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Gets the response to the alert based on the alert ID.
   * @summary Get Alert Response
   * @param {string} alertId
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AlertsApi
   */
  public getAlertResponseAlertsRequestAlertIdResponseGet(
    alertId: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return AlertsApiFp(this.configuration)
      .getAlertResponseAlertsRequestAlertIdResponseGet(alertId, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all the alerts associated to a task ID. Provides the option to only return alerts that have not been responded to yet.
   * @summary Get Alerts Of Task
   * @param {string} taskId
   * @param {boolean} [unresponded]
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AlertsApi
   */
  public getAlertsOfTaskAlertsRequestsTaskTaskIdGet(
    taskId: string,
    unresponded?: boolean,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return AlertsApiFp(this.configuration)
      .getAlertsOfTaskAlertsRequestsTaskTaskIdGet(taskId, unresponded, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns the list of alert IDs that have yet to be responded to, while a response was required.
   * @summary Get Unresponded Alerts
   * @param {string | null} [authorization]
   * @param {Pagination} [pagination]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AlertsApi
   */
  public getUnrespondedAlertsAlertsUnrespondedRequestsGet(
    authorization?: string | null,
    pagination?: Pagination,
    options?: RawAxiosRequestConfig,
  ) {
    return AlertsApiFp(this.configuration)
      .getUnrespondedAlertsAlertsUnrespondedRequestsGet(authorization, pagination, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Responds to an existing alert. The response must be one of the available responses listed in the alert.
   * @summary Respond To Alert
   * @param {string} alertId
   * @param {string} response
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AlertsApi
   */
  public respondToAlertAlertsRequestAlertIdRespondPost(
    alertId: string,
    response: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return AlertsApiFp(this.configuration)
      .respondToAlertAlertsRequestAlertIdRespondPost(alertId, response, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * BeaconsApi - axios parameter creator
 * @export
 */
export const BeaconsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get Beacon
     * @param {string} beaconId
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBeaconBeaconsBeaconIdGet: async (
      beaconId: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'beaconId' is not null or undefined
      assertParamExists('getBeaconBeaconsBeaconIdGet', 'beaconId', beaconId);
      const localVarPath = `/beacons/{beacon_id}`.replace(
        `{${'beacon_id'}}`,
        encodeURIComponent(String(beaconId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Beacons
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBeaconsBeaconsGet: async (
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/beacons`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Save Beacon State
     * @param {string} beaconId
     * @param {boolean} online
     * @param {string} category
     * @param {boolean} activated
     * @param {string} level
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveBeaconStateBeaconsPost: async (
      beaconId: string,
      online: boolean,
      category: string,
      activated: boolean,
      level: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'beaconId' is not null or undefined
      assertParamExists('saveBeaconStateBeaconsPost', 'beaconId', beaconId);
      // verify required parameter 'online' is not null or undefined
      assertParamExists('saveBeaconStateBeaconsPost', 'online', online);
      // verify required parameter 'category' is not null or undefined
      assertParamExists('saveBeaconStateBeaconsPost', 'category', category);
      // verify required parameter 'activated' is not null or undefined
      assertParamExists('saveBeaconStateBeaconsPost', 'activated', activated);
      // verify required parameter 'level' is not null or undefined
      assertParamExists('saveBeaconStateBeaconsPost', 'level', level);
      const localVarPath = `/beacons`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (beaconId !== undefined) {
        localVarQueryParameter['beacon_id'] = beaconId;
      }

      if (online !== undefined) {
        localVarQueryParameter['online'] = online;
      }

      if (category !== undefined) {
        localVarQueryParameter['category'] = category;
      }

      if (activated !== undefined) {
        localVarQueryParameter['activated'] = activated;
      }

      if (level !== undefined) {
        localVarQueryParameter['level'] = level;
      }

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * BeaconsApi - functional programming interface
 * @export
 */
export const BeaconsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = BeaconsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Get Beacon
     * @param {string} beaconId
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBeaconBeaconsBeaconIdGet(
      beaconId: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BeaconState>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBeaconBeaconsBeaconIdGet(
        beaconId,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BeaconsApi.getBeaconBeaconsBeaconIdGet']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get Beacons
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBeaconsBeaconsGet(
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BeaconState>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBeaconsBeaconsGet(
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BeaconsApi.getBeaconsBeaconsGet']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Save Beacon State
     * @param {string} beaconId
     * @param {boolean} online
     * @param {string} category
     * @param {boolean} activated
     * @param {string} level
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async saveBeaconStateBeaconsPost(
      beaconId: string,
      online: boolean,
      category: string,
      activated: boolean,
      level: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BeaconState>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.saveBeaconStateBeaconsPost(
        beaconId,
        online,
        category,
        activated,
        level,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BeaconsApi.saveBeaconStateBeaconsPost']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * BeaconsApi - factory interface
 * @export
 */
export const BeaconsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = BeaconsApiFp(configuration);
  return {
    /**
     *
     * @summary Get Beacon
     * @param {string} beaconId
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBeaconBeaconsBeaconIdGet(
      beaconId: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<BeaconState> {
      return localVarFp
        .getBeaconBeaconsBeaconIdGet(beaconId, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Beacons
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBeaconsBeaconsGet(
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<Array<BeaconState>> {
      return localVarFp
        .getBeaconsBeaconsGet(authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Save Beacon State
     * @param {string} beaconId
     * @param {boolean} online
     * @param {string} category
     * @param {boolean} activated
     * @param {string} level
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveBeaconStateBeaconsPost(
      beaconId: string,
      online: boolean,
      category: string,
      activated: boolean,
      level: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<BeaconState> {
      return localVarFp
        .saveBeaconStateBeaconsPost(
          beaconId,
          online,
          category,
          activated,
          level,
          authorization,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * BeaconsApi - object-oriented interface
 * @export
 * @class BeaconsApi
 * @extends {BaseAPI}
 */
export class BeaconsApi extends BaseAPI {
  /**
   *
   * @summary Get Beacon
   * @param {string} beaconId
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconsApi
   */
  public getBeaconBeaconsBeaconIdGet(
    beaconId: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return BeaconsApiFp(this.configuration)
      .getBeaconBeaconsBeaconIdGet(beaconId, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Beacons
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconsApi
   */
  public getBeaconsBeaconsGet(authorization?: string | null, options?: RawAxiosRequestConfig) {
    return BeaconsApiFp(this.configuration)
      .getBeaconsBeaconsGet(authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Save Beacon State
   * @param {string} beaconId
   * @param {boolean} online
   * @param {string} category
   * @param {boolean} activated
   * @param {string} level
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconsApi
   */
  public saveBeaconStateBeaconsPost(
    beaconId: string,
    online: boolean,
    category: string,
    activated: boolean,
    level: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return BeaconsApiFp(this.configuration)
      .saveBeaconStateBeaconsPost(
        beaconId,
        online,
        category,
        activated,
        level,
        authorization,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * BuildingApi - axios parameter creator
 * @export
 */
export const BuildingApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Available in socket.io
     * @summary Get Building Map
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildingMapBuildingMapGet: async (
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/building_map`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Previous Fire Alarm Trigger
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPreviousFireAlarmTriggerBuildingMapPreviousFireAlarmTriggerGet: async (
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/building_map/previous_fire_alarm_trigger`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Reset Fire Alarm Trigger
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetFireAlarmTriggerBuildingMapResetFireAlarmTriggerPost: async (
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/building_map/reset_fire_alarm_trigger`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * BuildingApi - functional programming interface
 * @export
 */
export const BuildingApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = BuildingApiAxiosParamCreator(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Building Map
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBuildingMapBuildingMapGet(
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BuildingMap>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBuildingMapBuildingMapGet(
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildingApi.getBuildingMapBuildingMapGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get Previous Fire Alarm Trigger
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPreviousFireAlarmTriggerBuildingMapPreviousFireAlarmTriggerGet(
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FireAlarmTriggerState>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPreviousFireAlarmTriggerBuildingMapPreviousFireAlarmTriggerGet(
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          'BuildingApi.getPreviousFireAlarmTriggerBuildingMapPreviousFireAlarmTriggerGet'
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Reset Fire Alarm Trigger
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async resetFireAlarmTriggerBuildingMapResetFireAlarmTriggerPost(
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FireAlarmTriggerState>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.resetFireAlarmTriggerBuildingMapResetFireAlarmTriggerPost(
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          'BuildingApi.resetFireAlarmTriggerBuildingMapResetFireAlarmTriggerPost'
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * BuildingApi - factory interface
 * @export
 */
export const BuildingApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = BuildingApiFp(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Building Map
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildingMapBuildingMapGet(
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<BuildingMap> {
      return localVarFp
        .getBuildingMapBuildingMapGet(authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Previous Fire Alarm Trigger
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPreviousFireAlarmTriggerBuildingMapPreviousFireAlarmTriggerGet(
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<FireAlarmTriggerState> {
      return localVarFp
        .getPreviousFireAlarmTriggerBuildingMapPreviousFireAlarmTriggerGet(authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Reset Fire Alarm Trigger
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetFireAlarmTriggerBuildingMapResetFireAlarmTriggerPost(
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<FireAlarmTriggerState> {
      return localVarFp
        .resetFireAlarmTriggerBuildingMapResetFireAlarmTriggerPost(authorization, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * BuildingApi - object-oriented interface
 * @export
 * @class BuildingApi
 * @extends {BaseAPI}
 */
export class BuildingApi extends BaseAPI {
  /**
   * Available in socket.io
   * @summary Get Building Map
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildingApi
   */
  public getBuildingMapBuildingMapGet(
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return BuildingApiFp(this.configuration)
      .getBuildingMapBuildingMapGet(authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Previous Fire Alarm Trigger
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildingApi
   */
  public getPreviousFireAlarmTriggerBuildingMapPreviousFireAlarmTriggerGet(
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return BuildingApiFp(this.configuration)
      .getPreviousFireAlarmTriggerBuildingMapPreviousFireAlarmTriggerGet(authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Reset Fire Alarm Trigger
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildingApi
   */
  public resetFireAlarmTriggerBuildingMapResetFireAlarmTriggerPost(
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return BuildingApiFp(this.configuration)
      .resetFireAlarmTriggerBuildingMapResetFireAlarmTriggerPost(authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Get the effective permissions of the current user
     * @summary Get Effective Permissions
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEffectivePermissionsPermissionsGet: async (
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/permissions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the current rmf time in unix milliseconds
     * @summary Get Time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTimeTimeGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/time`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the currently logged in user
     * @summary Get User
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserUserGet: async (
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/user`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * # NOTE: This endpoint is here for documentation purposes only, this is _not_ a REST endpoint.  ## About This exposes a minimal pubsub system built on top of socket.io. It works similar to a normal socket.io endpoint, except that are 2 special rooms which control subscriptions.  ## Rooms ### subscribe Clients must send a message to this room to start receiving messages on other rooms. The message must be of the form:  ``` {     \"room\": \"<room_name>\" } ```  ### unsubscribe Clients can send a message to this room to stop receiving messages on other rooms. The message must be of the form:  ``` {     \"room\": \"<room_name>\" } ``` ### /alerts/requests   ``` {   \"$defs\": {     \"AlertParameter\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"value\": {           \"title\": \"Value\",           \"type\": \"string\"         }       },       \"required\": [         \"name\",         \"value\"       ],       \"title\": \"AlertParameter\",       \"type\": \"object\"     },     \"Tier\": {       \"enum\": [         \"info\",         \"warning\",         \"error\"       ],       \"title\": \"Tier\",       \"type\": \"string\"     }   },   \"properties\": {     \"id\": {       \"title\": \"Id\",       \"type\": \"string\"     },     \"unix_millis_alert_time\": {       \"title\": \"Unix Millis Alert Time\",       \"type\": \"integer\"     },     \"title\": {       \"title\": \"Title\",       \"type\": \"string\"     },     \"subtitle\": {       \"title\": \"Subtitle\",       \"type\": \"string\"     },     \"message\": {       \"title\": \"Message\",       \"type\": \"string\"     },     \"display\": {       \"title\": \"Display\",       \"type\": \"boolean\"     },     \"tier\": {       \"$ref\": \"#/$defs/Tier\"     },     \"responses_available\": {       \"items\": {         \"type\": \"string\"       },       \"title\": \"Responses Available\",       \"type\": \"array\"     },     \"alert_parameters\": {       \"items\": {         \"$ref\": \"#/$defs/AlertParameter\"       },       \"title\": \"Alert Parameters\",       \"type\": \"array\"     },     \"task_id\": {       \"anyOf\": [         {           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"title\": \"Task Id\"     }   },   \"required\": [     \"id\",     \"unix_millis_alert_time\",     \"title\",     \"subtitle\",     \"message\",     \"display\",     \"tier\",     \"responses_available\",     \"alert_parameters\",     \"task_id\"   ],   \"title\": \"AlertRequest\",   \"type\": \"object\" } ```   ### /alerts/responses   ``` {   \"properties\": {     \"id\": {       \"title\": \"Id\",       \"type\": \"string\"     },     \"unix_millis_response_time\": {       \"title\": \"Unix Millis Response Time\",       \"type\": \"integer\"     },     \"response\": {       \"title\": \"Response\",       \"type\": \"string\"     }   },   \"required\": [     \"id\",     \"unix_millis_response_time\",     \"response\"   ],   \"title\": \"AlertResponse\",   \"type\": \"object\" } ```   ### /beacons   ``` {   \"properties\": {     \"id\": {       \"title\": \"Id\",       \"type\": \"string\"     },     \"online\": {       \"title\": \"Online\",       \"type\": \"boolean\"     },     \"category\": {       \"title\": \"Category\",       \"type\": \"string\"     },     \"activated\": {       \"title\": \"Activated\",       \"type\": \"boolean\"     },     \"level\": {       \"title\": \"Level\",       \"type\": \"string\"     }   },   \"required\": [     \"id\",     \"online\",     \"category\",     \"activated\",     \"level\"   ],   \"title\": \"BeaconState\",   \"type\": \"object\" } ```   ### /building_map   ``` {   \"$defs\": {     \"AffineImage\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"x_offset\": {           \"title\": \"X Offset\",           \"type\": \"number\"         },         \"y_offset\": {           \"title\": \"Y Offset\",           \"type\": \"number\"         },         \"yaw\": {           \"title\": \"Yaw\",           \"type\": \"number\"         },         \"scale\": {           \"title\": \"Scale\",           \"type\": \"number\"         },         \"encoding\": {           \"title\": \"Encoding\",           \"type\": \"string\"         },         \"data\": {           \"title\": \"Data\",           \"type\": \"string\"         }       },       \"required\": [         \"name\",         \"x_offset\",         \"y_offset\",         \"yaw\",         \"scale\",         \"encoding\",         \"data\"       ],       \"title\": \"AffineImage\",       \"type\": \"object\"     },     \"Door\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"v1_x\": {           \"title\": \"V1 X\",           \"type\": \"number\"         },         \"v1_y\": {           \"title\": \"V1 Y\",           \"type\": \"number\"         },         \"v2_x\": {           \"title\": \"V2 X\",           \"type\": \"number\"         },         \"v2_y\": {           \"title\": \"V2 Y\",           \"type\": \"number\"         },         \"door_type\": {           \"maximum\": 255,           \"minimum\": 0,           \"title\": \"Door Type\",           \"type\": \"integer\"         },         \"motion_range\": {           \"title\": \"Motion Range\",           \"type\": \"number\"         },         \"motion_direction\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Motion Direction\",           \"type\": \"integer\"         }       },       \"required\": [         \"name\",         \"v1_x\",         \"v1_y\",         \"v2_x\",         \"v2_y\",         \"door_type\",         \"motion_range\",         \"motion_direction\"       ],       \"title\": \"Door\",       \"type\": \"object\"     },     \"Graph\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"vertices\": {           \"items\": {             \"$ref\": \"#/$defs/GraphNode\"           },           \"title\": \"Vertices\",           \"type\": \"array\"         },         \"edges\": {           \"items\": {             \"$ref\": \"#/$defs/GraphEdge\"           },           \"title\": \"Edges\",           \"type\": \"array\"         },         \"params\": {           \"items\": {             \"$ref\": \"#/$defs/Param\"           },           \"title\": \"Params\",           \"type\": \"array\"         }       },       \"required\": [         \"name\",         \"vertices\",         \"edges\",         \"params\"       ],       \"title\": \"Graph\",       \"type\": \"object\"     },     \"GraphEdge\": {       \"properties\": {         \"v1_idx\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"V1 Idx\",           \"type\": \"integer\"         },         \"v2_idx\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"V2 Idx\",           \"type\": \"integer\"         },         \"params\": {           \"items\": {             \"$ref\": \"#/$defs/Param\"           },           \"title\": \"Params\",           \"type\": \"array\"         },         \"edge_type\": {           \"maximum\": 255,           \"minimum\": 0,           \"title\": \"Edge Type\",           \"type\": \"integer\"         }       },       \"required\": [         \"v1_idx\",         \"v2_idx\",         \"params\",         \"edge_type\"       ],       \"title\": \"GraphEdge\",       \"type\": \"object\"     },     \"GraphNode\": {       \"properties\": {         \"x\": {           \"title\": \"X\",           \"type\": \"number\"         },         \"y\": {           \"title\": \"Y\",           \"type\": \"number\"         },         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"params\": {           \"items\": {             \"$ref\": \"#/$defs/Param\"           },           \"title\": \"Params\",           \"type\": \"array\"         }       },       \"required\": [         \"x\",         \"y\",         \"name\",         \"params\"       ],       \"title\": \"GraphNode\",       \"type\": \"object\"     },     \"Level\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"elevation\": {           \"title\": \"Elevation\",           \"type\": \"number\"         },         \"images\": {           \"items\": {             \"$ref\": \"#/$defs/AffineImage\"           },           \"title\": \"Images\",           \"type\": \"array\"         },         \"places\": {           \"items\": {             \"$ref\": \"#/$defs/Place\"           },           \"title\": \"Places\",           \"type\": \"array\"         },         \"doors\": {           \"items\": {             \"$ref\": \"#/$defs/Door\"           },           \"title\": \"Doors\",           \"type\": \"array\"         },         \"nav_graphs\": {           \"items\": {             \"$ref\": \"#/$defs/Graph\"           },           \"title\": \"Nav Graphs\",           \"type\": \"array\"         },         \"wall_graph\": {           \"$ref\": \"#/$defs/Graph\"         }       },       \"required\": [         \"name\",         \"elevation\",         \"images\",         \"places\",         \"doors\",         \"nav_graphs\",         \"wall_graph\"       ],       \"title\": \"Level\",       \"type\": \"object\"     },     \"Lift\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"levels\": {           \"items\": {             \"type\": \"string\"           },           \"title\": \"Levels\",           \"type\": \"array\"         },         \"doors\": {           \"items\": {             \"$ref\": \"#/$defs/Door\"           },           \"title\": \"Doors\",           \"type\": \"array\"         },         \"wall_graph\": {           \"$ref\": \"#/$defs/Graph\"         },         \"ref_x\": {           \"title\": \"Ref X\",           \"type\": \"number\"         },         \"ref_y\": {           \"title\": \"Ref Y\",           \"type\": \"number\"         },         \"ref_yaw\": {           \"title\": \"Ref Yaw\",           \"type\": \"number\"         },         \"width\": {           \"title\": \"Width\",           \"type\": \"number\"         },         \"depth\": {           \"title\": \"Depth\",           \"type\": \"number\"         }       },       \"required\": [         \"name\",         \"levels\",         \"doors\",         \"wall_graph\",         \"ref_x\",         \"ref_y\",         \"ref_yaw\",         \"width\",         \"depth\"       ],       \"title\": \"Lift\",       \"type\": \"object\"     },     \"Param\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"type\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Type\",           \"type\": \"integer\"         },         \"value_int\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Value Int\",           \"type\": \"integer\"         },         \"value_float\": {           \"title\": \"Value Float\",           \"type\": \"number\"         },         \"value_string\": {           \"title\": \"Value String\",           \"type\": \"string\"         },         \"value_bool\": {           \"title\": \"Value Bool\",           \"type\": \"boolean\"         }       },       \"required\": [         \"name\",         \"type\",         \"value_int\",         \"value_float\",         \"value_string\",         \"value_bool\"       ],       \"title\": \"Param\",       \"type\": \"object\"     },     \"Place\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"x\": {           \"title\": \"X\",           \"type\": \"number\"         },         \"y\": {           \"title\": \"Y\",           \"type\": \"number\"         },         \"yaw\": {           \"title\": \"Yaw\",           \"type\": \"number\"         },         \"position_tolerance\": {           \"title\": \"Position Tolerance\",           \"type\": \"number\"         },         \"yaw_tolerance\": {           \"title\": \"Yaw Tolerance\",           \"type\": \"number\"         }       },       \"required\": [         \"name\",         \"x\",         \"y\",         \"yaw\",         \"position_tolerance\",         \"yaw_tolerance\"       ],       \"title\": \"Place\",       \"type\": \"object\"     }   },   \"properties\": {     \"name\": {       \"title\": \"Name\",       \"type\": \"string\"     },     \"levels\": {       \"items\": {         \"$ref\": \"#/$defs/Level\"       },       \"title\": \"Levels\",       \"type\": \"array\"     },     \"lifts\": {       \"items\": {         \"$ref\": \"#/$defs/Lift\"       },       \"title\": \"Lifts\",       \"type\": \"array\"     }   },   \"required\": [     \"name\",     \"levels\",     \"lifts\"   ],   \"title\": \"BuildingMap\",   \"type\": \"object\" } ```   ### /building_map/fire_alarm_trigger   ``` {   \"properties\": {     \"unix_millis_time\": {       \"title\": \"Unix Millis Time\",       \"type\": \"integer\"     },     \"trigger\": {       \"title\": \"Trigger\",       \"type\": \"boolean\"     }   },   \"required\": [     \"unix_millis_time\",     \"trigger\"   ],   \"title\": \"FireAlarmTriggerState\",   \"type\": \"object\" } ```   ### /delivery_alerts   ``` {   \"$defs\": {     \"Action\": {       \"enum\": [         \"waiting\",         \"cancel\",         \"override\",         \"resume\"       ],       \"title\": \"Action\",       \"type\": \"string\"     },     \"Category\": {       \"enum\": [         \"missing\",         \"wrong\",         \"obstructed\",         \"cancelled\"       ],       \"title\": \"Category\",       \"type\": \"string\"     },     \"Tier\": {       \"enum\": [         \"warning\",         \"error\"       ],       \"title\": \"Tier\",       \"type\": \"string\"     }   },   \"properties\": {     \"id\": {       \"title\": \"Id\",       \"type\": \"string\"     },     \"category\": {       \"$ref\": \"#/$defs/Category\"     },     \"tier\": {       \"$ref\": \"#/$defs/Tier\"     },     \"action\": {       \"$ref\": \"#/$defs/Action\"     },     \"task_id\": {       \"title\": \"Task Id\",       \"type\": \"string\"     },     \"message\": {       \"title\": \"Message\",       \"type\": \"string\"     }   },   \"required\": [     \"id\",     \"category\",     \"tier\",     \"action\",     \"task_id\",     \"message\"   ],   \"title\": \"DeliveryAlert\",   \"type\": \"object\" } ```   ### /doors/{door_name}/state   ``` {   \"$defs\": {     \"DoorMode\": {       \"properties\": {         \"value\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Value\",           \"type\": \"integer\"         }       },       \"required\": [         \"value\"       ],       \"title\": \"DoorMode\",       \"type\": \"object\"     },     \"Time\": {       \"properties\": {         \"sec\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Sec\",           \"type\": \"integer\"         },         \"nanosec\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Nanosec\",           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ],       \"title\": \"Time\",       \"type\": \"object\"     }   },   \"properties\": {     \"door_time\": {       \"$ref\": \"#/$defs/Time\"     },     \"door_name\": {       \"title\": \"Door Name\",       \"type\": \"string\"     },     \"current_mode\": {       \"$ref\": \"#/$defs/DoorMode\"     }   },   \"required\": [     \"door_time\",     \"door_name\",     \"current_mode\"   ],   \"title\": \"DoorState\",   \"type\": \"object\" } ```   ### /lifts/{lift_name}/state   ``` {   \"$defs\": {     \"Time\": {       \"properties\": {         \"sec\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Sec\",           \"type\": \"integer\"         },         \"nanosec\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Nanosec\",           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ],       \"title\": \"Time\",       \"type\": \"object\"     }   },   \"properties\": {     \"lift_time\": {       \"$ref\": \"#/$defs/Time\"     },     \"lift_name\": {       \"title\": \"Lift Name\",       \"type\": \"string\"     },     \"available_floors\": {       \"items\": {         \"type\": \"string\"       },       \"title\": \"Available Floors\",       \"type\": \"array\"     },     \"current_floor\": {       \"title\": \"Current Floor\",       \"type\": \"string\"     },     \"destination_floor\": {       \"title\": \"Destination Floor\",       \"type\": \"string\"     },     \"door_state\": {       \"maximum\": 255,       \"minimum\": 0,       \"title\": \"Door State\",       \"type\": \"integer\"     },     \"motion_state\": {       \"maximum\": 255,       \"minimum\": 0,       \"title\": \"Motion State\",       \"type\": \"integer\"     },     \"available_modes\": {       \"items\": {         \"type\": \"integer\"       },       \"title\": \"Available Modes\",       \"type\": \"array\"     },     \"current_mode\": {       \"maximum\": 255,       \"minimum\": 0,       \"title\": \"Current Mode\",       \"type\": \"integer\"     },     \"session_id\": {       \"title\": \"Session Id\",       \"type\": \"string\"     }   },   \"required\": [     \"lift_time\",     \"lift_name\",     \"available_floors\",     \"current_floor\",     \"destination_floor\",     \"door_state\",     \"motion_state\",     \"available_modes\",     \"current_mode\",     \"session_id\"   ],   \"title\": \"LiftState\",   \"type\": \"object\" } ```   ### /tasks/{task_id}/state   ``` {   \"$defs\": {     \"AssignedTo\": {       \"properties\": {         \"group\": {           \"title\": \"Group\",           \"type\": \"string\"         },         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         }       },       \"required\": [         \"group\",         \"name\"       ],       \"title\": \"AssignedTo\",       \"type\": \"object\"     },     \"Assignment\": {       \"properties\": {         \"fleet_name\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Fleet Name\"         },         \"expected_robot_name\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Expected Robot Name\"         }       },       \"title\": \"Assignment\",       \"type\": \"object\"     },     \"Booking\": {       \"properties\": {         \"id\": {           \"description\": \"The unique identifier for this task\",           \"title\": \"Id\",           \"type\": \"string\"         },         \"unix_millis_earliest_start_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Unix Millis Earliest Start Time\"         },         \"unix_millis_request_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Unix Millis Request Time\"         },         \"priority\": {           \"anyOf\": [             {               \"type\": \"object\"             },             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Priority information about this task\",           \"title\": \"Priority\"         },         \"labels\": {           \"anyOf\": [             {               \"items\": {                 \"type\": \"string\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Information about how and why this task was booked, items can be a single value like `dashboard` or a key-value pair like `app=dashboard`, in the case of a single value, it will be interpreted as a key-value pair with an empty string value.\",           \"title\": \"Labels\"         },         \"requester\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"(Optional) An identifier for the entity that requested this task\",           \"title\": \"Requester\"         }       },       \"required\": [         \"id\"       ],       \"title\": \"Booking\",       \"type\": \"object\"     },     \"Cancellation\": {       \"properties\": {         \"unix_millis_request_time\": {           \"description\": \"The time that the cancellation request arrived\",           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"labels\": {           \"description\": \"Labels to describe the cancel request, items can be a single value like `dashboard` or a key-value pair like `app=dashboard`, in the case of a single value, it will be interpreted as a key-value pair with an empty string value.\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ],       \"title\": \"Cancellation\",       \"type\": \"object\"     },     \"Category\": {       \"description\": \"The category of this task or phase\",       \"title\": \"Category\",       \"type\": \"string\"     },     \"Detail\": {       \"anyOf\": [         {           \"type\": \"object\"         },         {           \"items\": {},           \"type\": \"array\"         },         {           \"type\": \"string\"         }       ],       \"description\": \"Detailed information about a task, phase, or event\",       \"title\": \"Detail\"     },     \"Dispatch\": {       \"properties\": {         \"status\": {           \"$ref\": \"#/$defs/Status2\"         },         \"assignment\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Assignment\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"errors\": {           \"anyOf\": [             {               \"items\": {                 \"$ref\": \"#/$defs/Error\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Errors\"         }       },       \"required\": [         \"status\"       ],       \"title\": \"Dispatch\",       \"type\": \"object\"     },     \"Error\": {       \"properties\": {         \"code\": {           \"anyOf\": [             {               \"minimum\": 0,               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A standard code for the kind of error that has occurred\",           \"title\": \"Code\"         },         \"category\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"The category of the error\",           \"title\": \"Category\"         },         \"detail\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Details about the error\",           \"title\": \"Detail\"         }       },       \"title\": \"Error\",       \"type\": \"object\"     },     \"EstimateMillis\": {       \"description\": \"An estimate, in milliseconds, of how long the subject will take to complete\",       \"minimum\": 0,       \"title\": \"EstimateMillis\",       \"type\": \"integer\"     },     \"EventState\": {       \"properties\": {         \"id\": {           \"$ref\": \"#/$defs/Id\"         },         \"status\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Status\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"name\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"The brief name of the event\",           \"title\": \"Name\"         },         \"detail\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Detail\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Detailed information about the event\"         },         \"deps\": {           \"anyOf\": [             {               \"items\": {                 \"minimum\": 0,                 \"type\": \"integer\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"This event may depend on other events. This array contains the IDs of those other event dependencies.\",           \"title\": \"Deps\"         }       },       \"required\": [         \"id\"       ],       \"title\": \"EventState\",       \"type\": \"object\"     },     \"Id\": {       \"minimum\": 0,       \"title\": \"Id\",       \"type\": \"integer\"     },     \"Interruption\": {       \"properties\": {         \"unix_millis_request_time\": {           \"description\": \"The time that the interruption request arrived\",           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"labels\": {           \"description\": \"Labels to describe the purpose of the interruption, items can be a single value like `dashboard` or a key-value pair like `app=dashboard`, in the case of a single value, it will be interpreted as a key-value pair with an empty string value.\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         },         \"resumed_by\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/ResumedBy\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Information about the resume request that ended this interruption. This field will be missing if the interruption is still active.\"         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ],       \"title\": \"Interruption\",       \"type\": \"object\"     },     \"Killed\": {       \"properties\": {         \"unix_millis_request_time\": {           \"description\": \"The time that the cancellation request arrived\",           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"labels\": {           \"description\": \"Labels to describe the kill request, items can be a single value like `dashboard` or a key-value pair like `app=dashboard`, in the case of a single value, it will be interpreted as a key-value pair with an empty string value.\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ],       \"title\": \"Killed\",       \"type\": \"object\"     },     \"Phase\": {       \"properties\": {         \"id\": {           \"$ref\": \"#/$defs/Id\"         },         \"category\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Category\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"detail\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Detail\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"unix_millis_start_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Unix Millis Start Time\"         },         \"unix_millis_finish_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Unix Millis Finish Time\"         },         \"original_estimate_millis\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/EstimateMillis\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"estimate_millis\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/EstimateMillis\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"final_event_id\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Id\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"events\": {           \"anyOf\": [             {               \"additionalProperties\": {                 \"$ref\": \"#/$defs/EventState\"               },               \"type\": \"object\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A dictionary of events for this phase. The keys (property names) are the event IDs, which are integers.\",           \"title\": \"Events\"         },         \"skip_requests\": {           \"anyOf\": [             {               \"additionalProperties\": {                 \"$ref\": \"#/$defs/SkipPhaseRequest\"               },               \"type\": \"object\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Information about any skip requests that have been received\",           \"title\": \"Skip Requests\"         }       },       \"required\": [         \"id\"       ],       \"title\": \"Phase\",       \"type\": \"object\"     },     \"ResumedBy\": {       \"properties\": {         \"unix_millis_request_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"The time that the resume request arrived\",           \"title\": \"Unix Millis Request Time\"         },         \"labels\": {           \"description\": \"Labels to describe the resume request, items can be a single value like `dashboard` or a key-value pair like `app=dashboard`, in the case of a single value, it will be interpreted as a key-value pair with an empty string value.\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         }       },       \"required\": [         \"labels\"       ],       \"title\": \"ResumedBy\",       \"type\": \"object\"     },     \"SkipPhaseRequest\": {       \"properties\": {         \"unix_millis_request_time\": {           \"description\": \"The time that the skip request arrived\",           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"labels\": {           \"description\": \"Labels to describe the purpose of the skip request, items can be a single value like `dashboard` or a key-value pair like `app=dashboard`, in the case of a single value, it will be interpreted as a key-value pair with an empty string value.\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         },         \"undo\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Undo\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Information about an undo skip request that applied to this request\"         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ],       \"title\": \"SkipPhaseRequest\",       \"type\": \"object\"     },     \"Status\": {       \"enum\": [         \"uninitialized\",         \"blocked\",         \"error\",         \"failed\",         \"queued\",         \"standby\",         \"underway\",         \"delayed\",         \"skipped\",         \"canceled\",         \"killed\",         \"completed\"       ],       \"title\": \"Status\",       \"type\": \"string\"     },     \"Status2\": {       \"enum\": [         \"queued\",         \"selected\",         \"dispatched\",         \"failed_to_assign\",         \"canceled_in_flight\"       ],       \"title\": \"Status2\",       \"type\": \"string\"     },     \"Undo\": {       \"properties\": {         \"unix_millis_request_time\": {           \"description\": \"The time that the undo skip request arrived\",           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"labels\": {           \"description\": \"Labels to describe the undo skip request, items can be a single value like `dashboard` or a key-value pair like `app=dashboard`, in the case of a single value, it will be interpreted as a key-value pair with an empty string value.\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ],       \"title\": \"Undo\",       \"type\": \"object\"     }   },   \"properties\": {     \"booking\": {       \"$ref\": \"#/$defs/Booking\"     },     \"category\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Category\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"detail\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Detail\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"unix_millis_start_time\": {       \"anyOf\": [         {           \"type\": \"integer\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"title\": \"Unix Millis Start Time\"     },     \"unix_millis_finish_time\": {       \"anyOf\": [         {           \"type\": \"integer\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"title\": \"Unix Millis Finish Time\"     },     \"original_estimate_millis\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/EstimateMillis\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"estimate_millis\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/EstimateMillis\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"assigned_to\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/AssignedTo\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"Which agent (robot) is the task assigned to\"     },     \"status\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Status\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"dispatch\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Dispatch\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"phases\": {       \"anyOf\": [         {           \"additionalProperties\": {             \"$ref\": \"#/$defs/Phase\"           },           \"type\": \"object\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"A dictionary of the states of the phases of the task. The keys (property names) are phase IDs, which are integers.\",       \"title\": \"Phases\"     },     \"completed\": {       \"anyOf\": [         {           \"items\": {             \"$ref\": \"#/$defs/Id\"           },           \"type\": \"array\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"An array of the IDs of completed phases of this task\",       \"title\": \"Completed\"     },     \"active\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Id\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"The ID of the active phase for this task\"     },     \"pending\": {       \"anyOf\": [         {           \"items\": {             \"$ref\": \"#/$defs/Id\"           },           \"type\": \"array\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"An array of the pending phases of this task\",       \"title\": \"Pending\"     },     \"interruptions\": {       \"anyOf\": [         {           \"additionalProperties\": {             \"$ref\": \"#/$defs/Interruption\"           },           \"type\": \"object\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"A dictionary of interruptions that have been applied to this task. The keys (property names) are the unique token of the interruption request.\",       \"title\": \"Interruptions\"     },     \"cancellation\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Cancellation\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"If the task was cancelled, this will describe information about the request.\"     },     \"killed\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Killed\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"If the task was killed, this will describe information about the request.\"     }   },   \"required\": [     \"booking\"   ],   \"title\": \"TaskState\",   \"type\": \"object\" } ```   ### /tasks/{task_id}/log   ``` {   \"$defs\": {     \"LogEntry\": {       \"properties\": {         \"seq\": {           \"description\": \"Sequence number for this entry. Each entry has a unique sequence number which monotonically increase, until integer overflow causes a wrap around.\",           \"exclusiveMaximum\": 4294967296,           \"minimum\": 0,           \"title\": \"Seq\",           \"type\": \"integer\"         },         \"tier\": {           \"allOf\": [             {               \"$ref\": \"#/$defs/Tier\"             }           ],           \"description\": \"The importance level of the log entry\"         },         \"unix_millis_time\": {           \"title\": \"Unix Millis Time\",           \"type\": \"integer\"         },         \"text\": {           \"description\": \"The text of the log entry\",           \"title\": \"Text\",           \"type\": \"string\"         }       },       \"required\": [         \"seq\",         \"tier\",         \"unix_millis_time\",         \"text\"       ],       \"title\": \"LogEntry\",       \"type\": \"object\"     },     \"Phases\": {       \"additionalProperties\": false,       \"properties\": {         \"log\": {           \"anyOf\": [             {               \"items\": {                 \"$ref\": \"#/$defs/LogEntry\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Log entries related to the overall phase\",           \"title\": \"Log\"         },         \"events\": {           \"anyOf\": [             {               \"additionalProperties\": {                 \"items\": {                   \"$ref\": \"#/$defs/LogEntry\"                 },                 \"type\": \"array\"               },               \"type\": \"object\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A dictionary whose keys (property names) are the indices of an event in the phase\",           \"title\": \"Events\"         }       },       \"title\": \"Phases\",       \"type\": \"object\"     },     \"Tier\": {       \"enum\": [         \"uninitialized\",         \"info\",         \"warning\",         \"error\"       ],       \"title\": \"Tier\",       \"type\": \"string\"     }   },   \"additionalProperties\": false,   \"properties\": {     \"task_id\": {       \"title\": \"Task Id\",       \"type\": \"string\"     },     \"log\": {       \"anyOf\": [         {           \"items\": {             \"$ref\": \"#/$defs/LogEntry\"           },           \"type\": \"array\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"Log entries related to the overall task\",       \"title\": \"Log\"     },     \"phases\": {       \"anyOf\": [         {           \"additionalProperties\": {             \"$ref\": \"#/$defs/Phases\"           },           \"type\": \"object\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"A dictionary whose keys (property names) are the indices of a phase\",       \"title\": \"Phases\"     }   },   \"required\": [     \"task_id\"   ],   \"title\": \"TaskEventLog\",   \"type\": \"object\" } ```   ### /dispensers/{guid}/state   ``` {   \"$defs\": {     \"Time\": {       \"properties\": {         \"sec\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Sec\",           \"type\": \"integer\"         },         \"nanosec\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Nanosec\",           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ],       \"title\": \"Time\",       \"type\": \"object\"     }   },   \"properties\": {     \"time\": {       \"$ref\": \"#/$defs/Time\"     },     \"guid\": {       \"title\": \"Guid\",       \"type\": \"string\"     },     \"mode\": {       \"maximum\": 2147483647,       \"minimum\": -2147483648,       \"title\": \"Mode\",       \"type\": \"integer\"     },     \"request_guid_queue\": {       \"items\": {         \"type\": \"string\"       },       \"title\": \"Request Guid Queue\",       \"type\": \"array\"     },     \"seconds_remaining\": {       \"title\": \"Seconds Remaining\",       \"type\": \"number\"     }   },   \"required\": [     \"time\",     \"guid\",     \"mode\",     \"request_guid_queue\",     \"seconds_remaining\"   ],   \"title\": \"DispenserState\",   \"type\": \"object\" } ```   ### /ingestors/{guid}/state   ``` {   \"$defs\": {     \"Time\": {       \"properties\": {         \"sec\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Sec\",           \"type\": \"integer\"         },         \"nanosec\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Nanosec\",           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ],       \"title\": \"Time\",       \"type\": \"object\"     }   },   \"properties\": {     \"time\": {       \"$ref\": \"#/$defs/Time\"     },     \"guid\": {       \"title\": \"Guid\",       \"type\": \"string\"     },     \"mode\": {       \"maximum\": 2147483647,       \"minimum\": -2147483648,       \"title\": \"Mode\",       \"type\": \"integer\"     },     \"request_guid_queue\": {       \"items\": {         \"type\": \"string\"       },       \"title\": \"Request Guid Queue\",       \"type\": \"array\"     },     \"seconds_remaining\": {       \"title\": \"Seconds Remaining\",       \"type\": \"number\"     }   },   \"required\": [     \"time\",     \"guid\",     \"mode\",     \"request_guid_queue\",     \"seconds_remaining\"   ],   \"title\": \"IngestorState\",   \"type\": \"object\" } ```   ### /fleets/{name}/state   ``` {   \"$defs\": {     \"Commission\": {       \"properties\": {         \"dispatch_tasks\": {           \"anyOf\": [             {               \"type\": \"boolean\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Should the robot accept dispatched tasks, true/false. When used in a request, leave this unset to not change the robot\'s current value.\",           \"title\": \"Dispatch Tasks\"         },         \"direct_tasks\": {           \"anyOf\": [             {               \"type\": \"boolean\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Should the robot accept direct task requests, true/false. When used in a request, leave this unset to not change the robot\'s current value.\",           \"title\": \"Direct Tasks\"         },         \"idle_behavior\": {           \"anyOf\": [             {               \"type\": \"boolean\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Should the robot perform its idle behavior, true/false. When used in a request, leave this unset to not change the robot\'s current value.\",           \"title\": \"Idle Behavior\"         }       },       \"title\": \"Commission\",       \"type\": \"object\"     },     \"Issue\": {       \"properties\": {         \"category\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Category of the robot\'s issue\",           \"title\": \"Category\"         },         \"detail\": {           \"anyOf\": [             {               \"type\": \"object\"             },             {               \"items\": {},               \"type\": \"array\"             },             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Detailed information about the issue\",           \"title\": \"Detail\"         }       },       \"title\": \"Issue\",       \"type\": \"object\"     },     \"Location2D\": {       \"properties\": {         \"map\": {           \"title\": \"Map\",           \"type\": \"string\"         },         \"x\": {           \"title\": \"X\",           \"type\": \"number\"         },         \"y\": {           \"title\": \"Y\",           \"type\": \"number\"         },         \"yaw\": {           \"title\": \"Yaw\",           \"type\": \"number\"         }       },       \"required\": [         \"map\",         \"x\",         \"y\",         \"yaw\"       ],       \"title\": \"Location2D\",       \"type\": \"object\"     },     \"MutexGroups\": {       \"properties\": {         \"locked\": {           \"anyOf\": [             {               \"items\": {                 \"type\": \"string\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A list of mutex groups that this robot has currently locked\",           \"title\": \"Locked\"         },         \"requesting\": {           \"anyOf\": [             {               \"items\": {                 \"type\": \"string\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A list of the mutex groups that this robot is currently requesting but has not lockd yet\",           \"title\": \"Requesting\"         }       },       \"title\": \"MutexGroups\",       \"type\": \"object\"     },     \"RobotState\": {       \"properties\": {         \"name\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Name\"         },         \"status\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Status\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A simple token representing the status of the robot\"         },         \"task_id\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"The ID of the task this robot is currently working on. Empty string if the robot is not working on a task.\",           \"title\": \"Task Id\"         },         \"unix_millis_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Unix Millis Time\"         },         \"location\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Location2D\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"battery\": {           \"anyOf\": [             {               \"maximum\": 1.0,               \"minimum\": 0.0,               \"type\": \"number\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"State of charge of the battery. Values range from 0.0 (depleted) to 1.0 (fully charged)\",           \"title\": \"Battery\"         },         \"issues\": {           \"anyOf\": [             {               \"items\": {                 \"$ref\": \"#/$defs/Issue\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A list of issues with the robot that operators need to address\",           \"title\": \"Issues\"         },         \"commission\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Commission\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"mutex_groups\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/MutexGroups\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Information about the mutex groups that this robot is interacting with\"         }       },       \"title\": \"RobotState\",       \"type\": \"object\"     },     \"Status\": {       \"enum\": [         \"uninitialized\",         \"offline\",         \"shutdown\",         \"idle\",         \"charging\",         \"working\",         \"error\"       ],       \"title\": \"Status\",       \"type\": \"string\"     }   },   \"properties\": {     \"name\": {       \"anyOf\": [         {           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"title\": \"Name\"     },     \"robots\": {       \"anyOf\": [         {           \"additionalProperties\": {             \"$ref\": \"#/$defs/RobotState\"           },           \"type\": \"object\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"A dictionary of the states of the robots that belong to this fleet\",       \"title\": \"Robots\"     }   },   \"title\": \"FleetState\",   \"type\": \"object\" } ```   ### /fleets/{name}/log   ``` {   \"$defs\": {     \"LogEntry\": {       \"properties\": {         \"seq\": {           \"description\": \"Sequence number for this entry. Each entry has a unique sequence number which monotonically increase, until integer overflow causes a wrap around.\",           \"exclusiveMaximum\": 4294967296,           \"minimum\": 0,           \"title\": \"Seq\",           \"type\": \"integer\"         },         \"tier\": {           \"allOf\": [             {               \"$ref\": \"#/$defs/Tier\"             }           ],           \"description\": \"The importance level of the log entry\"         },         \"unix_millis_time\": {           \"title\": \"Unix Millis Time\",           \"type\": \"integer\"         },         \"text\": {           \"description\": \"The text of the log entry\",           \"title\": \"Text\",           \"type\": \"string\"         }       },       \"required\": [         \"seq\",         \"tier\",         \"unix_millis_time\",         \"text\"       ],       \"title\": \"LogEntry\",       \"type\": \"object\"     },     \"Tier\": {       \"enum\": [         \"uninitialized\",         \"info\",         \"warning\",         \"error\"       ],       \"title\": \"Tier\",       \"type\": \"string\"     }   },   \"properties\": {     \"name\": {       \"anyOf\": [         {           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"title\": \"Name\"     },     \"log\": {       \"anyOf\": [         {           \"items\": {             \"$ref\": \"#/$defs/LogEntry\"           },           \"type\": \"array\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"Log for the overall fleet\",       \"title\": \"Log\"     },     \"robots\": {       \"anyOf\": [         {           \"additionalProperties\": {             \"items\": {               \"$ref\": \"#/$defs/LogEntry\"             },             \"type\": \"array\"           },           \"type\": \"object\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"Dictionary of logs for the individual robots. The keys (property names) are the robot names.\",       \"title\": \"Robots\"     }   },   \"title\": \"FleetLog\",   \"type\": \"object\" } ```   ### /rios   ``` {   \"properties\": {     \"id\": {       \"title\": \"Id\",       \"type\": \"string\"     },     \"type\": {       \"title\": \"Type\",       \"type\": \"string\"     },     \"data\": {       \"title\": \"Data\",       \"type\": \"object\"     }   },   \"required\": [     \"id\",     \"type\",     \"data\"   ],   \"title\": \"Rio\",   \"type\": \"object\" } ```
     * @summary Socket.io endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lambdaSocketIoGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/socket.io`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration);
  return {
    /**
     * Get the effective permissions of the current user
     * @summary Get Effective Permissions
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEffectivePermissionsPermissionsGet(
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Permission>>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getEffectivePermissionsPermissionsGet(
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.getEffectivePermissionsPermissionsGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get the current rmf time in unix milliseconds
     * @summary Get Time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTimeTimeGet(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTimeTimeGet(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.getTimeTimeGet']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get the currently logged in user
     * @summary Get User
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserUserGet(
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserUserGet(
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.getUserUserGet']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * # NOTE: This endpoint is here for documentation purposes only, this is _not_ a REST endpoint.  ## About This exposes a minimal pubsub system built on top of socket.io. It works similar to a normal socket.io endpoint, except that are 2 special rooms which control subscriptions.  ## Rooms ### subscribe Clients must send a message to this room to start receiving messages on other rooms. The message must be of the form:  ``` {     \"room\": \"<room_name>\" } ```  ### unsubscribe Clients can send a message to this room to stop receiving messages on other rooms. The message must be of the form:  ``` {     \"room\": \"<room_name>\" } ``` ### /alerts/requests   ``` {   \"$defs\": {     \"AlertParameter\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"value\": {           \"title\": \"Value\",           \"type\": \"string\"         }       },       \"required\": [         \"name\",         \"value\"       ],       \"title\": \"AlertParameter\",       \"type\": \"object\"     },     \"Tier\": {       \"enum\": [         \"info\",         \"warning\",         \"error\"       ],       \"title\": \"Tier\",       \"type\": \"string\"     }   },   \"properties\": {     \"id\": {       \"title\": \"Id\",       \"type\": \"string\"     },     \"unix_millis_alert_time\": {       \"title\": \"Unix Millis Alert Time\",       \"type\": \"integer\"     },     \"title\": {       \"title\": \"Title\",       \"type\": \"string\"     },     \"subtitle\": {       \"title\": \"Subtitle\",       \"type\": \"string\"     },     \"message\": {       \"title\": \"Message\",       \"type\": \"string\"     },     \"display\": {       \"title\": \"Display\",       \"type\": \"boolean\"     },     \"tier\": {       \"$ref\": \"#/$defs/Tier\"     },     \"responses_available\": {       \"items\": {         \"type\": \"string\"       },       \"title\": \"Responses Available\",       \"type\": \"array\"     },     \"alert_parameters\": {       \"items\": {         \"$ref\": \"#/$defs/AlertParameter\"       },       \"title\": \"Alert Parameters\",       \"type\": \"array\"     },     \"task_id\": {       \"anyOf\": [         {           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"title\": \"Task Id\"     }   },   \"required\": [     \"id\",     \"unix_millis_alert_time\",     \"title\",     \"subtitle\",     \"message\",     \"display\",     \"tier\",     \"responses_available\",     \"alert_parameters\",     \"task_id\"   ],   \"title\": \"AlertRequest\",   \"type\": \"object\" } ```   ### /alerts/responses   ``` {   \"properties\": {     \"id\": {       \"title\": \"Id\",       \"type\": \"string\"     },     \"unix_millis_response_time\": {       \"title\": \"Unix Millis Response Time\",       \"type\": \"integer\"     },     \"response\": {       \"title\": \"Response\",       \"type\": \"string\"     }   },   \"required\": [     \"id\",     \"unix_millis_response_time\",     \"response\"   ],   \"title\": \"AlertResponse\",   \"type\": \"object\" } ```   ### /beacons   ``` {   \"properties\": {     \"id\": {       \"title\": \"Id\",       \"type\": \"string\"     },     \"online\": {       \"title\": \"Online\",       \"type\": \"boolean\"     },     \"category\": {       \"title\": \"Category\",       \"type\": \"string\"     },     \"activated\": {       \"title\": \"Activated\",       \"type\": \"boolean\"     },     \"level\": {       \"title\": \"Level\",       \"type\": \"string\"     }   },   \"required\": [     \"id\",     \"online\",     \"category\",     \"activated\",     \"level\"   ],   \"title\": \"BeaconState\",   \"type\": \"object\" } ```   ### /building_map   ``` {   \"$defs\": {     \"AffineImage\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"x_offset\": {           \"title\": \"X Offset\",           \"type\": \"number\"         },         \"y_offset\": {           \"title\": \"Y Offset\",           \"type\": \"number\"         },         \"yaw\": {           \"title\": \"Yaw\",           \"type\": \"number\"         },         \"scale\": {           \"title\": \"Scale\",           \"type\": \"number\"         },         \"encoding\": {           \"title\": \"Encoding\",           \"type\": \"string\"         },         \"data\": {           \"title\": \"Data\",           \"type\": \"string\"         }       },       \"required\": [         \"name\",         \"x_offset\",         \"y_offset\",         \"yaw\",         \"scale\",         \"encoding\",         \"data\"       ],       \"title\": \"AffineImage\",       \"type\": \"object\"     },     \"Door\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"v1_x\": {           \"title\": \"V1 X\",           \"type\": \"number\"         },         \"v1_y\": {           \"title\": \"V1 Y\",           \"type\": \"number\"         },         \"v2_x\": {           \"title\": \"V2 X\",           \"type\": \"number\"         },         \"v2_y\": {           \"title\": \"V2 Y\",           \"type\": \"number\"         },         \"door_type\": {           \"maximum\": 255,           \"minimum\": 0,           \"title\": \"Door Type\",           \"type\": \"integer\"         },         \"motion_range\": {           \"title\": \"Motion Range\",           \"type\": \"number\"         },         \"motion_direction\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Motion Direction\",           \"type\": \"integer\"         }       },       \"required\": [         \"name\",         \"v1_x\",         \"v1_y\",         \"v2_x\",         \"v2_y\",         \"door_type\",         \"motion_range\",         \"motion_direction\"       ],       \"title\": \"Door\",       \"type\": \"object\"     },     \"Graph\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"vertices\": {           \"items\": {             \"$ref\": \"#/$defs/GraphNode\"           },           \"title\": \"Vertices\",           \"type\": \"array\"         },         \"edges\": {           \"items\": {             \"$ref\": \"#/$defs/GraphEdge\"           },           \"title\": \"Edges\",           \"type\": \"array\"         },         \"params\": {           \"items\": {             \"$ref\": \"#/$defs/Param\"           },           \"title\": \"Params\",           \"type\": \"array\"         }       },       \"required\": [         \"name\",         \"vertices\",         \"edges\",         \"params\"       ],       \"title\": \"Graph\",       \"type\": \"object\"     },     \"GraphEdge\": {       \"properties\": {         \"v1_idx\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"V1 Idx\",           \"type\": \"integer\"         },         \"v2_idx\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"V2 Idx\",           \"type\": \"integer\"         },         \"params\": {           \"items\": {             \"$ref\": \"#/$defs/Param\"           },           \"title\": \"Params\",           \"type\": \"array\"         },         \"edge_type\": {           \"maximum\": 255,           \"minimum\": 0,           \"title\": \"Edge Type\",           \"type\": \"integer\"         }       },       \"required\": [         \"v1_idx\",         \"v2_idx\",         \"params\",         \"edge_type\"       ],       \"title\": \"GraphEdge\",       \"type\": \"object\"     },     \"GraphNode\": {       \"properties\": {         \"x\": {           \"title\": \"X\",           \"type\": \"number\"         },         \"y\": {           \"title\": \"Y\",           \"type\": \"number\"         },         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"params\": {           \"items\": {             \"$ref\": \"#/$defs/Param\"           },           \"title\": \"Params\",           \"type\": \"array\"         }       },       \"required\": [         \"x\",         \"y\",         \"name\",         \"params\"       ],       \"title\": \"GraphNode\",       \"type\": \"object\"     },     \"Level\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"elevation\": {           \"title\": \"Elevation\",           \"type\": \"number\"         },         \"images\": {           \"items\": {             \"$ref\": \"#/$defs/AffineImage\"           },           \"title\": \"Images\",           \"type\": \"array\"         },         \"places\": {           \"items\": {             \"$ref\": \"#/$defs/Place\"           },           \"title\": \"Places\",           \"type\": \"array\"         },         \"doors\": {           \"items\": {             \"$ref\": \"#/$defs/Door\"           },           \"title\": \"Doors\",           \"type\": \"array\"         },         \"nav_graphs\": {           \"items\": {             \"$ref\": \"#/$defs/Graph\"           },           \"title\": \"Nav Graphs\",           \"type\": \"array\"         },         \"wall_graph\": {           \"$ref\": \"#/$defs/Graph\"         }       },       \"required\": [         \"name\",         \"elevation\",         \"images\",         \"places\",         \"doors\",         \"nav_graphs\",         \"wall_graph\"       ],       \"title\": \"Level\",       \"type\": \"object\"     },     \"Lift\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"levels\": {           \"items\": {             \"type\": \"string\"           },           \"title\": \"Levels\",           \"type\": \"array\"         },         \"doors\": {           \"items\": {             \"$ref\": \"#/$defs/Door\"           },           \"title\": \"Doors\",           \"type\": \"array\"         },         \"wall_graph\": {           \"$ref\": \"#/$defs/Graph\"         },         \"ref_x\": {           \"title\": \"Ref X\",           \"type\": \"number\"         },         \"ref_y\": {           \"title\": \"Ref Y\",           \"type\": \"number\"         },         \"ref_yaw\": {           \"title\": \"Ref Yaw\",           \"type\": \"number\"         },         \"width\": {           \"title\": \"Width\",           \"type\": \"number\"         },         \"depth\": {           \"title\": \"Depth\",           \"type\": \"number\"         }       },       \"required\": [         \"name\",         \"levels\",         \"doors\",         \"wall_graph\",         \"ref_x\",         \"ref_y\",         \"ref_yaw\",         \"width\",         \"depth\"       ],       \"title\": \"Lift\",       \"type\": \"object\"     },     \"Param\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"type\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Type\",           \"type\": \"integer\"         },         \"value_int\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Value Int\",           \"type\": \"integer\"         },         \"value_float\": {           \"title\": \"Value Float\",           \"type\": \"number\"         },         \"value_string\": {           \"title\": \"Value String\",           \"type\": \"string\"         },         \"value_bool\": {           \"title\": \"Value Bool\",           \"type\": \"boolean\"         }       },       \"required\": [         \"name\",         \"type\",         \"value_int\",         \"value_float\",         \"value_string\",         \"value_bool\"       ],       \"title\": \"Param\",       \"type\": \"object\"     },     \"Place\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"x\": {           \"title\": \"X\",           \"type\": \"number\"         },         \"y\": {           \"title\": \"Y\",           \"type\": \"number\"         },         \"yaw\": {           \"title\": \"Yaw\",           \"type\": \"number\"         },         \"position_tolerance\": {           \"title\": \"Position Tolerance\",           \"type\": \"number\"         },         \"yaw_tolerance\": {           \"title\": \"Yaw Tolerance\",           \"type\": \"number\"         }       },       \"required\": [         \"name\",         \"x\",         \"y\",         \"yaw\",         \"position_tolerance\",         \"yaw_tolerance\"       ],       \"title\": \"Place\",       \"type\": \"object\"     }   },   \"properties\": {     \"name\": {       \"title\": \"Name\",       \"type\": \"string\"     },     \"levels\": {       \"items\": {         \"$ref\": \"#/$defs/Level\"       },       \"title\": \"Levels\",       \"type\": \"array\"     },     \"lifts\": {       \"items\": {         \"$ref\": \"#/$defs/Lift\"       },       \"title\": \"Lifts\",       \"type\": \"array\"     }   },   \"required\": [     \"name\",     \"levels\",     \"lifts\"   ],   \"title\": \"BuildingMap\",   \"type\": \"object\" } ```   ### /building_map/fire_alarm_trigger   ``` {   \"properties\": {     \"unix_millis_time\": {       \"title\": \"Unix Millis Time\",       \"type\": \"integer\"     },     \"trigger\": {       \"title\": \"Trigger\",       \"type\": \"boolean\"     }   },   \"required\": [     \"unix_millis_time\",     \"trigger\"   ],   \"title\": \"FireAlarmTriggerState\",   \"type\": \"object\" } ```   ### /delivery_alerts   ``` {   \"$defs\": {     \"Action\": {       \"enum\": [         \"waiting\",         \"cancel\",         \"override\",         \"resume\"       ],       \"title\": \"Action\",       \"type\": \"string\"     },     \"Category\": {       \"enum\": [         \"missing\",         \"wrong\",         \"obstructed\",         \"cancelled\"       ],       \"title\": \"Category\",       \"type\": \"string\"     },     \"Tier\": {       \"enum\": [         \"warning\",         \"error\"       ],       \"title\": \"Tier\",       \"type\": \"string\"     }   },   \"properties\": {     \"id\": {       \"title\": \"Id\",       \"type\": \"string\"     },     \"category\": {       \"$ref\": \"#/$defs/Category\"     },     \"tier\": {       \"$ref\": \"#/$defs/Tier\"     },     \"action\": {       \"$ref\": \"#/$defs/Action\"     },     \"task_id\": {       \"title\": \"Task Id\",       \"type\": \"string\"     },     \"message\": {       \"title\": \"Message\",       \"type\": \"string\"     }   },   \"required\": [     \"id\",     \"category\",     \"tier\",     \"action\",     \"task_id\",     \"message\"   ],   \"title\": \"DeliveryAlert\",   \"type\": \"object\" } ```   ### /doors/{door_name}/state   ``` {   \"$defs\": {     \"DoorMode\": {       \"properties\": {         \"value\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Value\",           \"type\": \"integer\"         }       },       \"required\": [         \"value\"       ],       \"title\": \"DoorMode\",       \"type\": \"object\"     },     \"Time\": {       \"properties\": {         \"sec\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Sec\",           \"type\": \"integer\"         },         \"nanosec\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Nanosec\",           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ],       \"title\": \"Time\",       \"type\": \"object\"     }   },   \"properties\": {     \"door_time\": {       \"$ref\": \"#/$defs/Time\"     },     \"door_name\": {       \"title\": \"Door Name\",       \"type\": \"string\"     },     \"current_mode\": {       \"$ref\": \"#/$defs/DoorMode\"     }   },   \"required\": [     \"door_time\",     \"door_name\",     \"current_mode\"   ],   \"title\": \"DoorState\",   \"type\": \"object\" } ```   ### /lifts/{lift_name}/state   ``` {   \"$defs\": {     \"Time\": {       \"properties\": {         \"sec\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Sec\",           \"type\": \"integer\"         },         \"nanosec\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Nanosec\",           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ],       \"title\": \"Time\",       \"type\": \"object\"     }   },   \"properties\": {     \"lift_time\": {       \"$ref\": \"#/$defs/Time\"     },     \"lift_name\": {       \"title\": \"Lift Name\",       \"type\": \"string\"     },     \"available_floors\": {       \"items\": {         \"type\": \"string\"       },       \"title\": \"Available Floors\",       \"type\": \"array\"     },     \"current_floor\": {       \"title\": \"Current Floor\",       \"type\": \"string\"     },     \"destination_floor\": {       \"title\": \"Destination Floor\",       \"type\": \"string\"     },     \"door_state\": {       \"maximum\": 255,       \"minimum\": 0,       \"title\": \"Door State\",       \"type\": \"integer\"     },     \"motion_state\": {       \"maximum\": 255,       \"minimum\": 0,       \"title\": \"Motion State\",       \"type\": \"integer\"     },     \"available_modes\": {       \"items\": {         \"type\": \"integer\"       },       \"title\": \"Available Modes\",       \"type\": \"array\"     },     \"current_mode\": {       \"maximum\": 255,       \"minimum\": 0,       \"title\": \"Current Mode\",       \"type\": \"integer\"     },     \"session_id\": {       \"title\": \"Session Id\",       \"type\": \"string\"     }   },   \"required\": [     \"lift_time\",     \"lift_name\",     \"available_floors\",     \"current_floor\",     \"destination_floor\",     \"door_state\",     \"motion_state\",     \"available_modes\",     \"current_mode\",     \"session_id\"   ],   \"title\": \"LiftState\",   \"type\": \"object\" } ```   ### /tasks/{task_id}/state   ``` {   \"$defs\": {     \"AssignedTo\": {       \"properties\": {         \"group\": {           \"title\": \"Group\",           \"type\": \"string\"         },         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         }       },       \"required\": [         \"group\",         \"name\"       ],       \"title\": \"AssignedTo\",       \"type\": \"object\"     },     \"Assignment\": {       \"properties\": {         \"fleet_name\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Fleet Name\"         },         \"expected_robot_name\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Expected Robot Name\"         }       },       \"title\": \"Assignment\",       \"type\": \"object\"     },     \"Booking\": {       \"properties\": {         \"id\": {           \"description\": \"The unique identifier for this task\",           \"title\": \"Id\",           \"type\": \"string\"         },         \"unix_millis_earliest_start_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Unix Millis Earliest Start Time\"         },         \"unix_millis_request_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Unix Millis Request Time\"         },         \"priority\": {           \"anyOf\": [             {               \"type\": \"object\"             },             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Priority information about this task\",           \"title\": \"Priority\"         },         \"labels\": {           \"anyOf\": [             {               \"items\": {                 \"type\": \"string\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Information about how and why this task was booked, items can be a single value like `dashboard` or a key-value pair like `app=dashboard`, in the case of a single value, it will be interpreted as a key-value pair with an empty string value.\",           \"title\": \"Labels\"         },         \"requester\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"(Optional) An identifier for the entity that requested this task\",           \"title\": \"Requester\"         }       },       \"required\": [         \"id\"       ],       \"title\": \"Booking\",       \"type\": \"object\"     },     \"Cancellation\": {       \"properties\": {         \"unix_millis_request_time\": {           \"description\": \"The time that the cancellation request arrived\",           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"labels\": {           \"description\": \"Labels to describe the cancel request, items can be a single value like `dashboard` or a key-value pair like `app=dashboard`, in the case of a single value, it will be interpreted as a key-value pair with an empty string value.\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ],       \"title\": \"Cancellation\",       \"type\": \"object\"     },     \"Category\": {       \"description\": \"The category of this task or phase\",       \"title\": \"Category\",       \"type\": \"string\"     },     \"Detail\": {       \"anyOf\": [         {           \"type\": \"object\"         },         {           \"items\": {},           \"type\": \"array\"         },         {           \"type\": \"string\"         }       ],       \"description\": \"Detailed information about a task, phase, or event\",       \"title\": \"Detail\"     },     \"Dispatch\": {       \"properties\": {         \"status\": {           \"$ref\": \"#/$defs/Status2\"         },         \"assignment\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Assignment\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"errors\": {           \"anyOf\": [             {               \"items\": {                 \"$ref\": \"#/$defs/Error\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Errors\"         }       },       \"required\": [         \"status\"       ],       \"title\": \"Dispatch\",       \"type\": \"object\"     },     \"Error\": {       \"properties\": {         \"code\": {           \"anyOf\": [             {               \"minimum\": 0,               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A standard code for the kind of error that has occurred\",           \"title\": \"Code\"         },         \"category\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"The category of the error\",           \"title\": \"Category\"         },         \"detail\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Details about the error\",           \"title\": \"Detail\"         }       },       \"title\": \"Error\",       \"type\": \"object\"     },     \"EstimateMillis\": {       \"description\": \"An estimate, in milliseconds, of how long the subject will take to complete\",       \"minimum\": 0,       \"title\": \"EstimateMillis\",       \"type\": \"integer\"     },     \"EventState\": {       \"properties\": {         \"id\": {           \"$ref\": \"#/$defs/Id\"         },         \"status\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Status\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"name\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"The brief name of the event\",           \"title\": \"Name\"         },         \"detail\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Detail\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Detailed information about the event\"         },         \"deps\": {           \"anyOf\": [             {               \"items\": {                 \"minimum\": 0,                 \"type\": \"integer\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"This event may depend on other events. This array contains the IDs of those other event dependencies.\",           \"title\": \"Deps\"         }       },       \"required\": [         \"id\"       ],       \"title\": \"EventState\",       \"type\": \"object\"     },     \"Id\": {       \"minimum\": 0,       \"title\": \"Id\",       \"type\": \"integer\"     },     \"Interruption\": {       \"properties\": {         \"unix_millis_request_time\": {           \"description\": \"The time that the interruption request arrived\",           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"labels\": {           \"description\": \"Labels to describe the purpose of the interruption, items can be a single value like `dashboard` or a key-value pair like `app=dashboard`, in the case of a single value, it will be interpreted as a key-value pair with an empty string value.\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         },         \"resumed_by\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/ResumedBy\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Information about the resume request that ended this interruption. This field will be missing if the interruption is still active.\"         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ],       \"title\": \"Interruption\",       \"type\": \"object\"     },     \"Killed\": {       \"properties\": {         \"unix_millis_request_time\": {           \"description\": \"The time that the cancellation request arrived\",           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"labels\": {           \"description\": \"Labels to describe the kill request, items can be a single value like `dashboard` or a key-value pair like `app=dashboard`, in the case of a single value, it will be interpreted as a key-value pair with an empty string value.\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ],       \"title\": \"Killed\",       \"type\": \"object\"     },     \"Phase\": {       \"properties\": {         \"id\": {           \"$ref\": \"#/$defs/Id\"         },         \"category\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Category\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"detail\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Detail\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"unix_millis_start_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Unix Millis Start Time\"         },         \"unix_millis_finish_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Unix Millis Finish Time\"         },         \"original_estimate_millis\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/EstimateMillis\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"estimate_millis\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/EstimateMillis\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"final_event_id\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Id\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"events\": {           \"anyOf\": [             {               \"additionalProperties\": {                 \"$ref\": \"#/$defs/EventState\"               },               \"type\": \"object\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A dictionary of events for this phase. The keys (property names) are the event IDs, which are integers.\",           \"title\": \"Events\"         },         \"skip_requests\": {           \"anyOf\": [             {               \"additionalProperties\": {                 \"$ref\": \"#/$defs/SkipPhaseRequest\"               },               \"type\": \"object\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Information about any skip requests that have been received\",           \"title\": \"Skip Requests\"         }       },       \"required\": [         \"id\"       ],       \"title\": \"Phase\",       \"type\": \"object\"     },     \"ResumedBy\": {       \"properties\": {         \"unix_millis_request_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"The time that the resume request arrived\",           \"title\": \"Unix Millis Request Time\"         },         \"labels\": {           \"description\": \"Labels to describe the resume request, items can be a single value like `dashboard` or a key-value pair like `app=dashboard`, in the case of a single value, it will be interpreted as a key-value pair with an empty string value.\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         }       },       \"required\": [         \"labels\"       ],       \"title\": \"ResumedBy\",       \"type\": \"object\"     },     \"SkipPhaseRequest\": {       \"properties\": {         \"unix_millis_request_time\": {           \"description\": \"The time that the skip request arrived\",           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"labels\": {           \"description\": \"Labels to describe the purpose of the skip request, items can be a single value like `dashboard` or a key-value pair like `app=dashboard`, in the case of a single value, it will be interpreted as a key-value pair with an empty string value.\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         },         \"undo\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Undo\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Information about an undo skip request that applied to this request\"         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ],       \"title\": \"SkipPhaseRequest\",       \"type\": \"object\"     },     \"Status\": {       \"enum\": [         \"uninitialized\",         \"blocked\",         \"error\",         \"failed\",         \"queued\",         \"standby\",         \"underway\",         \"delayed\",         \"skipped\",         \"canceled\",         \"killed\",         \"completed\"       ],       \"title\": \"Status\",       \"type\": \"string\"     },     \"Status2\": {       \"enum\": [         \"queued\",         \"selected\",         \"dispatched\",         \"failed_to_assign\",         \"canceled_in_flight\"       ],       \"title\": \"Status2\",       \"type\": \"string\"     },     \"Undo\": {       \"properties\": {         \"unix_millis_request_time\": {           \"description\": \"The time that the undo skip request arrived\",           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"labels\": {           \"description\": \"Labels to describe the undo skip request, items can be a single value like `dashboard` or a key-value pair like `app=dashboard`, in the case of a single value, it will be interpreted as a key-value pair with an empty string value.\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ],       \"title\": \"Undo\",       \"type\": \"object\"     }   },   \"properties\": {     \"booking\": {       \"$ref\": \"#/$defs/Booking\"     },     \"category\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Category\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"detail\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Detail\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"unix_millis_start_time\": {       \"anyOf\": [         {           \"type\": \"integer\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"title\": \"Unix Millis Start Time\"     },     \"unix_millis_finish_time\": {       \"anyOf\": [         {           \"type\": \"integer\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"title\": \"Unix Millis Finish Time\"     },     \"original_estimate_millis\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/EstimateMillis\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"estimate_millis\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/EstimateMillis\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"assigned_to\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/AssignedTo\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"Which agent (robot) is the task assigned to\"     },     \"status\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Status\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"dispatch\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Dispatch\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"phases\": {       \"anyOf\": [         {           \"additionalProperties\": {             \"$ref\": \"#/$defs/Phase\"           },           \"type\": \"object\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"A dictionary of the states of the phases of the task. The keys (property names) are phase IDs, which are integers.\",       \"title\": \"Phases\"     },     \"completed\": {       \"anyOf\": [         {           \"items\": {             \"$ref\": \"#/$defs/Id\"           },           \"type\": \"array\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"An array of the IDs of completed phases of this task\",       \"title\": \"Completed\"     },     \"active\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Id\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"The ID of the active phase for this task\"     },     \"pending\": {       \"anyOf\": [         {           \"items\": {             \"$ref\": \"#/$defs/Id\"           },           \"type\": \"array\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"An array of the pending phases of this task\",       \"title\": \"Pending\"     },     \"interruptions\": {       \"anyOf\": [         {           \"additionalProperties\": {             \"$ref\": \"#/$defs/Interruption\"           },           \"type\": \"object\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"A dictionary of interruptions that have been applied to this task. The keys (property names) are the unique token of the interruption request.\",       \"title\": \"Interruptions\"     },     \"cancellation\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Cancellation\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"If the task was cancelled, this will describe information about the request.\"     },     \"killed\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Killed\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"If the task was killed, this will describe information about the request.\"     }   },   \"required\": [     \"booking\"   ],   \"title\": \"TaskState\",   \"type\": \"object\" } ```   ### /tasks/{task_id}/log   ``` {   \"$defs\": {     \"LogEntry\": {       \"properties\": {         \"seq\": {           \"description\": \"Sequence number for this entry. Each entry has a unique sequence number which monotonically increase, until integer overflow causes a wrap around.\",           \"exclusiveMaximum\": 4294967296,           \"minimum\": 0,           \"title\": \"Seq\",           \"type\": \"integer\"         },         \"tier\": {           \"allOf\": [             {               \"$ref\": \"#/$defs/Tier\"             }           ],           \"description\": \"The importance level of the log entry\"         },         \"unix_millis_time\": {           \"title\": \"Unix Millis Time\",           \"type\": \"integer\"         },         \"text\": {           \"description\": \"The text of the log entry\",           \"title\": \"Text\",           \"type\": \"string\"         }       },       \"required\": [         \"seq\",         \"tier\",         \"unix_millis_time\",         \"text\"       ],       \"title\": \"LogEntry\",       \"type\": \"object\"     },     \"Phases\": {       \"additionalProperties\": false,       \"properties\": {         \"log\": {           \"anyOf\": [             {               \"items\": {                 \"$ref\": \"#/$defs/LogEntry\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Log entries related to the overall phase\",           \"title\": \"Log\"         },         \"events\": {           \"anyOf\": [             {               \"additionalProperties\": {                 \"items\": {                   \"$ref\": \"#/$defs/LogEntry\"                 },                 \"type\": \"array\"               },               \"type\": \"object\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A dictionary whose keys (property names) are the indices of an event in the phase\",           \"title\": \"Events\"         }       },       \"title\": \"Phases\",       \"type\": \"object\"     },     \"Tier\": {       \"enum\": [         \"uninitialized\",         \"info\",         \"warning\",         \"error\"       ],       \"title\": \"Tier\",       \"type\": \"string\"     }   },   \"additionalProperties\": false,   \"properties\": {     \"task_id\": {       \"title\": \"Task Id\",       \"type\": \"string\"     },     \"log\": {       \"anyOf\": [         {           \"items\": {             \"$ref\": \"#/$defs/LogEntry\"           },           \"type\": \"array\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"Log entries related to the overall task\",       \"title\": \"Log\"     },     \"phases\": {       \"anyOf\": [         {           \"additionalProperties\": {             \"$ref\": \"#/$defs/Phases\"           },           \"type\": \"object\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"A dictionary whose keys (property names) are the indices of a phase\",       \"title\": \"Phases\"     }   },   \"required\": [     \"task_id\"   ],   \"title\": \"TaskEventLog\",   \"type\": \"object\" } ```   ### /dispensers/{guid}/state   ``` {   \"$defs\": {     \"Time\": {       \"properties\": {         \"sec\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Sec\",           \"type\": \"integer\"         },         \"nanosec\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Nanosec\",           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ],       \"title\": \"Time\",       \"type\": \"object\"     }   },   \"properties\": {     \"time\": {       \"$ref\": \"#/$defs/Time\"     },     \"guid\": {       \"title\": \"Guid\",       \"type\": \"string\"     },     \"mode\": {       \"maximum\": 2147483647,       \"minimum\": -2147483648,       \"title\": \"Mode\",       \"type\": \"integer\"     },     \"request_guid_queue\": {       \"items\": {         \"type\": \"string\"       },       \"title\": \"Request Guid Queue\",       \"type\": \"array\"     },     \"seconds_remaining\": {       \"title\": \"Seconds Remaining\",       \"type\": \"number\"     }   },   \"required\": [     \"time\",     \"guid\",     \"mode\",     \"request_guid_queue\",     \"seconds_remaining\"   ],   \"title\": \"DispenserState\",   \"type\": \"object\" } ```   ### /ingestors/{guid}/state   ``` {   \"$defs\": {     \"Time\": {       \"properties\": {         \"sec\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Sec\",           \"type\": \"integer\"         },         \"nanosec\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Nanosec\",           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ],       \"title\": \"Time\",       \"type\": \"object\"     }   },   \"properties\": {     \"time\": {       \"$ref\": \"#/$defs/Time\"     },     \"guid\": {       \"title\": \"Guid\",       \"type\": \"string\"     },     \"mode\": {       \"maximum\": 2147483647,       \"minimum\": -2147483648,       \"title\": \"Mode\",       \"type\": \"integer\"     },     \"request_guid_queue\": {       \"items\": {         \"type\": \"string\"       },       \"title\": \"Request Guid Queue\",       \"type\": \"array\"     },     \"seconds_remaining\": {       \"title\": \"Seconds Remaining\",       \"type\": \"number\"     }   },   \"required\": [     \"time\",     \"guid\",     \"mode\",     \"request_guid_queue\",     \"seconds_remaining\"   ],   \"title\": \"IngestorState\",   \"type\": \"object\" } ```   ### /fleets/{name}/state   ``` {   \"$defs\": {     \"Commission\": {       \"properties\": {         \"dispatch_tasks\": {           \"anyOf\": [             {               \"type\": \"boolean\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Should the robot accept dispatched tasks, true/false. When used in a request, leave this unset to not change the robot\'s current value.\",           \"title\": \"Dispatch Tasks\"         },         \"direct_tasks\": {           \"anyOf\": [             {               \"type\": \"boolean\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Should the robot accept direct task requests, true/false. When used in a request, leave this unset to not change the robot\'s current value.\",           \"title\": \"Direct Tasks\"         },         \"idle_behavior\": {           \"anyOf\": [             {               \"type\": \"boolean\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Should the robot perform its idle behavior, true/false. When used in a request, leave this unset to not change the robot\'s current value.\",           \"title\": \"Idle Behavior\"         }       },       \"title\": \"Commission\",       \"type\": \"object\"     },     \"Issue\": {       \"properties\": {         \"category\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Category of the robot\'s issue\",           \"title\": \"Category\"         },         \"detail\": {           \"anyOf\": [             {               \"type\": \"object\"             },             {               \"items\": {},               \"type\": \"array\"             },             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Detailed information about the issue\",           \"title\": \"Detail\"         }       },       \"title\": \"Issue\",       \"type\": \"object\"     },     \"Location2D\": {       \"properties\": {         \"map\": {           \"title\": \"Map\",           \"type\": \"string\"         },         \"x\": {           \"title\": \"X\",           \"type\": \"number\"         },         \"y\": {           \"title\": \"Y\",           \"type\": \"number\"         },         \"yaw\": {           \"title\": \"Yaw\",           \"type\": \"number\"         }       },       \"required\": [         \"map\",         \"x\",         \"y\",         \"yaw\"       ],       \"title\": \"Location2D\",       \"type\": \"object\"     },     \"MutexGroups\": {       \"properties\": {         \"locked\": {           \"anyOf\": [             {               \"items\": {                 \"type\": \"string\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A list of mutex groups that this robot has currently locked\",           \"title\": \"Locked\"         },         \"requesting\": {           \"anyOf\": [             {               \"items\": {                 \"type\": \"string\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A list of the mutex groups that this robot is currently requesting but has not lockd yet\",           \"title\": \"Requesting\"         }       },       \"title\": \"MutexGroups\",       \"type\": \"object\"     },     \"RobotState\": {       \"properties\": {         \"name\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Name\"         },         \"status\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Status\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A simple token representing the status of the robot\"         },         \"task_id\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"The ID of the task this robot is currently working on. Empty string if the robot is not working on a task.\",           \"title\": \"Task Id\"         },         \"unix_millis_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Unix Millis Time\"         },         \"location\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Location2D\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"battery\": {           \"anyOf\": [             {               \"maximum\": 1.0,               \"minimum\": 0.0,               \"type\": \"number\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"State of charge of the battery. Values range from 0.0 (depleted) to 1.0 (fully charged)\",           \"title\": \"Battery\"         },         \"issues\": {           \"anyOf\": [             {               \"items\": {                 \"$ref\": \"#/$defs/Issue\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A list of issues with the robot that operators need to address\",           \"title\": \"Issues\"         },         \"commission\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Commission\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"mutex_groups\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/MutexGroups\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Information about the mutex groups that this robot is interacting with\"         }       },       \"title\": \"RobotState\",       \"type\": \"object\"     },     \"Status\": {       \"enum\": [         \"uninitialized\",         \"offline\",         \"shutdown\",         \"idle\",         \"charging\",         \"working\",         \"error\"       ],       \"title\": \"Status\",       \"type\": \"string\"     }   },   \"properties\": {     \"name\": {       \"anyOf\": [         {           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"title\": \"Name\"     },     \"robots\": {       \"anyOf\": [         {           \"additionalProperties\": {             \"$ref\": \"#/$defs/RobotState\"           },           \"type\": \"object\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"A dictionary of the states of the robots that belong to this fleet\",       \"title\": \"Robots\"     }   },   \"title\": \"FleetState\",   \"type\": \"object\" } ```   ### /fleets/{name}/log   ``` {   \"$defs\": {     \"LogEntry\": {       \"properties\": {         \"seq\": {           \"description\": \"Sequence number for this entry. Each entry has a unique sequence number which monotonically increase, until integer overflow causes a wrap around.\",           \"exclusiveMaximum\": 4294967296,           \"minimum\": 0,           \"title\": \"Seq\",           \"type\": \"integer\"         },         \"tier\": {           \"allOf\": [             {               \"$ref\": \"#/$defs/Tier\"             }           ],           \"description\": \"The importance level of the log entry\"         },         \"unix_millis_time\": {           \"title\": \"Unix Millis Time\",           \"type\": \"integer\"         },         \"text\": {           \"description\": \"The text of the log entry\",           \"title\": \"Text\",           \"type\": \"string\"         }       },       \"required\": [         \"seq\",         \"tier\",         \"unix_millis_time\",         \"text\"       ],       \"title\": \"LogEntry\",       \"type\": \"object\"     },     \"Tier\": {       \"enum\": [         \"uninitialized\",         \"info\",         \"warning\",         \"error\"       ],       \"title\": \"Tier\",       \"type\": \"string\"     }   },   \"properties\": {     \"name\": {       \"anyOf\": [         {           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"title\": \"Name\"     },     \"log\": {       \"anyOf\": [         {           \"items\": {             \"$ref\": \"#/$defs/LogEntry\"           },           \"type\": \"array\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"Log for the overall fleet\",       \"title\": \"Log\"     },     \"robots\": {       \"anyOf\": [         {           \"additionalProperties\": {             \"items\": {               \"$ref\": \"#/$defs/LogEntry\"             },             \"type\": \"array\"           },           \"type\": \"object\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"Dictionary of logs for the individual robots. The keys (property names) are the robot names.\",       \"title\": \"Robots\"     }   },   \"title\": \"FleetLog\",   \"type\": \"object\" } ```   ### /rios   ``` {   \"properties\": {     \"id\": {       \"title\": \"Id\",       \"type\": \"string\"     },     \"type\": {       \"title\": \"Type\",       \"type\": \"string\"     },     \"data\": {       \"title\": \"Data\",       \"type\": \"object\"     }   },   \"required\": [     \"id\",     \"type\",     \"data\"   ],   \"title\": \"Rio\",   \"type\": \"object\" } ```
     * @summary Socket.io endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async lambdaSocketIoGet(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.lambdaSocketIoGet(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.lambdaSocketIoGet']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DefaultApiFp(configuration);
  return {
    /**
     * Get the effective permissions of the current user
     * @summary Get Effective Permissions
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEffectivePermissionsPermissionsGet(
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<Array<Permission>> {
      return localVarFp
        .getEffectivePermissionsPermissionsGet(authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get the current rmf time in unix milliseconds
     * @summary Get Time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTimeTimeGet(options?: any): AxiosPromise<number> {
      return localVarFp.getTimeTimeGet(options).then((request) => request(axios, basePath));
    },
    /**
     * Get the currently logged in user
     * @summary Get User
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserUserGet(authorization?: string | null, options?: any): AxiosPromise<User> {
      return localVarFp
        .getUserUserGet(authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * # NOTE: This endpoint is here for documentation purposes only, this is _not_ a REST endpoint.  ## About This exposes a minimal pubsub system built on top of socket.io. It works similar to a normal socket.io endpoint, except that are 2 special rooms which control subscriptions.  ## Rooms ### subscribe Clients must send a message to this room to start receiving messages on other rooms. The message must be of the form:  ``` {     \"room\": \"<room_name>\" } ```  ### unsubscribe Clients can send a message to this room to stop receiving messages on other rooms. The message must be of the form:  ``` {     \"room\": \"<room_name>\" } ``` ### /alerts/requests   ``` {   \"$defs\": {     \"AlertParameter\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"value\": {           \"title\": \"Value\",           \"type\": \"string\"         }       },       \"required\": [         \"name\",         \"value\"       ],       \"title\": \"AlertParameter\",       \"type\": \"object\"     },     \"Tier\": {       \"enum\": [         \"info\",         \"warning\",         \"error\"       ],       \"title\": \"Tier\",       \"type\": \"string\"     }   },   \"properties\": {     \"id\": {       \"title\": \"Id\",       \"type\": \"string\"     },     \"unix_millis_alert_time\": {       \"title\": \"Unix Millis Alert Time\",       \"type\": \"integer\"     },     \"title\": {       \"title\": \"Title\",       \"type\": \"string\"     },     \"subtitle\": {       \"title\": \"Subtitle\",       \"type\": \"string\"     },     \"message\": {       \"title\": \"Message\",       \"type\": \"string\"     },     \"display\": {       \"title\": \"Display\",       \"type\": \"boolean\"     },     \"tier\": {       \"$ref\": \"#/$defs/Tier\"     },     \"responses_available\": {       \"items\": {         \"type\": \"string\"       },       \"title\": \"Responses Available\",       \"type\": \"array\"     },     \"alert_parameters\": {       \"items\": {         \"$ref\": \"#/$defs/AlertParameter\"       },       \"title\": \"Alert Parameters\",       \"type\": \"array\"     },     \"task_id\": {       \"anyOf\": [         {           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"title\": \"Task Id\"     }   },   \"required\": [     \"id\",     \"unix_millis_alert_time\",     \"title\",     \"subtitle\",     \"message\",     \"display\",     \"tier\",     \"responses_available\",     \"alert_parameters\",     \"task_id\"   ],   \"title\": \"AlertRequest\",   \"type\": \"object\" } ```   ### /alerts/responses   ``` {   \"properties\": {     \"id\": {       \"title\": \"Id\",       \"type\": \"string\"     },     \"unix_millis_response_time\": {       \"title\": \"Unix Millis Response Time\",       \"type\": \"integer\"     },     \"response\": {       \"title\": \"Response\",       \"type\": \"string\"     }   },   \"required\": [     \"id\",     \"unix_millis_response_time\",     \"response\"   ],   \"title\": \"AlertResponse\",   \"type\": \"object\" } ```   ### /beacons   ``` {   \"properties\": {     \"id\": {       \"title\": \"Id\",       \"type\": \"string\"     },     \"online\": {       \"title\": \"Online\",       \"type\": \"boolean\"     },     \"category\": {       \"title\": \"Category\",       \"type\": \"string\"     },     \"activated\": {       \"title\": \"Activated\",       \"type\": \"boolean\"     },     \"level\": {       \"title\": \"Level\",       \"type\": \"string\"     }   },   \"required\": [     \"id\",     \"online\",     \"category\",     \"activated\",     \"level\"   ],   \"title\": \"BeaconState\",   \"type\": \"object\" } ```   ### /building_map   ``` {   \"$defs\": {     \"AffineImage\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"x_offset\": {           \"title\": \"X Offset\",           \"type\": \"number\"         },         \"y_offset\": {           \"title\": \"Y Offset\",           \"type\": \"number\"         },         \"yaw\": {           \"title\": \"Yaw\",           \"type\": \"number\"         },         \"scale\": {           \"title\": \"Scale\",           \"type\": \"number\"         },         \"encoding\": {           \"title\": \"Encoding\",           \"type\": \"string\"         },         \"data\": {           \"title\": \"Data\",           \"type\": \"string\"         }       },       \"required\": [         \"name\",         \"x_offset\",         \"y_offset\",         \"yaw\",         \"scale\",         \"encoding\",         \"data\"       ],       \"title\": \"AffineImage\",       \"type\": \"object\"     },     \"Door\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"v1_x\": {           \"title\": \"V1 X\",           \"type\": \"number\"         },         \"v1_y\": {           \"title\": \"V1 Y\",           \"type\": \"number\"         },         \"v2_x\": {           \"title\": \"V2 X\",           \"type\": \"number\"         },         \"v2_y\": {           \"title\": \"V2 Y\",           \"type\": \"number\"         },         \"door_type\": {           \"maximum\": 255,           \"minimum\": 0,           \"title\": \"Door Type\",           \"type\": \"integer\"         },         \"motion_range\": {           \"title\": \"Motion Range\",           \"type\": \"number\"         },         \"motion_direction\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Motion Direction\",           \"type\": \"integer\"         }       },       \"required\": [         \"name\",         \"v1_x\",         \"v1_y\",         \"v2_x\",         \"v2_y\",         \"door_type\",         \"motion_range\",         \"motion_direction\"       ],       \"title\": \"Door\",       \"type\": \"object\"     },     \"Graph\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"vertices\": {           \"items\": {             \"$ref\": \"#/$defs/GraphNode\"           },           \"title\": \"Vertices\",           \"type\": \"array\"         },         \"edges\": {           \"items\": {             \"$ref\": \"#/$defs/GraphEdge\"           },           \"title\": \"Edges\",           \"type\": \"array\"         },         \"params\": {           \"items\": {             \"$ref\": \"#/$defs/Param\"           },           \"title\": \"Params\",           \"type\": \"array\"         }       },       \"required\": [         \"name\",         \"vertices\",         \"edges\",         \"params\"       ],       \"title\": \"Graph\",       \"type\": \"object\"     },     \"GraphEdge\": {       \"properties\": {         \"v1_idx\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"V1 Idx\",           \"type\": \"integer\"         },         \"v2_idx\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"V2 Idx\",           \"type\": \"integer\"         },         \"params\": {           \"items\": {             \"$ref\": \"#/$defs/Param\"           },           \"title\": \"Params\",           \"type\": \"array\"         },         \"edge_type\": {           \"maximum\": 255,           \"minimum\": 0,           \"title\": \"Edge Type\",           \"type\": \"integer\"         }       },       \"required\": [         \"v1_idx\",         \"v2_idx\",         \"params\",         \"edge_type\"       ],       \"title\": \"GraphEdge\",       \"type\": \"object\"     },     \"GraphNode\": {       \"properties\": {         \"x\": {           \"title\": \"X\",           \"type\": \"number\"         },         \"y\": {           \"title\": \"Y\",           \"type\": \"number\"         },         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"params\": {           \"items\": {             \"$ref\": \"#/$defs/Param\"           },           \"title\": \"Params\",           \"type\": \"array\"         }       },       \"required\": [         \"x\",         \"y\",         \"name\",         \"params\"       ],       \"title\": \"GraphNode\",       \"type\": \"object\"     },     \"Level\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"elevation\": {           \"title\": \"Elevation\",           \"type\": \"number\"         },         \"images\": {           \"items\": {             \"$ref\": \"#/$defs/AffineImage\"           },           \"title\": \"Images\",           \"type\": \"array\"         },         \"places\": {           \"items\": {             \"$ref\": \"#/$defs/Place\"           },           \"title\": \"Places\",           \"type\": \"array\"         },         \"doors\": {           \"items\": {             \"$ref\": \"#/$defs/Door\"           },           \"title\": \"Doors\",           \"type\": \"array\"         },         \"nav_graphs\": {           \"items\": {             \"$ref\": \"#/$defs/Graph\"           },           \"title\": \"Nav Graphs\",           \"type\": \"array\"         },         \"wall_graph\": {           \"$ref\": \"#/$defs/Graph\"         }       },       \"required\": [         \"name\",         \"elevation\",         \"images\",         \"places\",         \"doors\",         \"nav_graphs\",         \"wall_graph\"       ],       \"title\": \"Level\",       \"type\": \"object\"     },     \"Lift\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"levels\": {           \"items\": {             \"type\": \"string\"           },           \"title\": \"Levels\",           \"type\": \"array\"         },         \"doors\": {           \"items\": {             \"$ref\": \"#/$defs/Door\"           },           \"title\": \"Doors\",           \"type\": \"array\"         },         \"wall_graph\": {           \"$ref\": \"#/$defs/Graph\"         },         \"ref_x\": {           \"title\": \"Ref X\",           \"type\": \"number\"         },         \"ref_y\": {           \"title\": \"Ref Y\",           \"type\": \"number\"         },         \"ref_yaw\": {           \"title\": \"Ref Yaw\",           \"type\": \"number\"         },         \"width\": {           \"title\": \"Width\",           \"type\": \"number\"         },         \"depth\": {           \"title\": \"Depth\",           \"type\": \"number\"         }       },       \"required\": [         \"name\",         \"levels\",         \"doors\",         \"wall_graph\",         \"ref_x\",         \"ref_y\",         \"ref_yaw\",         \"width\",         \"depth\"       ],       \"title\": \"Lift\",       \"type\": \"object\"     },     \"Param\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"type\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Type\",           \"type\": \"integer\"         },         \"value_int\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Value Int\",           \"type\": \"integer\"         },         \"value_float\": {           \"title\": \"Value Float\",           \"type\": \"number\"         },         \"value_string\": {           \"title\": \"Value String\",           \"type\": \"string\"         },         \"value_bool\": {           \"title\": \"Value Bool\",           \"type\": \"boolean\"         }       },       \"required\": [         \"name\",         \"type\",         \"value_int\",         \"value_float\",         \"value_string\",         \"value_bool\"       ],       \"title\": \"Param\",       \"type\": \"object\"     },     \"Place\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"x\": {           \"title\": \"X\",           \"type\": \"number\"         },         \"y\": {           \"title\": \"Y\",           \"type\": \"number\"         },         \"yaw\": {           \"title\": \"Yaw\",           \"type\": \"number\"         },         \"position_tolerance\": {           \"title\": \"Position Tolerance\",           \"type\": \"number\"         },         \"yaw_tolerance\": {           \"title\": \"Yaw Tolerance\",           \"type\": \"number\"         }       },       \"required\": [         \"name\",         \"x\",         \"y\",         \"yaw\",         \"position_tolerance\",         \"yaw_tolerance\"       ],       \"title\": \"Place\",       \"type\": \"object\"     }   },   \"properties\": {     \"name\": {       \"title\": \"Name\",       \"type\": \"string\"     },     \"levels\": {       \"items\": {         \"$ref\": \"#/$defs/Level\"       },       \"title\": \"Levels\",       \"type\": \"array\"     },     \"lifts\": {       \"items\": {         \"$ref\": \"#/$defs/Lift\"       },       \"title\": \"Lifts\",       \"type\": \"array\"     }   },   \"required\": [     \"name\",     \"levels\",     \"lifts\"   ],   \"title\": \"BuildingMap\",   \"type\": \"object\" } ```   ### /building_map/fire_alarm_trigger   ``` {   \"properties\": {     \"unix_millis_time\": {       \"title\": \"Unix Millis Time\",       \"type\": \"integer\"     },     \"trigger\": {       \"title\": \"Trigger\",       \"type\": \"boolean\"     }   },   \"required\": [     \"unix_millis_time\",     \"trigger\"   ],   \"title\": \"FireAlarmTriggerState\",   \"type\": \"object\" } ```   ### /delivery_alerts   ``` {   \"$defs\": {     \"Action\": {       \"enum\": [         \"waiting\",         \"cancel\",         \"override\",         \"resume\"       ],       \"title\": \"Action\",       \"type\": \"string\"     },     \"Category\": {       \"enum\": [         \"missing\",         \"wrong\",         \"obstructed\",         \"cancelled\"       ],       \"title\": \"Category\",       \"type\": \"string\"     },     \"Tier\": {       \"enum\": [         \"warning\",         \"error\"       ],       \"title\": \"Tier\",       \"type\": \"string\"     }   },   \"properties\": {     \"id\": {       \"title\": \"Id\",       \"type\": \"string\"     },     \"category\": {       \"$ref\": \"#/$defs/Category\"     },     \"tier\": {       \"$ref\": \"#/$defs/Tier\"     },     \"action\": {       \"$ref\": \"#/$defs/Action\"     },     \"task_id\": {       \"title\": \"Task Id\",       \"type\": \"string\"     },     \"message\": {       \"title\": \"Message\",       \"type\": \"string\"     }   },   \"required\": [     \"id\",     \"category\",     \"tier\",     \"action\",     \"task_id\",     \"message\"   ],   \"title\": \"DeliveryAlert\",   \"type\": \"object\" } ```   ### /doors/{door_name}/state   ``` {   \"$defs\": {     \"DoorMode\": {       \"properties\": {         \"value\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Value\",           \"type\": \"integer\"         }       },       \"required\": [         \"value\"       ],       \"title\": \"DoorMode\",       \"type\": \"object\"     },     \"Time\": {       \"properties\": {         \"sec\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Sec\",           \"type\": \"integer\"         },         \"nanosec\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Nanosec\",           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ],       \"title\": \"Time\",       \"type\": \"object\"     }   },   \"properties\": {     \"door_time\": {       \"$ref\": \"#/$defs/Time\"     },     \"door_name\": {       \"title\": \"Door Name\",       \"type\": \"string\"     },     \"current_mode\": {       \"$ref\": \"#/$defs/DoorMode\"     }   },   \"required\": [     \"door_time\",     \"door_name\",     \"current_mode\"   ],   \"title\": \"DoorState\",   \"type\": \"object\" } ```   ### /lifts/{lift_name}/state   ``` {   \"$defs\": {     \"Time\": {       \"properties\": {         \"sec\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Sec\",           \"type\": \"integer\"         },         \"nanosec\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Nanosec\",           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ],       \"title\": \"Time\",       \"type\": \"object\"     }   },   \"properties\": {     \"lift_time\": {       \"$ref\": \"#/$defs/Time\"     },     \"lift_name\": {       \"title\": \"Lift Name\",       \"type\": \"string\"     },     \"available_floors\": {       \"items\": {         \"type\": \"string\"       },       \"title\": \"Available Floors\",       \"type\": \"array\"     },     \"current_floor\": {       \"title\": \"Current Floor\",       \"type\": \"string\"     },     \"destination_floor\": {       \"title\": \"Destination Floor\",       \"type\": \"string\"     },     \"door_state\": {       \"maximum\": 255,       \"minimum\": 0,       \"title\": \"Door State\",       \"type\": \"integer\"     },     \"motion_state\": {       \"maximum\": 255,       \"minimum\": 0,       \"title\": \"Motion State\",       \"type\": \"integer\"     },     \"available_modes\": {       \"items\": {         \"type\": \"integer\"       },       \"title\": \"Available Modes\",       \"type\": \"array\"     },     \"current_mode\": {       \"maximum\": 255,       \"minimum\": 0,       \"title\": \"Current Mode\",       \"type\": \"integer\"     },     \"session_id\": {       \"title\": \"Session Id\",       \"type\": \"string\"     }   },   \"required\": [     \"lift_time\",     \"lift_name\",     \"available_floors\",     \"current_floor\",     \"destination_floor\",     \"door_state\",     \"motion_state\",     \"available_modes\",     \"current_mode\",     \"session_id\"   ],   \"title\": \"LiftState\",   \"type\": \"object\" } ```   ### /tasks/{task_id}/state   ``` {   \"$defs\": {     \"AssignedTo\": {       \"properties\": {         \"group\": {           \"title\": \"Group\",           \"type\": \"string\"         },         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         }       },       \"required\": [         \"group\",         \"name\"       ],       \"title\": \"AssignedTo\",       \"type\": \"object\"     },     \"Assignment\": {       \"properties\": {         \"fleet_name\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Fleet Name\"         },         \"expected_robot_name\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Expected Robot Name\"         }       },       \"title\": \"Assignment\",       \"type\": \"object\"     },     \"Booking\": {       \"properties\": {         \"id\": {           \"description\": \"The unique identifier for this task\",           \"title\": \"Id\",           \"type\": \"string\"         },         \"unix_millis_earliest_start_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Unix Millis Earliest Start Time\"         },         \"unix_millis_request_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Unix Millis Request Time\"         },         \"priority\": {           \"anyOf\": [             {               \"type\": \"object\"             },             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Priority information about this task\",           \"title\": \"Priority\"         },         \"labels\": {           \"anyOf\": [             {               \"items\": {                 \"type\": \"string\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Information about how and why this task was booked, items can be a single value like `dashboard` or a key-value pair like `app=dashboard`, in the case of a single value, it will be interpreted as a key-value pair with an empty string value.\",           \"title\": \"Labels\"         },         \"requester\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"(Optional) An identifier for the entity that requested this task\",           \"title\": \"Requester\"         }       },       \"required\": [         \"id\"       ],       \"title\": \"Booking\",       \"type\": \"object\"     },     \"Cancellation\": {       \"properties\": {         \"unix_millis_request_time\": {           \"description\": \"The time that the cancellation request arrived\",           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"labels\": {           \"description\": \"Labels to describe the cancel request, items can be a single value like `dashboard` or a key-value pair like `app=dashboard`, in the case of a single value, it will be interpreted as a key-value pair with an empty string value.\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ],       \"title\": \"Cancellation\",       \"type\": \"object\"     },     \"Category\": {       \"description\": \"The category of this task or phase\",       \"title\": \"Category\",       \"type\": \"string\"     },     \"Detail\": {       \"anyOf\": [         {           \"type\": \"object\"         },         {           \"items\": {},           \"type\": \"array\"         },         {           \"type\": \"string\"         }       ],       \"description\": \"Detailed information about a task, phase, or event\",       \"title\": \"Detail\"     },     \"Dispatch\": {       \"properties\": {         \"status\": {           \"$ref\": \"#/$defs/Status2\"         },         \"assignment\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Assignment\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"errors\": {           \"anyOf\": [             {               \"items\": {                 \"$ref\": \"#/$defs/Error\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Errors\"         }       },       \"required\": [         \"status\"       ],       \"title\": \"Dispatch\",       \"type\": \"object\"     },     \"Error\": {       \"properties\": {         \"code\": {           \"anyOf\": [             {               \"minimum\": 0,               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A standard code for the kind of error that has occurred\",           \"title\": \"Code\"         },         \"category\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"The category of the error\",           \"title\": \"Category\"         },         \"detail\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Details about the error\",           \"title\": \"Detail\"         }       },       \"title\": \"Error\",       \"type\": \"object\"     },     \"EstimateMillis\": {       \"description\": \"An estimate, in milliseconds, of how long the subject will take to complete\",       \"minimum\": 0,       \"title\": \"EstimateMillis\",       \"type\": \"integer\"     },     \"EventState\": {       \"properties\": {         \"id\": {           \"$ref\": \"#/$defs/Id\"         },         \"status\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Status\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"name\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"The brief name of the event\",           \"title\": \"Name\"         },         \"detail\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Detail\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Detailed information about the event\"         },         \"deps\": {           \"anyOf\": [             {               \"items\": {                 \"minimum\": 0,                 \"type\": \"integer\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"This event may depend on other events. This array contains the IDs of those other event dependencies.\",           \"title\": \"Deps\"         }       },       \"required\": [         \"id\"       ],       \"title\": \"EventState\",       \"type\": \"object\"     },     \"Id\": {       \"minimum\": 0,       \"title\": \"Id\",       \"type\": \"integer\"     },     \"Interruption\": {       \"properties\": {         \"unix_millis_request_time\": {           \"description\": \"The time that the interruption request arrived\",           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"labels\": {           \"description\": \"Labels to describe the purpose of the interruption, items can be a single value like `dashboard` or a key-value pair like `app=dashboard`, in the case of a single value, it will be interpreted as a key-value pair with an empty string value.\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         },         \"resumed_by\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/ResumedBy\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Information about the resume request that ended this interruption. This field will be missing if the interruption is still active.\"         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ],       \"title\": \"Interruption\",       \"type\": \"object\"     },     \"Killed\": {       \"properties\": {         \"unix_millis_request_time\": {           \"description\": \"The time that the cancellation request arrived\",           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"labels\": {           \"description\": \"Labels to describe the kill request, items can be a single value like `dashboard` or a key-value pair like `app=dashboard`, in the case of a single value, it will be interpreted as a key-value pair with an empty string value.\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ],       \"title\": \"Killed\",       \"type\": \"object\"     },     \"Phase\": {       \"properties\": {         \"id\": {           \"$ref\": \"#/$defs/Id\"         },         \"category\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Category\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"detail\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Detail\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"unix_millis_start_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Unix Millis Start Time\"         },         \"unix_millis_finish_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Unix Millis Finish Time\"         },         \"original_estimate_millis\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/EstimateMillis\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"estimate_millis\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/EstimateMillis\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"final_event_id\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Id\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"events\": {           \"anyOf\": [             {               \"additionalProperties\": {                 \"$ref\": \"#/$defs/EventState\"               },               \"type\": \"object\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A dictionary of events for this phase. The keys (property names) are the event IDs, which are integers.\",           \"title\": \"Events\"         },         \"skip_requests\": {           \"anyOf\": [             {               \"additionalProperties\": {                 \"$ref\": \"#/$defs/SkipPhaseRequest\"               },               \"type\": \"object\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Information about any skip requests that have been received\",           \"title\": \"Skip Requests\"         }       },       \"required\": [         \"id\"       ],       \"title\": \"Phase\",       \"type\": \"object\"     },     \"ResumedBy\": {       \"properties\": {         \"unix_millis_request_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"The time that the resume request arrived\",           \"title\": \"Unix Millis Request Time\"         },         \"labels\": {           \"description\": \"Labels to describe the resume request, items can be a single value like `dashboard` or a key-value pair like `app=dashboard`, in the case of a single value, it will be interpreted as a key-value pair with an empty string value.\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         }       },       \"required\": [         \"labels\"       ],       \"title\": \"ResumedBy\",       \"type\": \"object\"     },     \"SkipPhaseRequest\": {       \"properties\": {         \"unix_millis_request_time\": {           \"description\": \"The time that the skip request arrived\",           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"labels\": {           \"description\": \"Labels to describe the purpose of the skip request, items can be a single value like `dashboard` or a key-value pair like `app=dashboard`, in the case of a single value, it will be interpreted as a key-value pair with an empty string value.\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         },         \"undo\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Undo\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Information about an undo skip request that applied to this request\"         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ],       \"title\": \"SkipPhaseRequest\",       \"type\": \"object\"     },     \"Status\": {       \"enum\": [         \"uninitialized\",         \"blocked\",         \"error\",         \"failed\",         \"queued\",         \"standby\",         \"underway\",         \"delayed\",         \"skipped\",         \"canceled\",         \"killed\",         \"completed\"       ],       \"title\": \"Status\",       \"type\": \"string\"     },     \"Status2\": {       \"enum\": [         \"queued\",         \"selected\",         \"dispatched\",         \"failed_to_assign\",         \"canceled_in_flight\"       ],       \"title\": \"Status2\",       \"type\": \"string\"     },     \"Undo\": {       \"properties\": {         \"unix_millis_request_time\": {           \"description\": \"The time that the undo skip request arrived\",           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"labels\": {           \"description\": \"Labels to describe the undo skip request, items can be a single value like `dashboard` or a key-value pair like `app=dashboard`, in the case of a single value, it will be interpreted as a key-value pair with an empty string value.\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ],       \"title\": \"Undo\",       \"type\": \"object\"     }   },   \"properties\": {     \"booking\": {       \"$ref\": \"#/$defs/Booking\"     },     \"category\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Category\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"detail\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Detail\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"unix_millis_start_time\": {       \"anyOf\": [         {           \"type\": \"integer\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"title\": \"Unix Millis Start Time\"     },     \"unix_millis_finish_time\": {       \"anyOf\": [         {           \"type\": \"integer\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"title\": \"Unix Millis Finish Time\"     },     \"original_estimate_millis\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/EstimateMillis\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"estimate_millis\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/EstimateMillis\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"assigned_to\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/AssignedTo\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"Which agent (robot) is the task assigned to\"     },     \"status\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Status\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"dispatch\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Dispatch\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"phases\": {       \"anyOf\": [         {           \"additionalProperties\": {             \"$ref\": \"#/$defs/Phase\"           },           \"type\": \"object\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"A dictionary of the states of the phases of the task. The keys (property names) are phase IDs, which are integers.\",       \"title\": \"Phases\"     },     \"completed\": {       \"anyOf\": [         {           \"items\": {             \"$ref\": \"#/$defs/Id\"           },           \"type\": \"array\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"An array of the IDs of completed phases of this task\",       \"title\": \"Completed\"     },     \"active\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Id\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"The ID of the active phase for this task\"     },     \"pending\": {       \"anyOf\": [         {           \"items\": {             \"$ref\": \"#/$defs/Id\"           },           \"type\": \"array\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"An array of the pending phases of this task\",       \"title\": \"Pending\"     },     \"interruptions\": {       \"anyOf\": [         {           \"additionalProperties\": {             \"$ref\": \"#/$defs/Interruption\"           },           \"type\": \"object\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"A dictionary of interruptions that have been applied to this task. The keys (property names) are the unique token of the interruption request.\",       \"title\": \"Interruptions\"     },     \"cancellation\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Cancellation\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"If the task was cancelled, this will describe information about the request.\"     },     \"killed\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Killed\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"If the task was killed, this will describe information about the request.\"     }   },   \"required\": [     \"booking\"   ],   \"title\": \"TaskState\",   \"type\": \"object\" } ```   ### /tasks/{task_id}/log   ``` {   \"$defs\": {     \"LogEntry\": {       \"properties\": {         \"seq\": {           \"description\": \"Sequence number for this entry. Each entry has a unique sequence number which monotonically increase, until integer overflow causes a wrap around.\",           \"exclusiveMaximum\": 4294967296,           \"minimum\": 0,           \"title\": \"Seq\",           \"type\": \"integer\"         },         \"tier\": {           \"allOf\": [             {               \"$ref\": \"#/$defs/Tier\"             }           ],           \"description\": \"The importance level of the log entry\"         },         \"unix_millis_time\": {           \"title\": \"Unix Millis Time\",           \"type\": \"integer\"         },         \"text\": {           \"description\": \"The text of the log entry\",           \"title\": \"Text\",           \"type\": \"string\"         }       },       \"required\": [         \"seq\",         \"tier\",         \"unix_millis_time\",         \"text\"       ],       \"title\": \"LogEntry\",       \"type\": \"object\"     },     \"Phases\": {       \"additionalProperties\": false,       \"properties\": {         \"log\": {           \"anyOf\": [             {               \"items\": {                 \"$ref\": \"#/$defs/LogEntry\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Log entries related to the overall phase\",           \"title\": \"Log\"         },         \"events\": {           \"anyOf\": [             {               \"additionalProperties\": {                 \"items\": {                   \"$ref\": \"#/$defs/LogEntry\"                 },                 \"type\": \"array\"               },               \"type\": \"object\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A dictionary whose keys (property names) are the indices of an event in the phase\",           \"title\": \"Events\"         }       },       \"title\": \"Phases\",       \"type\": \"object\"     },     \"Tier\": {       \"enum\": [         \"uninitialized\",         \"info\",         \"warning\",         \"error\"       ],       \"title\": \"Tier\",       \"type\": \"string\"     }   },   \"additionalProperties\": false,   \"properties\": {     \"task_id\": {       \"title\": \"Task Id\",       \"type\": \"string\"     },     \"log\": {       \"anyOf\": [         {           \"items\": {             \"$ref\": \"#/$defs/LogEntry\"           },           \"type\": \"array\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"Log entries related to the overall task\",       \"title\": \"Log\"     },     \"phases\": {       \"anyOf\": [         {           \"additionalProperties\": {             \"$ref\": \"#/$defs/Phases\"           },           \"type\": \"object\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"A dictionary whose keys (property names) are the indices of a phase\",       \"title\": \"Phases\"     }   },   \"required\": [     \"task_id\"   ],   \"title\": \"TaskEventLog\",   \"type\": \"object\" } ```   ### /dispensers/{guid}/state   ``` {   \"$defs\": {     \"Time\": {       \"properties\": {         \"sec\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Sec\",           \"type\": \"integer\"         },         \"nanosec\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Nanosec\",           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ],       \"title\": \"Time\",       \"type\": \"object\"     }   },   \"properties\": {     \"time\": {       \"$ref\": \"#/$defs/Time\"     },     \"guid\": {       \"title\": \"Guid\",       \"type\": \"string\"     },     \"mode\": {       \"maximum\": 2147483647,       \"minimum\": -2147483648,       \"title\": \"Mode\",       \"type\": \"integer\"     },     \"request_guid_queue\": {       \"items\": {         \"type\": \"string\"       },       \"title\": \"Request Guid Queue\",       \"type\": \"array\"     },     \"seconds_remaining\": {       \"title\": \"Seconds Remaining\",       \"type\": \"number\"     }   },   \"required\": [     \"time\",     \"guid\",     \"mode\",     \"request_guid_queue\",     \"seconds_remaining\"   ],   \"title\": \"DispenserState\",   \"type\": \"object\" } ```   ### /ingestors/{guid}/state   ``` {   \"$defs\": {     \"Time\": {       \"properties\": {         \"sec\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Sec\",           \"type\": \"integer\"         },         \"nanosec\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Nanosec\",           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ],       \"title\": \"Time\",       \"type\": \"object\"     }   },   \"properties\": {     \"time\": {       \"$ref\": \"#/$defs/Time\"     },     \"guid\": {       \"title\": \"Guid\",       \"type\": \"string\"     },     \"mode\": {       \"maximum\": 2147483647,       \"minimum\": -2147483648,       \"title\": \"Mode\",       \"type\": \"integer\"     },     \"request_guid_queue\": {       \"items\": {         \"type\": \"string\"       },       \"title\": \"Request Guid Queue\",       \"type\": \"array\"     },     \"seconds_remaining\": {       \"title\": \"Seconds Remaining\",       \"type\": \"number\"     }   },   \"required\": [     \"time\",     \"guid\",     \"mode\",     \"request_guid_queue\",     \"seconds_remaining\"   ],   \"title\": \"IngestorState\",   \"type\": \"object\" } ```   ### /fleets/{name}/state   ``` {   \"$defs\": {     \"Commission\": {       \"properties\": {         \"dispatch_tasks\": {           \"anyOf\": [             {               \"type\": \"boolean\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Should the robot accept dispatched tasks, true/false. When used in a request, leave this unset to not change the robot\'s current value.\",           \"title\": \"Dispatch Tasks\"         },         \"direct_tasks\": {           \"anyOf\": [             {               \"type\": \"boolean\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Should the robot accept direct task requests, true/false. When used in a request, leave this unset to not change the robot\'s current value.\",           \"title\": \"Direct Tasks\"         },         \"idle_behavior\": {           \"anyOf\": [             {               \"type\": \"boolean\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Should the robot perform its idle behavior, true/false. When used in a request, leave this unset to not change the robot\'s current value.\",           \"title\": \"Idle Behavior\"         }       },       \"title\": \"Commission\",       \"type\": \"object\"     },     \"Issue\": {       \"properties\": {         \"category\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Category of the robot\'s issue\",           \"title\": \"Category\"         },         \"detail\": {           \"anyOf\": [             {               \"type\": \"object\"             },             {               \"items\": {},               \"type\": \"array\"             },             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Detailed information about the issue\",           \"title\": \"Detail\"         }       },       \"title\": \"Issue\",       \"type\": \"object\"     },     \"Location2D\": {       \"properties\": {         \"map\": {           \"title\": \"Map\",           \"type\": \"string\"         },         \"x\": {           \"title\": \"X\",           \"type\": \"number\"         },         \"y\": {           \"title\": \"Y\",           \"type\": \"number\"         },         \"yaw\": {           \"title\": \"Yaw\",           \"type\": \"number\"         }       },       \"required\": [         \"map\",         \"x\",         \"y\",         \"yaw\"       ],       \"title\": \"Location2D\",       \"type\": \"object\"     },     \"MutexGroups\": {       \"properties\": {         \"locked\": {           \"anyOf\": [             {               \"items\": {                 \"type\": \"string\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A list of mutex groups that this robot has currently locked\",           \"title\": \"Locked\"         },         \"requesting\": {           \"anyOf\": [             {               \"items\": {                 \"type\": \"string\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A list of the mutex groups that this robot is currently requesting but has not lockd yet\",           \"title\": \"Requesting\"         }       },       \"title\": \"MutexGroups\",       \"type\": \"object\"     },     \"RobotState\": {       \"properties\": {         \"name\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Name\"         },         \"status\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Status\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A simple token representing the status of the robot\"         },         \"task_id\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"The ID of the task this robot is currently working on. Empty string if the robot is not working on a task.\",           \"title\": \"Task Id\"         },         \"unix_millis_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Unix Millis Time\"         },         \"location\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Location2D\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"battery\": {           \"anyOf\": [             {               \"maximum\": 1.0,               \"minimum\": 0.0,               \"type\": \"number\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"State of charge of the battery. Values range from 0.0 (depleted) to 1.0 (fully charged)\",           \"title\": \"Battery\"         },         \"issues\": {           \"anyOf\": [             {               \"items\": {                 \"$ref\": \"#/$defs/Issue\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A list of issues with the robot that operators need to address\",           \"title\": \"Issues\"         },         \"commission\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Commission\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"mutex_groups\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/MutexGroups\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Information about the mutex groups that this robot is interacting with\"         }       },       \"title\": \"RobotState\",       \"type\": \"object\"     },     \"Status\": {       \"enum\": [         \"uninitialized\",         \"offline\",         \"shutdown\",         \"idle\",         \"charging\",         \"working\",         \"error\"       ],       \"title\": \"Status\",       \"type\": \"string\"     }   },   \"properties\": {     \"name\": {       \"anyOf\": [         {           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"title\": \"Name\"     },     \"robots\": {       \"anyOf\": [         {           \"additionalProperties\": {             \"$ref\": \"#/$defs/RobotState\"           },           \"type\": \"object\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"A dictionary of the states of the robots that belong to this fleet\",       \"title\": \"Robots\"     }   },   \"title\": \"FleetState\",   \"type\": \"object\" } ```   ### /fleets/{name}/log   ``` {   \"$defs\": {     \"LogEntry\": {       \"properties\": {         \"seq\": {           \"description\": \"Sequence number for this entry. Each entry has a unique sequence number which monotonically increase, until integer overflow causes a wrap around.\",           \"exclusiveMaximum\": 4294967296,           \"minimum\": 0,           \"title\": \"Seq\",           \"type\": \"integer\"         },         \"tier\": {           \"allOf\": [             {               \"$ref\": \"#/$defs/Tier\"             }           ],           \"description\": \"The importance level of the log entry\"         },         \"unix_millis_time\": {           \"title\": \"Unix Millis Time\",           \"type\": \"integer\"         },         \"text\": {           \"description\": \"The text of the log entry\",           \"title\": \"Text\",           \"type\": \"string\"         }       },       \"required\": [         \"seq\",         \"tier\",         \"unix_millis_time\",         \"text\"       ],       \"title\": \"LogEntry\",       \"type\": \"object\"     },     \"Tier\": {       \"enum\": [         \"uninitialized\",         \"info\",         \"warning\",         \"error\"       ],       \"title\": \"Tier\",       \"type\": \"string\"     }   },   \"properties\": {     \"name\": {       \"anyOf\": [         {           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"title\": \"Name\"     },     \"log\": {       \"anyOf\": [         {           \"items\": {             \"$ref\": \"#/$defs/LogEntry\"           },           \"type\": \"array\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"Log for the overall fleet\",       \"title\": \"Log\"     },     \"robots\": {       \"anyOf\": [         {           \"additionalProperties\": {             \"items\": {               \"$ref\": \"#/$defs/LogEntry\"             },             \"type\": \"array\"           },           \"type\": \"object\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"Dictionary of logs for the individual robots. The keys (property names) are the robot names.\",       \"title\": \"Robots\"     }   },   \"title\": \"FleetLog\",   \"type\": \"object\" } ```   ### /rios   ``` {   \"properties\": {     \"id\": {       \"title\": \"Id\",       \"type\": \"string\"     },     \"type\": {       \"title\": \"Type\",       \"type\": \"string\"     },     \"data\": {       \"title\": \"Data\",       \"type\": \"object\"     }   },   \"required\": [     \"id\",     \"type\",     \"data\"   ],   \"title\": \"Rio\",   \"type\": \"object\" } ```
     * @summary Socket.io endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lambdaSocketIoGet(options?: any): AxiosPromise<any> {
      return localVarFp.lambdaSocketIoGet(options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   * Get the effective permissions of the current user
   * @summary Get Effective Permissions
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getEffectivePermissionsPermissionsGet(
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .getEffectivePermissionsPermissionsGet(authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get the current rmf time in unix milliseconds
   * @summary Get Time
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getTimeTimeGet(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getTimeTimeGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get the currently logged in user
   * @summary Get User
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getUserUserGet(authorization?: string | null, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getUserUserGet(authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * # NOTE: This endpoint is here for documentation purposes only, this is _not_ a REST endpoint.  ## About This exposes a minimal pubsub system built on top of socket.io. It works similar to a normal socket.io endpoint, except that are 2 special rooms which control subscriptions.  ## Rooms ### subscribe Clients must send a message to this room to start receiving messages on other rooms. The message must be of the form:  ``` {     \"room\": \"<room_name>\" } ```  ### unsubscribe Clients can send a message to this room to stop receiving messages on other rooms. The message must be of the form:  ``` {     \"room\": \"<room_name>\" } ``` ### /alerts/requests   ``` {   \"$defs\": {     \"AlertParameter\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"value\": {           \"title\": \"Value\",           \"type\": \"string\"         }       },       \"required\": [         \"name\",         \"value\"       ],       \"title\": \"AlertParameter\",       \"type\": \"object\"     },     \"Tier\": {       \"enum\": [         \"info\",         \"warning\",         \"error\"       ],       \"title\": \"Tier\",       \"type\": \"string\"     }   },   \"properties\": {     \"id\": {       \"title\": \"Id\",       \"type\": \"string\"     },     \"unix_millis_alert_time\": {       \"title\": \"Unix Millis Alert Time\",       \"type\": \"integer\"     },     \"title\": {       \"title\": \"Title\",       \"type\": \"string\"     },     \"subtitle\": {       \"title\": \"Subtitle\",       \"type\": \"string\"     },     \"message\": {       \"title\": \"Message\",       \"type\": \"string\"     },     \"display\": {       \"title\": \"Display\",       \"type\": \"boolean\"     },     \"tier\": {       \"$ref\": \"#/$defs/Tier\"     },     \"responses_available\": {       \"items\": {         \"type\": \"string\"       },       \"title\": \"Responses Available\",       \"type\": \"array\"     },     \"alert_parameters\": {       \"items\": {         \"$ref\": \"#/$defs/AlertParameter\"       },       \"title\": \"Alert Parameters\",       \"type\": \"array\"     },     \"task_id\": {       \"anyOf\": [         {           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"title\": \"Task Id\"     }   },   \"required\": [     \"id\",     \"unix_millis_alert_time\",     \"title\",     \"subtitle\",     \"message\",     \"display\",     \"tier\",     \"responses_available\",     \"alert_parameters\",     \"task_id\"   ],   \"title\": \"AlertRequest\",   \"type\": \"object\" } ```   ### /alerts/responses   ``` {   \"properties\": {     \"id\": {       \"title\": \"Id\",       \"type\": \"string\"     },     \"unix_millis_response_time\": {       \"title\": \"Unix Millis Response Time\",       \"type\": \"integer\"     },     \"response\": {       \"title\": \"Response\",       \"type\": \"string\"     }   },   \"required\": [     \"id\",     \"unix_millis_response_time\",     \"response\"   ],   \"title\": \"AlertResponse\",   \"type\": \"object\" } ```   ### /beacons   ``` {   \"properties\": {     \"id\": {       \"title\": \"Id\",       \"type\": \"string\"     },     \"online\": {       \"title\": \"Online\",       \"type\": \"boolean\"     },     \"category\": {       \"title\": \"Category\",       \"type\": \"string\"     },     \"activated\": {       \"title\": \"Activated\",       \"type\": \"boolean\"     },     \"level\": {       \"title\": \"Level\",       \"type\": \"string\"     }   },   \"required\": [     \"id\",     \"online\",     \"category\",     \"activated\",     \"level\"   ],   \"title\": \"BeaconState\",   \"type\": \"object\" } ```   ### /building_map   ``` {   \"$defs\": {     \"AffineImage\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"x_offset\": {           \"title\": \"X Offset\",           \"type\": \"number\"         },         \"y_offset\": {           \"title\": \"Y Offset\",           \"type\": \"number\"         },         \"yaw\": {           \"title\": \"Yaw\",           \"type\": \"number\"         },         \"scale\": {           \"title\": \"Scale\",           \"type\": \"number\"         },         \"encoding\": {           \"title\": \"Encoding\",           \"type\": \"string\"         },         \"data\": {           \"title\": \"Data\",           \"type\": \"string\"         }       },       \"required\": [         \"name\",         \"x_offset\",         \"y_offset\",         \"yaw\",         \"scale\",         \"encoding\",         \"data\"       ],       \"title\": \"AffineImage\",       \"type\": \"object\"     },     \"Door\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"v1_x\": {           \"title\": \"V1 X\",           \"type\": \"number\"         },         \"v1_y\": {           \"title\": \"V1 Y\",           \"type\": \"number\"         },         \"v2_x\": {           \"title\": \"V2 X\",           \"type\": \"number\"         },         \"v2_y\": {           \"title\": \"V2 Y\",           \"type\": \"number\"         },         \"door_type\": {           \"maximum\": 255,           \"minimum\": 0,           \"title\": \"Door Type\",           \"type\": \"integer\"         },         \"motion_range\": {           \"title\": \"Motion Range\",           \"type\": \"number\"         },         \"motion_direction\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Motion Direction\",           \"type\": \"integer\"         }       },       \"required\": [         \"name\",         \"v1_x\",         \"v1_y\",         \"v2_x\",         \"v2_y\",         \"door_type\",         \"motion_range\",         \"motion_direction\"       ],       \"title\": \"Door\",       \"type\": \"object\"     },     \"Graph\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"vertices\": {           \"items\": {             \"$ref\": \"#/$defs/GraphNode\"           },           \"title\": \"Vertices\",           \"type\": \"array\"         },         \"edges\": {           \"items\": {             \"$ref\": \"#/$defs/GraphEdge\"           },           \"title\": \"Edges\",           \"type\": \"array\"         },         \"params\": {           \"items\": {             \"$ref\": \"#/$defs/Param\"           },           \"title\": \"Params\",           \"type\": \"array\"         }       },       \"required\": [         \"name\",         \"vertices\",         \"edges\",         \"params\"       ],       \"title\": \"Graph\",       \"type\": \"object\"     },     \"GraphEdge\": {       \"properties\": {         \"v1_idx\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"V1 Idx\",           \"type\": \"integer\"         },         \"v2_idx\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"V2 Idx\",           \"type\": \"integer\"         },         \"params\": {           \"items\": {             \"$ref\": \"#/$defs/Param\"           },           \"title\": \"Params\",           \"type\": \"array\"         },         \"edge_type\": {           \"maximum\": 255,           \"minimum\": 0,           \"title\": \"Edge Type\",           \"type\": \"integer\"         }       },       \"required\": [         \"v1_idx\",         \"v2_idx\",         \"params\",         \"edge_type\"       ],       \"title\": \"GraphEdge\",       \"type\": \"object\"     },     \"GraphNode\": {       \"properties\": {         \"x\": {           \"title\": \"X\",           \"type\": \"number\"         },         \"y\": {           \"title\": \"Y\",           \"type\": \"number\"         },         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"params\": {           \"items\": {             \"$ref\": \"#/$defs/Param\"           },           \"title\": \"Params\",           \"type\": \"array\"         }       },       \"required\": [         \"x\",         \"y\",         \"name\",         \"params\"       ],       \"title\": \"GraphNode\",       \"type\": \"object\"     },     \"Level\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"elevation\": {           \"title\": \"Elevation\",           \"type\": \"number\"         },         \"images\": {           \"items\": {             \"$ref\": \"#/$defs/AffineImage\"           },           \"title\": \"Images\",           \"type\": \"array\"         },         \"places\": {           \"items\": {             \"$ref\": \"#/$defs/Place\"           },           \"title\": \"Places\",           \"type\": \"array\"         },         \"doors\": {           \"items\": {             \"$ref\": \"#/$defs/Door\"           },           \"title\": \"Doors\",           \"type\": \"array\"         },         \"nav_graphs\": {           \"items\": {             \"$ref\": \"#/$defs/Graph\"           },           \"title\": \"Nav Graphs\",           \"type\": \"array\"         },         \"wall_graph\": {           \"$ref\": \"#/$defs/Graph\"         }       },       \"required\": [         \"name\",         \"elevation\",         \"images\",         \"places\",         \"doors\",         \"nav_graphs\",         \"wall_graph\"       ],       \"title\": \"Level\",       \"type\": \"object\"     },     \"Lift\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"levels\": {           \"items\": {             \"type\": \"string\"           },           \"title\": \"Levels\",           \"type\": \"array\"         },         \"doors\": {           \"items\": {             \"$ref\": \"#/$defs/Door\"           },           \"title\": \"Doors\",           \"type\": \"array\"         },         \"wall_graph\": {           \"$ref\": \"#/$defs/Graph\"         },         \"ref_x\": {           \"title\": \"Ref X\",           \"type\": \"number\"         },         \"ref_y\": {           \"title\": \"Ref Y\",           \"type\": \"number\"         },         \"ref_yaw\": {           \"title\": \"Ref Yaw\",           \"type\": \"number\"         },         \"width\": {           \"title\": \"Width\",           \"type\": \"number\"         },         \"depth\": {           \"title\": \"Depth\",           \"type\": \"number\"         }       },       \"required\": [         \"name\",         \"levels\",         \"doors\",         \"wall_graph\",         \"ref_x\",         \"ref_y\",         \"ref_yaw\",         \"width\",         \"depth\"       ],       \"title\": \"Lift\",       \"type\": \"object\"     },     \"Param\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"type\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Type\",           \"type\": \"integer\"         },         \"value_int\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Value Int\",           \"type\": \"integer\"         },         \"value_float\": {           \"title\": \"Value Float\",           \"type\": \"number\"         },         \"value_string\": {           \"title\": \"Value String\",           \"type\": \"string\"         },         \"value_bool\": {           \"title\": \"Value Bool\",           \"type\": \"boolean\"         }       },       \"required\": [         \"name\",         \"type\",         \"value_int\",         \"value_float\",         \"value_string\",         \"value_bool\"       ],       \"title\": \"Param\",       \"type\": \"object\"     },     \"Place\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"x\": {           \"title\": \"X\",           \"type\": \"number\"         },         \"y\": {           \"title\": \"Y\",           \"type\": \"number\"         },         \"yaw\": {           \"title\": \"Yaw\",           \"type\": \"number\"         },         \"position_tolerance\": {           \"title\": \"Position Tolerance\",           \"type\": \"number\"         },         \"yaw_tolerance\": {           \"title\": \"Yaw Tolerance\",           \"type\": \"number\"         }       },       \"required\": [         \"name\",         \"x\",         \"y\",         \"yaw\",         \"position_tolerance\",         \"yaw_tolerance\"       ],       \"title\": \"Place\",       \"type\": \"object\"     }   },   \"properties\": {     \"name\": {       \"title\": \"Name\",       \"type\": \"string\"     },     \"levels\": {       \"items\": {         \"$ref\": \"#/$defs/Level\"       },       \"title\": \"Levels\",       \"type\": \"array\"     },     \"lifts\": {       \"items\": {         \"$ref\": \"#/$defs/Lift\"       },       \"title\": \"Lifts\",       \"type\": \"array\"     }   },   \"required\": [     \"name\",     \"levels\",     \"lifts\"   ],   \"title\": \"BuildingMap\",   \"type\": \"object\" } ```   ### /building_map/fire_alarm_trigger   ``` {   \"properties\": {     \"unix_millis_time\": {       \"title\": \"Unix Millis Time\",       \"type\": \"integer\"     },     \"trigger\": {       \"title\": \"Trigger\",       \"type\": \"boolean\"     }   },   \"required\": [     \"unix_millis_time\",     \"trigger\"   ],   \"title\": \"FireAlarmTriggerState\",   \"type\": \"object\" } ```   ### /delivery_alerts   ``` {   \"$defs\": {     \"Action\": {       \"enum\": [         \"waiting\",         \"cancel\",         \"override\",         \"resume\"       ],       \"title\": \"Action\",       \"type\": \"string\"     },     \"Category\": {       \"enum\": [         \"missing\",         \"wrong\",         \"obstructed\",         \"cancelled\"       ],       \"title\": \"Category\",       \"type\": \"string\"     },     \"Tier\": {       \"enum\": [         \"warning\",         \"error\"       ],       \"title\": \"Tier\",       \"type\": \"string\"     }   },   \"properties\": {     \"id\": {       \"title\": \"Id\",       \"type\": \"string\"     },     \"category\": {       \"$ref\": \"#/$defs/Category\"     },     \"tier\": {       \"$ref\": \"#/$defs/Tier\"     },     \"action\": {       \"$ref\": \"#/$defs/Action\"     },     \"task_id\": {       \"title\": \"Task Id\",       \"type\": \"string\"     },     \"message\": {       \"title\": \"Message\",       \"type\": \"string\"     }   },   \"required\": [     \"id\",     \"category\",     \"tier\",     \"action\",     \"task_id\",     \"message\"   ],   \"title\": \"DeliveryAlert\",   \"type\": \"object\" } ```   ### /doors/{door_name}/state   ``` {   \"$defs\": {     \"DoorMode\": {       \"properties\": {         \"value\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Value\",           \"type\": \"integer\"         }       },       \"required\": [         \"value\"       ],       \"title\": \"DoorMode\",       \"type\": \"object\"     },     \"Time\": {       \"properties\": {         \"sec\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Sec\",           \"type\": \"integer\"         },         \"nanosec\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Nanosec\",           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ],       \"title\": \"Time\",       \"type\": \"object\"     }   },   \"properties\": {     \"door_time\": {       \"$ref\": \"#/$defs/Time\"     },     \"door_name\": {       \"title\": \"Door Name\",       \"type\": \"string\"     },     \"current_mode\": {       \"$ref\": \"#/$defs/DoorMode\"     }   },   \"required\": [     \"door_time\",     \"door_name\",     \"current_mode\"   ],   \"title\": \"DoorState\",   \"type\": \"object\" } ```   ### /lifts/{lift_name}/state   ``` {   \"$defs\": {     \"Time\": {       \"properties\": {         \"sec\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Sec\",           \"type\": \"integer\"         },         \"nanosec\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Nanosec\",           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ],       \"title\": \"Time\",       \"type\": \"object\"     }   },   \"properties\": {     \"lift_time\": {       \"$ref\": \"#/$defs/Time\"     },     \"lift_name\": {       \"title\": \"Lift Name\",       \"type\": \"string\"     },     \"available_floors\": {       \"items\": {         \"type\": \"string\"       },       \"title\": \"Available Floors\",       \"type\": \"array\"     },     \"current_floor\": {       \"title\": \"Current Floor\",       \"type\": \"string\"     },     \"destination_floor\": {       \"title\": \"Destination Floor\",       \"type\": \"string\"     },     \"door_state\": {       \"maximum\": 255,       \"minimum\": 0,       \"title\": \"Door State\",       \"type\": \"integer\"     },     \"motion_state\": {       \"maximum\": 255,       \"minimum\": 0,       \"title\": \"Motion State\",       \"type\": \"integer\"     },     \"available_modes\": {       \"items\": {         \"type\": \"integer\"       },       \"title\": \"Available Modes\",       \"type\": \"array\"     },     \"current_mode\": {       \"maximum\": 255,       \"minimum\": 0,       \"title\": \"Current Mode\",       \"type\": \"integer\"     },     \"session_id\": {       \"title\": \"Session Id\",       \"type\": \"string\"     }   },   \"required\": [     \"lift_time\",     \"lift_name\",     \"available_floors\",     \"current_floor\",     \"destination_floor\",     \"door_state\",     \"motion_state\",     \"available_modes\",     \"current_mode\",     \"session_id\"   ],   \"title\": \"LiftState\",   \"type\": \"object\" } ```   ### /tasks/{task_id}/state   ``` {   \"$defs\": {     \"AssignedTo\": {       \"properties\": {         \"group\": {           \"title\": \"Group\",           \"type\": \"string\"         },         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         }       },       \"required\": [         \"group\",         \"name\"       ],       \"title\": \"AssignedTo\",       \"type\": \"object\"     },     \"Assignment\": {       \"properties\": {         \"fleet_name\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Fleet Name\"         },         \"expected_robot_name\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Expected Robot Name\"         }       },       \"title\": \"Assignment\",       \"type\": \"object\"     },     \"Booking\": {       \"properties\": {         \"id\": {           \"description\": \"The unique identifier for this task\",           \"title\": \"Id\",           \"type\": \"string\"         },         \"unix_millis_earliest_start_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Unix Millis Earliest Start Time\"         },         \"unix_millis_request_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Unix Millis Request Time\"         },         \"priority\": {           \"anyOf\": [             {               \"type\": \"object\"             },             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Priority information about this task\",           \"title\": \"Priority\"         },         \"labels\": {           \"anyOf\": [             {               \"items\": {                 \"type\": \"string\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Information about how and why this task was booked, items can be a single value like `dashboard` or a key-value pair like `app=dashboard`, in the case of a single value, it will be interpreted as a key-value pair with an empty string value.\",           \"title\": \"Labels\"         },         \"requester\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"(Optional) An identifier for the entity that requested this task\",           \"title\": \"Requester\"         }       },       \"required\": [         \"id\"       ],       \"title\": \"Booking\",       \"type\": \"object\"     },     \"Cancellation\": {       \"properties\": {         \"unix_millis_request_time\": {           \"description\": \"The time that the cancellation request arrived\",           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"labels\": {           \"description\": \"Labels to describe the cancel request, items can be a single value like `dashboard` or a key-value pair like `app=dashboard`, in the case of a single value, it will be interpreted as a key-value pair with an empty string value.\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ],       \"title\": \"Cancellation\",       \"type\": \"object\"     },     \"Category\": {       \"description\": \"The category of this task or phase\",       \"title\": \"Category\",       \"type\": \"string\"     },     \"Detail\": {       \"anyOf\": [         {           \"type\": \"object\"         },         {           \"items\": {},           \"type\": \"array\"         },         {           \"type\": \"string\"         }       ],       \"description\": \"Detailed information about a task, phase, or event\",       \"title\": \"Detail\"     },     \"Dispatch\": {       \"properties\": {         \"status\": {           \"$ref\": \"#/$defs/Status2\"         },         \"assignment\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Assignment\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"errors\": {           \"anyOf\": [             {               \"items\": {                 \"$ref\": \"#/$defs/Error\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Errors\"         }       },       \"required\": [         \"status\"       ],       \"title\": \"Dispatch\",       \"type\": \"object\"     },     \"Error\": {       \"properties\": {         \"code\": {           \"anyOf\": [             {               \"minimum\": 0,               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A standard code for the kind of error that has occurred\",           \"title\": \"Code\"         },         \"category\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"The category of the error\",           \"title\": \"Category\"         },         \"detail\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Details about the error\",           \"title\": \"Detail\"         }       },       \"title\": \"Error\",       \"type\": \"object\"     },     \"EstimateMillis\": {       \"description\": \"An estimate, in milliseconds, of how long the subject will take to complete\",       \"minimum\": 0,       \"title\": \"EstimateMillis\",       \"type\": \"integer\"     },     \"EventState\": {       \"properties\": {         \"id\": {           \"$ref\": \"#/$defs/Id\"         },         \"status\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Status\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"name\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"The brief name of the event\",           \"title\": \"Name\"         },         \"detail\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Detail\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Detailed information about the event\"         },         \"deps\": {           \"anyOf\": [             {               \"items\": {                 \"minimum\": 0,                 \"type\": \"integer\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"This event may depend on other events. This array contains the IDs of those other event dependencies.\",           \"title\": \"Deps\"         }       },       \"required\": [         \"id\"       ],       \"title\": \"EventState\",       \"type\": \"object\"     },     \"Id\": {       \"minimum\": 0,       \"title\": \"Id\",       \"type\": \"integer\"     },     \"Interruption\": {       \"properties\": {         \"unix_millis_request_time\": {           \"description\": \"The time that the interruption request arrived\",           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"labels\": {           \"description\": \"Labels to describe the purpose of the interruption, items can be a single value like `dashboard` or a key-value pair like `app=dashboard`, in the case of a single value, it will be interpreted as a key-value pair with an empty string value.\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         },         \"resumed_by\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/ResumedBy\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Information about the resume request that ended this interruption. This field will be missing if the interruption is still active.\"         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ],       \"title\": \"Interruption\",       \"type\": \"object\"     },     \"Killed\": {       \"properties\": {         \"unix_millis_request_time\": {           \"description\": \"The time that the cancellation request arrived\",           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"labels\": {           \"description\": \"Labels to describe the kill request, items can be a single value like `dashboard` or a key-value pair like `app=dashboard`, in the case of a single value, it will be interpreted as a key-value pair with an empty string value.\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ],       \"title\": \"Killed\",       \"type\": \"object\"     },     \"Phase\": {       \"properties\": {         \"id\": {           \"$ref\": \"#/$defs/Id\"         },         \"category\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Category\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"detail\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Detail\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"unix_millis_start_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Unix Millis Start Time\"         },         \"unix_millis_finish_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Unix Millis Finish Time\"         },         \"original_estimate_millis\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/EstimateMillis\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"estimate_millis\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/EstimateMillis\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"final_event_id\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Id\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"events\": {           \"anyOf\": [             {               \"additionalProperties\": {                 \"$ref\": \"#/$defs/EventState\"               },               \"type\": \"object\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A dictionary of events for this phase. The keys (property names) are the event IDs, which are integers.\",           \"title\": \"Events\"         },         \"skip_requests\": {           \"anyOf\": [             {               \"additionalProperties\": {                 \"$ref\": \"#/$defs/SkipPhaseRequest\"               },               \"type\": \"object\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Information about any skip requests that have been received\",           \"title\": \"Skip Requests\"         }       },       \"required\": [         \"id\"       ],       \"title\": \"Phase\",       \"type\": \"object\"     },     \"ResumedBy\": {       \"properties\": {         \"unix_millis_request_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"The time that the resume request arrived\",           \"title\": \"Unix Millis Request Time\"         },         \"labels\": {           \"description\": \"Labels to describe the resume request, items can be a single value like `dashboard` or a key-value pair like `app=dashboard`, in the case of a single value, it will be interpreted as a key-value pair with an empty string value.\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         }       },       \"required\": [         \"labels\"       ],       \"title\": \"ResumedBy\",       \"type\": \"object\"     },     \"SkipPhaseRequest\": {       \"properties\": {         \"unix_millis_request_time\": {           \"description\": \"The time that the skip request arrived\",           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"labels\": {           \"description\": \"Labels to describe the purpose of the skip request, items can be a single value like `dashboard` or a key-value pair like `app=dashboard`, in the case of a single value, it will be interpreted as a key-value pair with an empty string value.\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         },         \"undo\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Undo\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Information about an undo skip request that applied to this request\"         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ],       \"title\": \"SkipPhaseRequest\",       \"type\": \"object\"     },     \"Status\": {       \"enum\": [         \"uninitialized\",         \"blocked\",         \"error\",         \"failed\",         \"queued\",         \"standby\",         \"underway\",         \"delayed\",         \"skipped\",         \"canceled\",         \"killed\",         \"completed\"       ],       \"title\": \"Status\",       \"type\": \"string\"     },     \"Status2\": {       \"enum\": [         \"queued\",         \"selected\",         \"dispatched\",         \"failed_to_assign\",         \"canceled_in_flight\"       ],       \"title\": \"Status2\",       \"type\": \"string\"     },     \"Undo\": {       \"properties\": {         \"unix_millis_request_time\": {           \"description\": \"The time that the undo skip request arrived\",           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"labels\": {           \"description\": \"Labels to describe the undo skip request, items can be a single value like `dashboard` or a key-value pair like `app=dashboard`, in the case of a single value, it will be interpreted as a key-value pair with an empty string value.\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ],       \"title\": \"Undo\",       \"type\": \"object\"     }   },   \"properties\": {     \"booking\": {       \"$ref\": \"#/$defs/Booking\"     },     \"category\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Category\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"detail\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Detail\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"unix_millis_start_time\": {       \"anyOf\": [         {           \"type\": \"integer\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"title\": \"Unix Millis Start Time\"     },     \"unix_millis_finish_time\": {       \"anyOf\": [         {           \"type\": \"integer\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"title\": \"Unix Millis Finish Time\"     },     \"original_estimate_millis\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/EstimateMillis\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"estimate_millis\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/EstimateMillis\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"assigned_to\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/AssignedTo\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"Which agent (robot) is the task assigned to\"     },     \"status\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Status\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"dispatch\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Dispatch\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"phases\": {       \"anyOf\": [         {           \"additionalProperties\": {             \"$ref\": \"#/$defs/Phase\"           },           \"type\": \"object\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"A dictionary of the states of the phases of the task. The keys (property names) are phase IDs, which are integers.\",       \"title\": \"Phases\"     },     \"completed\": {       \"anyOf\": [         {           \"items\": {             \"$ref\": \"#/$defs/Id\"           },           \"type\": \"array\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"An array of the IDs of completed phases of this task\",       \"title\": \"Completed\"     },     \"active\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Id\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"The ID of the active phase for this task\"     },     \"pending\": {       \"anyOf\": [         {           \"items\": {             \"$ref\": \"#/$defs/Id\"           },           \"type\": \"array\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"An array of the pending phases of this task\",       \"title\": \"Pending\"     },     \"interruptions\": {       \"anyOf\": [         {           \"additionalProperties\": {             \"$ref\": \"#/$defs/Interruption\"           },           \"type\": \"object\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"A dictionary of interruptions that have been applied to this task. The keys (property names) are the unique token of the interruption request.\",       \"title\": \"Interruptions\"     },     \"cancellation\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Cancellation\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"If the task was cancelled, this will describe information about the request.\"     },     \"killed\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Killed\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"If the task was killed, this will describe information about the request.\"     }   },   \"required\": [     \"booking\"   ],   \"title\": \"TaskState\",   \"type\": \"object\" } ```   ### /tasks/{task_id}/log   ``` {   \"$defs\": {     \"LogEntry\": {       \"properties\": {         \"seq\": {           \"description\": \"Sequence number for this entry. Each entry has a unique sequence number which monotonically increase, until integer overflow causes a wrap around.\",           \"exclusiveMaximum\": 4294967296,           \"minimum\": 0,           \"title\": \"Seq\",           \"type\": \"integer\"         },         \"tier\": {           \"allOf\": [             {               \"$ref\": \"#/$defs/Tier\"             }           ],           \"description\": \"The importance level of the log entry\"         },         \"unix_millis_time\": {           \"title\": \"Unix Millis Time\",           \"type\": \"integer\"         },         \"text\": {           \"description\": \"The text of the log entry\",           \"title\": \"Text\",           \"type\": \"string\"         }       },       \"required\": [         \"seq\",         \"tier\",         \"unix_millis_time\",         \"text\"       ],       \"title\": \"LogEntry\",       \"type\": \"object\"     },     \"Phases\": {       \"additionalProperties\": false,       \"properties\": {         \"log\": {           \"anyOf\": [             {               \"items\": {                 \"$ref\": \"#/$defs/LogEntry\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Log entries related to the overall phase\",           \"title\": \"Log\"         },         \"events\": {           \"anyOf\": [             {               \"additionalProperties\": {                 \"items\": {                   \"$ref\": \"#/$defs/LogEntry\"                 },                 \"type\": \"array\"               },               \"type\": \"object\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A dictionary whose keys (property names) are the indices of an event in the phase\",           \"title\": \"Events\"         }       },       \"title\": \"Phases\",       \"type\": \"object\"     },     \"Tier\": {       \"enum\": [         \"uninitialized\",         \"info\",         \"warning\",         \"error\"       ],       \"title\": \"Tier\",       \"type\": \"string\"     }   },   \"additionalProperties\": false,   \"properties\": {     \"task_id\": {       \"title\": \"Task Id\",       \"type\": \"string\"     },     \"log\": {       \"anyOf\": [         {           \"items\": {             \"$ref\": \"#/$defs/LogEntry\"           },           \"type\": \"array\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"Log entries related to the overall task\",       \"title\": \"Log\"     },     \"phases\": {       \"anyOf\": [         {           \"additionalProperties\": {             \"$ref\": \"#/$defs/Phases\"           },           \"type\": \"object\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"A dictionary whose keys (property names) are the indices of a phase\",       \"title\": \"Phases\"     }   },   \"required\": [     \"task_id\"   ],   \"title\": \"TaskEventLog\",   \"type\": \"object\" } ```   ### /dispensers/{guid}/state   ``` {   \"$defs\": {     \"Time\": {       \"properties\": {         \"sec\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Sec\",           \"type\": \"integer\"         },         \"nanosec\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Nanosec\",           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ],       \"title\": \"Time\",       \"type\": \"object\"     }   },   \"properties\": {     \"time\": {       \"$ref\": \"#/$defs/Time\"     },     \"guid\": {       \"title\": \"Guid\",       \"type\": \"string\"     },     \"mode\": {       \"maximum\": 2147483647,       \"minimum\": -2147483648,       \"title\": \"Mode\",       \"type\": \"integer\"     },     \"request_guid_queue\": {       \"items\": {         \"type\": \"string\"       },       \"title\": \"Request Guid Queue\",       \"type\": \"array\"     },     \"seconds_remaining\": {       \"title\": \"Seconds Remaining\",       \"type\": \"number\"     }   },   \"required\": [     \"time\",     \"guid\",     \"mode\",     \"request_guid_queue\",     \"seconds_remaining\"   ],   \"title\": \"DispenserState\",   \"type\": \"object\" } ```   ### /ingestors/{guid}/state   ``` {   \"$defs\": {     \"Time\": {       \"properties\": {         \"sec\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Sec\",           \"type\": \"integer\"         },         \"nanosec\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Nanosec\",           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ],       \"title\": \"Time\",       \"type\": \"object\"     }   },   \"properties\": {     \"time\": {       \"$ref\": \"#/$defs/Time\"     },     \"guid\": {       \"title\": \"Guid\",       \"type\": \"string\"     },     \"mode\": {       \"maximum\": 2147483647,       \"minimum\": -2147483648,       \"title\": \"Mode\",       \"type\": \"integer\"     },     \"request_guid_queue\": {       \"items\": {         \"type\": \"string\"       },       \"title\": \"Request Guid Queue\",       \"type\": \"array\"     },     \"seconds_remaining\": {       \"title\": \"Seconds Remaining\",       \"type\": \"number\"     }   },   \"required\": [     \"time\",     \"guid\",     \"mode\",     \"request_guid_queue\",     \"seconds_remaining\"   ],   \"title\": \"IngestorState\",   \"type\": \"object\" } ```   ### /fleets/{name}/state   ``` {   \"$defs\": {     \"Commission\": {       \"properties\": {         \"dispatch_tasks\": {           \"anyOf\": [             {               \"type\": \"boolean\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Should the robot accept dispatched tasks, true/false. When used in a request, leave this unset to not change the robot\'s current value.\",           \"title\": \"Dispatch Tasks\"         },         \"direct_tasks\": {           \"anyOf\": [             {               \"type\": \"boolean\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Should the robot accept direct task requests, true/false. When used in a request, leave this unset to not change the robot\'s current value.\",           \"title\": \"Direct Tasks\"         },         \"idle_behavior\": {           \"anyOf\": [             {               \"type\": \"boolean\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Should the robot perform its idle behavior, true/false. When used in a request, leave this unset to not change the robot\'s current value.\",           \"title\": \"Idle Behavior\"         }       },       \"title\": \"Commission\",       \"type\": \"object\"     },     \"Issue\": {       \"properties\": {         \"category\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Category of the robot\'s issue\",           \"title\": \"Category\"         },         \"detail\": {           \"anyOf\": [             {               \"type\": \"object\"             },             {               \"items\": {},               \"type\": \"array\"             },             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Detailed information about the issue\",           \"title\": \"Detail\"         }       },       \"title\": \"Issue\",       \"type\": \"object\"     },     \"Location2D\": {       \"properties\": {         \"map\": {           \"title\": \"Map\",           \"type\": \"string\"         },         \"x\": {           \"title\": \"X\",           \"type\": \"number\"         },         \"y\": {           \"title\": \"Y\",           \"type\": \"number\"         },         \"yaw\": {           \"title\": \"Yaw\",           \"type\": \"number\"         }       },       \"required\": [         \"map\",         \"x\",         \"y\",         \"yaw\"       ],       \"title\": \"Location2D\",       \"type\": \"object\"     },     \"MutexGroups\": {       \"properties\": {         \"locked\": {           \"anyOf\": [             {               \"items\": {                 \"type\": \"string\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A list of mutex groups that this robot has currently locked\",           \"title\": \"Locked\"         },         \"requesting\": {           \"anyOf\": [             {               \"items\": {                 \"type\": \"string\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A list of the mutex groups that this robot is currently requesting but has not lockd yet\",           \"title\": \"Requesting\"         }       },       \"title\": \"MutexGroups\",       \"type\": \"object\"     },     \"RobotState\": {       \"properties\": {         \"name\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Name\"         },         \"status\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Status\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A simple token representing the status of the robot\"         },         \"task_id\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"The ID of the task this robot is currently working on. Empty string if the robot is not working on a task.\",           \"title\": \"Task Id\"         },         \"unix_millis_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Unix Millis Time\"         },         \"location\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Location2D\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"battery\": {           \"anyOf\": [             {               \"maximum\": 1.0,               \"minimum\": 0.0,               \"type\": \"number\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"State of charge of the battery. Values range from 0.0 (depleted) to 1.0 (fully charged)\",           \"title\": \"Battery\"         },         \"issues\": {           \"anyOf\": [             {               \"items\": {                 \"$ref\": \"#/$defs/Issue\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A list of issues with the robot that operators need to address\",           \"title\": \"Issues\"         },         \"commission\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Commission\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"mutex_groups\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/MutexGroups\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Information about the mutex groups that this robot is interacting with\"         }       },       \"title\": \"RobotState\",       \"type\": \"object\"     },     \"Status\": {       \"enum\": [         \"uninitialized\",         \"offline\",         \"shutdown\",         \"idle\",         \"charging\",         \"working\",         \"error\"       ],       \"title\": \"Status\",       \"type\": \"string\"     }   },   \"properties\": {     \"name\": {       \"anyOf\": [         {           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"title\": \"Name\"     },     \"robots\": {       \"anyOf\": [         {           \"additionalProperties\": {             \"$ref\": \"#/$defs/RobotState\"           },           \"type\": \"object\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"A dictionary of the states of the robots that belong to this fleet\",       \"title\": \"Robots\"     }   },   \"title\": \"FleetState\",   \"type\": \"object\" } ```   ### /fleets/{name}/log   ``` {   \"$defs\": {     \"LogEntry\": {       \"properties\": {         \"seq\": {           \"description\": \"Sequence number for this entry. Each entry has a unique sequence number which monotonically increase, until integer overflow causes a wrap around.\",           \"exclusiveMaximum\": 4294967296,           \"minimum\": 0,           \"title\": \"Seq\",           \"type\": \"integer\"         },         \"tier\": {           \"allOf\": [             {               \"$ref\": \"#/$defs/Tier\"             }           ],           \"description\": \"The importance level of the log entry\"         },         \"unix_millis_time\": {           \"title\": \"Unix Millis Time\",           \"type\": \"integer\"         },         \"text\": {           \"description\": \"The text of the log entry\",           \"title\": \"Text\",           \"type\": \"string\"         }       },       \"required\": [         \"seq\",         \"tier\",         \"unix_millis_time\",         \"text\"       ],       \"title\": \"LogEntry\",       \"type\": \"object\"     },     \"Tier\": {       \"enum\": [         \"uninitialized\",         \"info\",         \"warning\",         \"error\"       ],       \"title\": \"Tier\",       \"type\": \"string\"     }   },   \"properties\": {     \"name\": {       \"anyOf\": [         {           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"title\": \"Name\"     },     \"log\": {       \"anyOf\": [         {           \"items\": {             \"$ref\": \"#/$defs/LogEntry\"           },           \"type\": \"array\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"Log for the overall fleet\",       \"title\": \"Log\"     },     \"robots\": {       \"anyOf\": [         {           \"additionalProperties\": {             \"items\": {               \"$ref\": \"#/$defs/LogEntry\"             },             \"type\": \"array\"           },           \"type\": \"object\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"Dictionary of logs for the individual robots. The keys (property names) are the robot names.\",       \"title\": \"Robots\"     }   },   \"title\": \"FleetLog\",   \"type\": \"object\" } ```   ### /rios   ``` {   \"properties\": {     \"id\": {       \"title\": \"Id\",       \"type\": \"string\"     },     \"type\": {       \"title\": \"Type\",       \"type\": \"string\"     },     \"data\": {       \"title\": \"Data\",       \"type\": \"object\"     }   },   \"required\": [     \"id\",     \"type\",     \"data\"   ],   \"title\": \"Rio\",   \"type\": \"object\" } ```
   * @summary Socket.io endpoint
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public lambdaSocketIoGet(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .lambdaSocketIoGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * DeliveryAlertsApi - axios parameter creator
 * @export
 */
export const DeliveryAlertsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Respond To Delivery Alert
     * @param {string} deliveryAlertId
     * @param {ApiServerModelsDeliveryAlertsDeliveryAlertCategory} category
     * @param {ApiServerModelsDeliveryAlertsDeliveryAlertTier} tier
     * @param {string} taskId
     * @param {Action} action
     * @param {string} message
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    respondToDeliveryAlertDeliveryAlertsDeliveryAlertIdResponsePost: async (
      deliveryAlertId: string,
      category: ApiServerModelsDeliveryAlertsDeliveryAlertCategory,
      tier: ApiServerModelsDeliveryAlertsDeliveryAlertTier,
      taskId: string,
      action: Action,
      message: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'deliveryAlertId' is not null or undefined
      assertParamExists(
        'respondToDeliveryAlertDeliveryAlertsDeliveryAlertIdResponsePost',
        'deliveryAlertId',
        deliveryAlertId,
      );
      // verify required parameter 'category' is not null or undefined
      assertParamExists(
        'respondToDeliveryAlertDeliveryAlertsDeliveryAlertIdResponsePost',
        'category',
        category,
      );
      // verify required parameter 'tier' is not null or undefined
      assertParamExists(
        'respondToDeliveryAlertDeliveryAlertsDeliveryAlertIdResponsePost',
        'tier',
        tier,
      );
      // verify required parameter 'taskId' is not null or undefined
      assertParamExists(
        'respondToDeliveryAlertDeliveryAlertsDeliveryAlertIdResponsePost',
        'taskId',
        taskId,
      );
      // verify required parameter 'action' is not null or undefined
      assertParamExists(
        'respondToDeliveryAlertDeliveryAlertsDeliveryAlertIdResponsePost',
        'action',
        action,
      );
      // verify required parameter 'message' is not null or undefined
      assertParamExists(
        'respondToDeliveryAlertDeliveryAlertsDeliveryAlertIdResponsePost',
        'message',
        message,
      );
      const localVarPath = `/delivery_alerts/{delivery_alert_id}/response`.replace(
        `{${'delivery_alert_id'}}`,
        encodeURIComponent(String(deliveryAlertId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (category !== undefined) {
        localVarQueryParameter['category'] = category;
      }

      if (tier !== undefined) {
        localVarQueryParameter['tier'] = tier;
      }

      if (taskId !== undefined) {
        localVarQueryParameter['task_id'] = taskId;
      }

      if (action !== undefined) {
        localVarQueryParameter['action'] = action;
      }

      if (message !== undefined) {
        localVarQueryParameter['message'] = message;
      }

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DeliveryAlertsApi - functional programming interface
 * @export
 */
export const DeliveryAlertsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DeliveryAlertsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Respond To Delivery Alert
     * @param {string} deliveryAlertId
     * @param {ApiServerModelsDeliveryAlertsDeliveryAlertCategory} category
     * @param {ApiServerModelsDeliveryAlertsDeliveryAlertTier} tier
     * @param {string} taskId
     * @param {Action} action
     * @param {string} message
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async respondToDeliveryAlertDeliveryAlertsDeliveryAlertIdResponsePost(
      deliveryAlertId: string,
      category: ApiServerModelsDeliveryAlertsDeliveryAlertCategory,
      tier: ApiServerModelsDeliveryAlertsDeliveryAlertTier,
      taskId: string,
      action: Action,
      message: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeliveryAlert>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.respondToDeliveryAlertDeliveryAlertsDeliveryAlertIdResponsePost(
          deliveryAlertId,
          category,
          tier,
          taskId,
          action,
          message,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          'DeliveryAlertsApi.respondToDeliveryAlertDeliveryAlertsDeliveryAlertIdResponsePost'
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * DeliveryAlertsApi - factory interface
 * @export
 */
export const DeliveryAlertsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DeliveryAlertsApiFp(configuration);
  return {
    /**
     *
     * @summary Respond To Delivery Alert
     * @param {string} deliveryAlertId
     * @param {ApiServerModelsDeliveryAlertsDeliveryAlertCategory} category
     * @param {ApiServerModelsDeliveryAlertsDeliveryAlertTier} tier
     * @param {string} taskId
     * @param {Action} action
     * @param {string} message
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    respondToDeliveryAlertDeliveryAlertsDeliveryAlertIdResponsePost(
      deliveryAlertId: string,
      category: ApiServerModelsDeliveryAlertsDeliveryAlertCategory,
      tier: ApiServerModelsDeliveryAlertsDeliveryAlertTier,
      taskId: string,
      action: Action,
      message: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<DeliveryAlert> {
      return localVarFp
        .respondToDeliveryAlertDeliveryAlertsDeliveryAlertIdResponsePost(
          deliveryAlertId,
          category,
          tier,
          taskId,
          action,
          message,
          authorization,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * DeliveryAlertsApi - object-oriented interface
 * @export
 * @class DeliveryAlertsApi
 * @extends {BaseAPI}
 */
export class DeliveryAlertsApi extends BaseAPI {
  /**
   *
   * @summary Respond To Delivery Alert
   * @param {string} deliveryAlertId
   * @param {ApiServerModelsDeliveryAlertsDeliveryAlertCategory} category
   * @param {ApiServerModelsDeliveryAlertsDeliveryAlertTier} tier
   * @param {string} taskId
   * @param {Action} action
   * @param {string} message
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DeliveryAlertsApi
   */
  public respondToDeliveryAlertDeliveryAlertsDeliveryAlertIdResponsePost(
    deliveryAlertId: string,
    category: ApiServerModelsDeliveryAlertsDeliveryAlertCategory,
    tier: ApiServerModelsDeliveryAlertsDeliveryAlertTier,
    taskId: string,
    action: Action,
    message: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return DeliveryAlertsApiFp(this.configuration)
      .respondToDeliveryAlertDeliveryAlertsDeliveryAlertIdResponsePost(
        deliveryAlertId,
        category,
        tier,
        taskId,
        action,
        message,
        authorization,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * DispensersApi - axios parameter creator
 * @export
 */
export const DispensersApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Available in socket.io
     * @summary Get Dispenser State
     * @param {string} guid
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDispenserStateDispensersGuidStateGet: async (
      guid: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guid' is not null or undefined
      assertParamExists('getDispenserStateDispensersGuidStateGet', 'guid', guid);
      const localVarPath = `/dispensers/{guid}/state`.replace(
        `{${'guid'}}`,
        encodeURIComponent(String(guid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Dispensers
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDispensersDispensersGet: async (
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/dispensers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DispensersApi - functional programming interface
 * @export
 */
export const DispensersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DispensersApiAxiosParamCreator(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Dispenser State
     * @param {string} guid
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDispenserStateDispensersGuidStateGet(
      guid: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DispenserState>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getDispenserStateDispensersGuidStateGet(
          guid,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DispensersApi.getDispenserStateDispensersGuidStateGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get Dispensers
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDispensersDispensersGet(
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dispenser>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDispensersDispensersGet(
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DispensersApi.getDispensersDispensersGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * DispensersApi - factory interface
 * @export
 */
export const DispensersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DispensersApiFp(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Dispenser State
     * @param {string} guid
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDispenserStateDispensersGuidStateGet(
      guid: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<DispenserState> {
      return localVarFp
        .getDispenserStateDispensersGuidStateGet(guid, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Dispensers
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDispensersDispensersGet(
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<Array<Dispenser>> {
      return localVarFp
        .getDispensersDispensersGet(authorization, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * DispensersApi - object-oriented interface
 * @export
 * @class DispensersApi
 * @extends {BaseAPI}
 */
export class DispensersApi extends BaseAPI {
  /**
   * Available in socket.io
   * @summary Get Dispenser State
   * @param {string} guid
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DispensersApi
   */
  public getDispenserStateDispensersGuidStateGet(
    guid: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return DispensersApiFp(this.configuration)
      .getDispenserStateDispensersGuidStateGet(guid, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Dispensers
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DispensersApi
   */
  public getDispensersDispensersGet(
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return DispensersApiFp(this.configuration)
      .getDispensersDispensersGet(authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * DoorsApi - axios parameter creator
 * @export
 */
export const DoorsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Available in socket.io
     * @summary Get Door State
     * @param {string} doorName
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDoorStateDoorsDoorNameStateGet: async (
      doorName: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'doorName' is not null or undefined
      assertParamExists('getDoorStateDoorsDoorNameStateGet', 'doorName', doorName);
      const localVarPath = `/doors/{door_name}/state`.replace(
        `{${'door_name'}}`,
        encodeURIComponent(String(doorName)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Doors
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDoorsDoorsGet: async (
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/doors`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post Door Request
     * @param {string} doorName
     * @param {DoorRequest} doorRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postDoorRequestDoorsDoorNameRequestPost: async (
      doorName: string,
      doorRequest: DoorRequest,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'doorName' is not null or undefined
      assertParamExists('postDoorRequestDoorsDoorNameRequestPost', 'doorName', doorName);
      // verify required parameter 'doorRequest' is not null or undefined
      assertParamExists('postDoorRequestDoorsDoorNameRequestPost', 'doorRequest', doorRequest);
      const localVarPath = `/doors/{door_name}/request`.replace(
        `{${'door_name'}}`,
        encodeURIComponent(String(doorName)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        doorRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DoorsApi - functional programming interface
 * @export
 */
export const DoorsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DoorsApiAxiosParamCreator(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Door State
     * @param {string} doorName
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDoorStateDoorsDoorNameStateGet(
      doorName: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DoorState>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDoorStateDoorsDoorNameStateGet(
        doorName,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DoorsApi.getDoorStateDoorsDoorNameStateGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get Doors
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDoorsDoorsGet(
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Door>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDoorsDoorsGet(
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DoorsApi.getDoorsDoorsGet']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Post Door Request
     * @param {string} doorName
     * @param {DoorRequest} doorRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postDoorRequestDoorsDoorNameRequestPost(
      doorName: string,
      doorRequest: DoorRequest,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postDoorRequestDoorsDoorNameRequestPost(
          doorName,
          doorRequest,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DoorsApi.postDoorRequestDoorsDoorNameRequestPost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * DoorsApi - factory interface
 * @export
 */
export const DoorsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DoorsApiFp(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Door State
     * @param {string} doorName
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDoorStateDoorsDoorNameStateGet(
      doorName: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<DoorState> {
      return localVarFp
        .getDoorStateDoorsDoorNameStateGet(doorName, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Doors
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDoorsDoorsGet(authorization?: string | null, options?: any): AxiosPromise<Array<Door>> {
      return localVarFp
        .getDoorsDoorsGet(authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Post Door Request
     * @param {string} doorName
     * @param {DoorRequest} doorRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postDoorRequestDoorsDoorNameRequestPost(
      doorName: string,
      doorRequest: DoorRequest,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .postDoorRequestDoorsDoorNameRequestPost(doorName, doorRequest, authorization, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * DoorsApi - object-oriented interface
 * @export
 * @class DoorsApi
 * @extends {BaseAPI}
 */
export class DoorsApi extends BaseAPI {
  /**
   * Available in socket.io
   * @summary Get Door State
   * @param {string} doorName
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DoorsApi
   */
  public getDoorStateDoorsDoorNameStateGet(
    doorName: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return DoorsApiFp(this.configuration)
      .getDoorStateDoorsDoorNameStateGet(doorName, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Doors
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DoorsApi
   */
  public getDoorsDoorsGet(authorization?: string | null, options?: RawAxiosRequestConfig) {
    return DoorsApiFp(this.configuration)
      .getDoorsDoorsGet(authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Post Door Request
   * @param {string} doorName
   * @param {DoorRequest} doorRequest
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DoorsApi
   */
  public postDoorRequestDoorsDoorNameRequestPost(
    doorName: string,
    doorRequest: DoorRequest,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return DoorsApiFp(this.configuration)
      .postDoorRequestDoorsDoorNameRequestPost(doorName, doorRequest, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * FleetsApi - axios parameter creator
 * @export
 */
export const FleetsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Decommissions a robot, cancels all direct tasks, and preventing it from accepting any new tasks (both dispatch tasks and direct tasks), with the options to:  - Reassign all queued dispatch tasks to other robots. If task reassignment   is chosen, the response will contain the results of the reassignment as   well, any failed reassignments will be cancelled instead. - Still allow idle behaviors (formerly known as finishing tasks). If   allowed, the robot will still be issued idle behavior commands (e.g.   return to charger, park somewhere) once it is decommissioned, as opposed   to waiting for human intervention at the same position when it was   decommissioned.  This will not affect the ongoing task that the robot is currently performing.
     * @summary Decommission Robot
     * @param {string} name
     * @param {string} robotName
     * @param {boolean} reassignTasks
     * @param {boolean} allowIdleBehavior
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    decommissionRobotFleetsNameDecommissionPost: async (
      name: string,
      robotName: string,
      reassignTasks: boolean,
      allowIdleBehavior: boolean,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('decommissionRobotFleetsNameDecommissionPost', 'name', name);
      // verify required parameter 'robotName' is not null or undefined
      assertParamExists('decommissionRobotFleetsNameDecommissionPost', 'robotName', robotName);
      // verify required parameter 'reassignTasks' is not null or undefined
      assertParamExists(
        'decommissionRobotFleetsNameDecommissionPost',
        'reassignTasks',
        reassignTasks,
      );
      // verify required parameter 'allowIdleBehavior' is not null or undefined
      assertParamExists(
        'decommissionRobotFleetsNameDecommissionPost',
        'allowIdleBehavior',
        allowIdleBehavior,
      );
      const localVarPath = `/fleets/{name}/decommission`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (robotName !== undefined) {
        localVarQueryParameter['robot_name'] = robotName;
      }

      if (reassignTasks !== undefined) {
        localVarQueryParameter['reassign_tasks'] = reassignTasks;
      }

      if (allowIdleBehavior !== undefined) {
        localVarQueryParameter['allow_idle_behavior'] = allowIdleBehavior;
      }

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Available in socket.io
     * @summary Get Fleet Log
     * @param {string} name
     * @param {string | null} [between]              The period of request time to fetch, in unix millis.              This can be either a comma separated string or a string prefixed with \&#39;-\&#39; to fetch the last X millis.              Example:                 \&quot;1000,2000\&quot; - Fetch resources between unix millis 1000 and 2000.                 \&quot;-60000\&quot; - Fetch resources in the last minute.
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFleetLogFleetsNameLogGet: async (
      name: string,
      between?: string | null,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getFleetLogFleetsNameLogGet', 'name', name);
      const localVarPath = `/fleets/{name}/log`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (between !== undefined) {
        localVarQueryParameter['between'] = between;
      }

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Available in socket.io
     * @summary Get Fleet State
     * @param {string} name
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFleetStateFleetsNameStateGet: async (
      name: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getFleetStateFleetsNameStateGet', 'name', name);
      const localVarPath = `/fleets/{name}/state`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Fleets
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFleetsFleetsGet: async (
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/fleets`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Recommissions a robot, allowing it to accept new dispatch tasks and direct tasks, as well as resume idle behaviors (formerly known as finishing tasks).
     * @summary Recommission Robot
     * @param {string} name
     * @param {string} robotName
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    recommissionRobotFleetsNameRecommissionPost: async (
      name: string,
      robotName: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('recommissionRobotFleetsNameRecommissionPost', 'name', name);
      // verify required parameter 'robotName' is not null or undefined
      assertParamExists('recommissionRobotFleetsNameRecommissionPost', 'robotName', robotName);
      const localVarPath = `/fleets/{name}/recommission`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (robotName !== undefined) {
        localVarQueryParameter['robot_name'] = robotName;
      }

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Request to manually unlock a mutex group that is currently being held by a specific robot of a specific fleet.
     * @summary Unlock Mutex Group
     * @param {string} name
     * @param {string} robotName
     * @param {string} mutexGroup
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlockMutexGroupFleetsNameUnlockMutexGroupPost: async (
      name: string,
      robotName: string,
      mutexGroup: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('unlockMutexGroupFleetsNameUnlockMutexGroupPost', 'name', name);
      // verify required parameter 'robotName' is not null or undefined
      assertParamExists('unlockMutexGroupFleetsNameUnlockMutexGroupPost', 'robotName', robotName);
      // verify required parameter 'mutexGroup' is not null or undefined
      assertParamExists('unlockMutexGroupFleetsNameUnlockMutexGroupPost', 'mutexGroup', mutexGroup);
      const localVarPath = `/fleets/{name}/unlock_mutex_group`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (robotName !== undefined) {
        localVarQueryParameter['robot_name'] = robotName;
      }

      if (mutexGroup !== undefined) {
        localVarQueryParameter['mutex_group'] = mutexGroup;
      }

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FleetsApi - functional programming interface
 * @export
 */
export const FleetsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FleetsApiAxiosParamCreator(configuration);
  return {
    /**
     * Decommissions a robot, cancels all direct tasks, and preventing it from accepting any new tasks (both dispatch tasks and direct tasks), with the options to:  - Reassign all queued dispatch tasks to other robots. If task reassignment   is chosen, the response will contain the results of the reassignment as   well, any failed reassignments will be cancelled instead. - Still allow idle behaviors (formerly known as finishing tasks). If   allowed, the robot will still be issued idle behavior commands (e.g.   return to charger, park somewhere) once it is decommissioned, as opposed   to waiting for human intervention at the same position when it was   decommissioned.  This will not affect the ongoing task that the robot is currently performing.
     * @summary Decommission Robot
     * @param {string} name
     * @param {string} robotName
     * @param {boolean} reassignTasks
     * @param {boolean} allowIdleBehavior
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async decommissionRobotFleetsNameDecommissionPost(
      name: string,
      robotName: string,
      reassignTasks: boolean,
      allowIdleBehavior: boolean,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RobotCommissionResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.decommissionRobotFleetsNameDecommissionPost(
          name,
          robotName,
          reassignTasks,
          allowIdleBehavior,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['FleetsApi.decommissionRobotFleetsNameDecommissionPost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Available in socket.io
     * @summary Get Fleet Log
     * @param {string} name
     * @param {string | null} [between]              The period of request time to fetch, in unix millis.              This can be either a comma separated string or a string prefixed with \&#39;-\&#39; to fetch the last X millis.              Example:                 \&quot;1000,2000\&quot; - Fetch resources between unix millis 1000 and 2000.                 \&quot;-60000\&quot; - Fetch resources in the last minute.
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFleetLogFleetsNameLogGet(
      name: string,
      between?: string | null,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FleetLog>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFleetLogFleetsNameLogGet(
        name,
        between,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['FleetsApi.getFleetLogFleetsNameLogGet']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Available in socket.io
     * @summary Get Fleet State
     * @param {string} name
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFleetStateFleetsNameStateGet(
      name: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FleetState>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFleetStateFleetsNameStateGet(
        name,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['FleetsApi.getFleetStateFleetsNameStateGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get Fleets
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFleetsFleetsGet(
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FleetState>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFleetsFleetsGet(
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['FleetsApi.getFleetsFleetsGet']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Recommissions a robot, allowing it to accept new dispatch tasks and direct tasks, as well as resume idle behaviors (formerly known as finishing tasks).
     * @summary Recommission Robot
     * @param {string} name
     * @param {string} robotName
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async recommissionRobotFleetsNameRecommissionPost(
      name: string,
      robotName: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RobotCommissionResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.recommissionRobotFleetsNameRecommissionPost(
          name,
          robotName,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['FleetsApi.recommissionRobotFleetsNameRecommissionPost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Request to manually unlock a mutex group that is currently being held by a specific robot of a specific fleet.
     * @summary Unlock Mutex Group
     * @param {string} name
     * @param {string} robotName
     * @param {string} mutexGroup
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unlockMutexGroupFleetsNameUnlockMutexGroupPost(
      name: string,
      robotName: string,
      mutexGroup: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.unlockMutexGroupFleetsNameUnlockMutexGroupPost(
          name,
          robotName,
          mutexGroup,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['FleetsApi.unlockMutexGroupFleetsNameUnlockMutexGroupPost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * FleetsApi - factory interface
 * @export
 */
export const FleetsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = FleetsApiFp(configuration);
  return {
    /**
     * Decommissions a robot, cancels all direct tasks, and preventing it from accepting any new tasks (both dispatch tasks and direct tasks), with the options to:  - Reassign all queued dispatch tasks to other robots. If task reassignment   is chosen, the response will contain the results of the reassignment as   well, any failed reassignments will be cancelled instead. - Still allow idle behaviors (formerly known as finishing tasks). If   allowed, the robot will still be issued idle behavior commands (e.g.   return to charger, park somewhere) once it is decommissioned, as opposed   to waiting for human intervention at the same position when it was   decommissioned.  This will not affect the ongoing task that the robot is currently performing.
     * @summary Decommission Robot
     * @param {string} name
     * @param {string} robotName
     * @param {boolean} reassignTasks
     * @param {boolean} allowIdleBehavior
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    decommissionRobotFleetsNameDecommissionPost(
      name: string,
      robotName: string,
      reassignTasks: boolean,
      allowIdleBehavior: boolean,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<RobotCommissionResponse> {
      return localVarFp
        .decommissionRobotFleetsNameDecommissionPost(
          name,
          robotName,
          reassignTasks,
          allowIdleBehavior,
          authorization,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Available in socket.io
     * @summary Get Fleet Log
     * @param {string} name
     * @param {string | null} [between]              The period of request time to fetch, in unix millis.              This can be either a comma separated string or a string prefixed with \&#39;-\&#39; to fetch the last X millis.              Example:                 \&quot;1000,2000\&quot; - Fetch resources between unix millis 1000 and 2000.                 \&quot;-60000\&quot; - Fetch resources in the last minute.
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFleetLogFleetsNameLogGet(
      name: string,
      between?: string | null,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<FleetLog> {
      return localVarFp
        .getFleetLogFleetsNameLogGet(name, between, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Available in socket.io
     * @summary Get Fleet State
     * @param {string} name
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFleetStateFleetsNameStateGet(
      name: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<FleetState> {
      return localVarFp
        .getFleetStateFleetsNameStateGet(name, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Fleets
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFleetsFleetsGet(
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<Array<FleetState>> {
      return localVarFp
        .getFleetsFleetsGet(authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Recommissions a robot, allowing it to accept new dispatch tasks and direct tasks, as well as resume idle behaviors (formerly known as finishing tasks).
     * @summary Recommission Robot
     * @param {string} name
     * @param {string} robotName
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    recommissionRobotFleetsNameRecommissionPost(
      name: string,
      robotName: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<RobotCommissionResponse> {
      return localVarFp
        .recommissionRobotFleetsNameRecommissionPost(name, robotName, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Request to manually unlock a mutex group that is currently being held by a specific robot of a specific fleet.
     * @summary Unlock Mutex Group
     * @param {string} name
     * @param {string} robotName
     * @param {string} mutexGroup
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlockMutexGroupFleetsNameUnlockMutexGroupPost(
      name: string,
      robotName: string,
      mutexGroup: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .unlockMutexGroupFleetsNameUnlockMutexGroupPost(
          name,
          robotName,
          mutexGroup,
          authorization,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * FleetsApi - object-oriented interface
 * @export
 * @class FleetsApi
 * @extends {BaseAPI}
 */
export class FleetsApi extends BaseAPI {
  /**
   * Decommissions a robot, cancels all direct tasks, and preventing it from accepting any new tasks (both dispatch tasks and direct tasks), with the options to:  - Reassign all queued dispatch tasks to other robots. If task reassignment   is chosen, the response will contain the results of the reassignment as   well, any failed reassignments will be cancelled instead. - Still allow idle behaviors (formerly known as finishing tasks). If   allowed, the robot will still be issued idle behavior commands (e.g.   return to charger, park somewhere) once it is decommissioned, as opposed   to waiting for human intervention at the same position when it was   decommissioned.  This will not affect the ongoing task that the robot is currently performing.
   * @summary Decommission Robot
   * @param {string} name
   * @param {string} robotName
   * @param {boolean} reassignTasks
   * @param {boolean} allowIdleBehavior
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetsApi
   */
  public decommissionRobotFleetsNameDecommissionPost(
    name: string,
    robotName: string,
    reassignTasks: boolean,
    allowIdleBehavior: boolean,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return FleetsApiFp(this.configuration)
      .decommissionRobotFleetsNameDecommissionPost(
        name,
        robotName,
        reassignTasks,
        allowIdleBehavior,
        authorization,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Available in socket.io
   * @summary Get Fleet Log
   * @param {string} name
   * @param {string | null} [between]              The period of request time to fetch, in unix millis.              This can be either a comma separated string or a string prefixed with \&#39;-\&#39; to fetch the last X millis.              Example:                 \&quot;1000,2000\&quot; - Fetch resources between unix millis 1000 and 2000.                 \&quot;-60000\&quot; - Fetch resources in the last minute.
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetsApi
   */
  public getFleetLogFleetsNameLogGet(
    name: string,
    between?: string | null,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return FleetsApiFp(this.configuration)
      .getFleetLogFleetsNameLogGet(name, between, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Available in socket.io
   * @summary Get Fleet State
   * @param {string} name
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetsApi
   */
  public getFleetStateFleetsNameStateGet(
    name: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return FleetsApiFp(this.configuration)
      .getFleetStateFleetsNameStateGet(name, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Fleets
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetsApi
   */
  public getFleetsFleetsGet(authorization?: string | null, options?: RawAxiosRequestConfig) {
    return FleetsApiFp(this.configuration)
      .getFleetsFleetsGet(authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Recommissions a robot, allowing it to accept new dispatch tasks and direct tasks, as well as resume idle behaviors (formerly known as finishing tasks).
   * @summary Recommission Robot
   * @param {string} name
   * @param {string} robotName
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetsApi
   */
  public recommissionRobotFleetsNameRecommissionPost(
    name: string,
    robotName: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return FleetsApiFp(this.configuration)
      .recommissionRobotFleetsNameRecommissionPost(name, robotName, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Request to manually unlock a mutex group that is currently being held by a specific robot of a specific fleet.
   * @summary Unlock Mutex Group
   * @param {string} name
   * @param {string} robotName
   * @param {string} mutexGroup
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetsApi
   */
  public unlockMutexGroupFleetsNameUnlockMutexGroupPost(
    name: string,
    robotName: string,
    mutexGroup: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return FleetsApiFp(this.configuration)
      .unlockMutexGroupFleetsNameUnlockMutexGroupPost(
        name,
        robotName,
        mutexGroup,
        authorization,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * IngestorsApi - axios parameter creator
 * @export
 */
export const IngestorsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Available in socket.io
     * @summary Get Ingestor State
     * @param {string} guid
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIngestorStateIngestorsGuidStateGet: async (
      guid: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guid' is not null or undefined
      assertParamExists('getIngestorStateIngestorsGuidStateGet', 'guid', guid);
      const localVarPath = `/ingestors/{guid}/state`.replace(
        `{${'guid'}}`,
        encodeURIComponent(String(guid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Ingestors
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIngestorsIngestorsGet: async (
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/ingestors`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * IngestorsApi - functional programming interface
 * @export
 */
export const IngestorsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = IngestorsApiAxiosParamCreator(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Ingestor State
     * @param {string} guid
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getIngestorStateIngestorsGuidStateGet(
      guid: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IngestorState>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getIngestorStateIngestorsGuidStateGet(
          guid,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['IngestorsApi.getIngestorStateIngestorsGuidStateGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get Ingestors
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getIngestorsIngestorsGet(
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Ingestor>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getIngestorsIngestorsGet(
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['IngestorsApi.getIngestorsIngestorsGet']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * IngestorsApi - factory interface
 * @export
 */
export const IngestorsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = IngestorsApiFp(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Ingestor State
     * @param {string} guid
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIngestorStateIngestorsGuidStateGet(
      guid: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<IngestorState> {
      return localVarFp
        .getIngestorStateIngestorsGuidStateGet(guid, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Ingestors
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIngestorsIngestorsGet(
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<Array<Ingestor>> {
      return localVarFp
        .getIngestorsIngestorsGet(authorization, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * IngestorsApi - object-oriented interface
 * @export
 * @class IngestorsApi
 * @extends {BaseAPI}
 */
export class IngestorsApi extends BaseAPI {
  /**
   * Available in socket.io
   * @summary Get Ingestor State
   * @param {string} guid
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IngestorsApi
   */
  public getIngestorStateIngestorsGuidStateGet(
    guid: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return IngestorsApiFp(this.configuration)
      .getIngestorStateIngestorsGuidStateGet(guid, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Ingestors
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IngestorsApi
   */
  public getIngestorsIngestorsGet(authorization?: string | null, options?: RawAxiosRequestConfig) {
    return IngestorsApiFp(this.configuration)
      .getIngestorsIngestorsGet(authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * LiftsApi - axios parameter creator
 * @export
 */
export const LiftsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Available in socket.io
     * @summary Get Lift State
     * @param {string} liftName
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLiftStateLiftsLiftNameStateGet: async (
      liftName: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'liftName' is not null or undefined
      assertParamExists('getLiftStateLiftsLiftNameStateGet', 'liftName', liftName);
      const localVarPath = `/lifts/{lift_name}/state`.replace(
        `{${'lift_name'}}`,
        encodeURIComponent(String(liftName)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Lifts
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLiftsLiftsGet: async (
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/lifts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post Lift Request
     * @param {string} liftName
     * @param {LiftRequest} liftRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postLiftRequestLiftsLiftNameRequestPost: async (
      liftName: string,
      liftRequest: LiftRequest,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'liftName' is not null or undefined
      assertParamExists('postLiftRequestLiftsLiftNameRequestPost', 'liftName', liftName);
      // verify required parameter 'liftRequest' is not null or undefined
      assertParamExists('postLiftRequestLiftsLiftNameRequestPost', 'liftRequest', liftRequest);
      const localVarPath = `/lifts/{lift_name}/request`.replace(
        `{${'lift_name'}}`,
        encodeURIComponent(String(liftName)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        liftRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LiftsApi - functional programming interface
 * @export
 */
export const LiftsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = LiftsApiAxiosParamCreator(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Lift State
     * @param {string} liftName
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLiftStateLiftsLiftNameStateGet(
      liftName: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiftState>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLiftStateLiftsLiftNameStateGet(
        liftName,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['LiftsApi.getLiftStateLiftsLiftNameStateGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get Lifts
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLiftsLiftsGet(
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Lift>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLiftsLiftsGet(
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['LiftsApi.getLiftsLiftsGet']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Post Lift Request
     * @param {string} liftName
     * @param {LiftRequest} liftRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postLiftRequestLiftsLiftNameRequestPost(
      liftName: string,
      liftRequest: LiftRequest,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postLiftRequestLiftsLiftNameRequestPost(
          liftName,
          liftRequest,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['LiftsApi.postLiftRequestLiftsLiftNameRequestPost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * LiftsApi - factory interface
 * @export
 */
export const LiftsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = LiftsApiFp(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Lift State
     * @param {string} liftName
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLiftStateLiftsLiftNameStateGet(
      liftName: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<LiftState> {
      return localVarFp
        .getLiftStateLiftsLiftNameStateGet(liftName, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Lifts
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLiftsLiftsGet(authorization?: string | null, options?: any): AxiosPromise<Array<Lift>> {
      return localVarFp
        .getLiftsLiftsGet(authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Post Lift Request
     * @param {string} liftName
     * @param {LiftRequest} liftRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postLiftRequestLiftsLiftNameRequestPost(
      liftName: string,
      liftRequest: LiftRequest,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .postLiftRequestLiftsLiftNameRequestPost(liftName, liftRequest, authorization, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * LiftsApi - object-oriented interface
 * @export
 * @class LiftsApi
 * @extends {BaseAPI}
 */
export class LiftsApi extends BaseAPI {
  /**
   * Available in socket.io
   * @summary Get Lift State
   * @param {string} liftName
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LiftsApi
   */
  public getLiftStateLiftsLiftNameStateGet(
    liftName: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return LiftsApiFp(this.configuration)
      .getLiftStateLiftsLiftNameStateGet(liftName, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Lifts
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LiftsApi
   */
  public getLiftsLiftsGet(authorization?: string | null, options?: RawAxiosRequestConfig) {
    return LiftsApiFp(this.configuration)
      .getLiftsLiftsGet(authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Post Lift Request
   * @param {string} liftName
   * @param {LiftRequest} liftRequest
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LiftsApi
   */
  public postLiftRequestLiftsLiftNameRequestPost(
    liftName: string,
    liftRequest: LiftRequest,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return LiftsApiFp(this.configuration)
      .postLiftRequestLiftsLiftNameRequestPost(liftName, liftRequest, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * RIOsApi - axios parameter creator
 * @export
 */
export const RIOsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Put Rio
     * @param {Rio} rio
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putRioRiosPut: async (
      rio: Rio,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'rio' is not null or undefined
      assertParamExists('putRioRiosPut', 'rio', rio);
      const localVarPath = `/rios`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        rio,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Query Rios
     * @param {string | null} [id] comma separated list of ids
     * @param {string | null} [type] comma separated list of types
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryRiosRiosGet: async (
      id?: string | null,
      type?: string | null,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/rios`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }

      if (type !== undefined) {
        localVarQueryParameter['type'] = type;
      }

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RIOsApi - functional programming interface
 * @export
 */
export const RIOsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = RIOsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Put Rio
     * @param {Rio} rio
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putRioRiosPut(
      rio: Rio,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.putRioRiosPut(
        rio,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['RIOsApi.putRioRiosPut']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Query Rios
     * @param {string | null} [id] comma separated list of ids
     * @param {string | null} [type] comma separated list of types
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async queryRiosRiosGet(
      id?: string | null,
      type?: string | null,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Rio>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.queryRiosRiosGet(
        id,
        type,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['RIOsApi.queryRiosRiosGet']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * RIOsApi - factory interface
 * @export
 */
export const RIOsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = RIOsApiFp(configuration);
  return {
    /**
     *
     * @summary Put Rio
     * @param {Rio} rio
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putRioRiosPut(rio: Rio, authorization?: string | null, options?: any): AxiosPromise<any> {
      return localVarFp
        .putRioRiosPut(rio, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Query Rios
     * @param {string | null} [id] comma separated list of ids
     * @param {string | null} [type] comma separated list of types
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryRiosRiosGet(
      id?: string | null,
      type?: string | null,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<Array<Rio>> {
      return localVarFp
        .queryRiosRiosGet(id, type, authorization, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * RIOsApi - object-oriented interface
 * @export
 * @class RIOsApi
 * @extends {BaseAPI}
 */
export class RIOsApi extends BaseAPI {
  /**
   *
   * @summary Put Rio
   * @param {Rio} rio
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RIOsApi
   */
  public putRioRiosPut(rio: Rio, authorization?: string | null, options?: RawAxiosRequestConfig) {
    return RIOsApiFp(this.configuration)
      .putRioRiosPut(rio, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Query Rios
   * @param {string | null} [id] comma separated list of ids
   * @param {string | null} [type] comma separated list of types
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RIOsApi
   */
  public queryRiosRiosGet(
    id?: string | null,
    type?: string | null,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return RIOsApiFp(this.configuration)
      .queryRiosRiosGet(id, type, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TasksApi - axios parameter creator
 * @export
 */
export const TasksApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Skip tasks on the excepted date
     * @summary Add Except Date
     * @param {number} taskId
     * @param {AddExceptDateRequest} addExceptDateRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addExceptDateScheduledTasksTaskIdExceptDatePost: async (
      taskId: number,
      addExceptDateRequest: AddExceptDateRequest,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskId' is not null or undefined
      assertParamExists('addExceptDateScheduledTasksTaskIdExceptDatePost', 'taskId', taskId);
      // verify required parameter 'addExceptDateRequest' is not null or undefined
      assertParamExists(
        'addExceptDateScheduledTasksTaskIdExceptDatePost',
        'addExceptDateRequest',
        addExceptDateRequest,
      );
      const localVarPath = `/scheduled_tasks/{task_id}/except_date`.replace(
        `{${'task_id'}}`,
        encodeURIComponent(String(taskId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        addExceptDateRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Del Scheduled Tasks
     * @param {number} taskId
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    delScheduledTasksScheduledTasksTaskIdDelete: async (
      taskId: number,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskId' is not null or undefined
      assertParamExists('delScheduledTasksScheduledTasksTaskIdDelete', 'taskId', taskId);
      const localVarPath = `/scheduled_tasks/{task_id}`.replace(
        `{${'task_id'}}`,
        encodeURIComponent(String(taskId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete Favorite Task
     * @param {string} favoriteTaskId
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFavoriteTaskFavoriteTasksFavoriteTaskIdDelete: async (
      favoriteTaskId: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'favoriteTaskId' is not null or undefined
      assertParamExists(
        'deleteFavoriteTaskFavoriteTasksFavoriteTaskIdDelete',
        'favoriteTaskId',
        favoriteTaskId,
      );
      const localVarPath = `/favorite_tasks/{favorite_task_id}`.replace(
        `{${'favorite_task_id'}}`,
        encodeURIComponent(String(favoriteTaskId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Favorites Tasks
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFavoritesTasksFavoriteTasksGet: async (
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/favorite_tasks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Scheduled Task
     * @param {number} taskId
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getScheduledTaskScheduledTasksTaskIdGet: async (
      taskId: number,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskId' is not null or undefined
      assertParamExists('getScheduledTaskScheduledTasksTaskIdGet', 'taskId', taskId);
      const localVarPath = `/scheduled_tasks/{task_id}`.replace(
        `{${'task_id'}}`,
        encodeURIComponent(String(taskId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Scheduled Tasks
     * @param {string} startBefore Only return scheduled tasks that start before given timestamp
     * @param {string} untilAfter Only return scheduled tasks that stop after given timestamp
     * @param {number | null} [limit] defaults to 100
     * @param {number | null} [offset] defaults to 0
     * @param {string | null} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getScheduledTasksScheduledTasksGet: async (
      startBefore: string,
      untilAfter: string,
      limit?: number | null,
      offset?: number | null,
      orderBy?: string | null,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'startBefore' is not null or undefined
      assertParamExists('getScheduledTasksScheduledTasksGet', 'startBefore', startBefore);
      // verify required parameter 'untilAfter' is not null or undefined
      assertParamExists('getScheduledTasksScheduledTasksGet', 'untilAfter', untilAfter);
      const localVarPath = `/scheduled_tasks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (startBefore !== undefined) {
        localVarQueryParameter['start_before'] =
          (startBefore as any) instanceof Date ? (startBefore as any).toISOString() : startBefore;
      }

      if (untilAfter !== undefined) {
        localVarQueryParameter['until_after'] =
          (untilAfter as any) instanceof Date ? (untilAfter as any).toISOString() : untilAfter;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['order_by'] = orderBy;
      }

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Task Booking Label
     * @param {string} taskId task_id
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskBookingLabelTasksTaskIdBookingLabelGet: async (
      taskId: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskId' is not null or undefined
      assertParamExists('getTaskBookingLabelTasksTaskIdBookingLabelGet', 'taskId', taskId);
      const localVarPath = `/tasks/{task_id}/booking_label`.replace(
        `{${'task_id'}}`,
        encodeURIComponent(String(taskId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Available in socket.io
     * @summary Get Task Log
     * @param {string} taskId task_id
     * @param {string | null} [between]              The period of request time to fetch, in unix millis.              This can be either a comma separated string or a string prefixed with \&#39;-\&#39; to fetch the last X millis.              Example:                 \&quot;1000,2000\&quot; - Fetch resources between unix millis 1000 and 2000.                 \&quot;-60000\&quot; - Fetch resources in the last minute.
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskLogTasksTaskIdLogGet: async (
      taskId: string,
      between?: string | null,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskId' is not null or undefined
      assertParamExists('getTaskLogTasksTaskIdLogGet', 'taskId', taskId);
      const localVarPath = `/tasks/{task_id}/log`.replace(
        `{${'task_id'}}`,
        encodeURIComponent(String(taskId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (between !== undefined) {
        localVarQueryParameter['between'] = between;
      }

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Task Request
     * @param {string} taskId task_id
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskRequestTasksTaskIdRequestGet: async (
      taskId: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskId' is not null or undefined
      assertParamExists('getTaskRequestTasksTaskIdRequestGet', 'taskId', taskId);
      const localVarPath = `/tasks/{task_id}/request`.replace(
        `{${'task_id'}}`,
        encodeURIComponent(String(taskId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Available in socket.io
     * @summary Get Task State
     * @param {string} taskId task_id
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskStateTasksTaskIdStateGet: async (
      taskId: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskId' is not null or undefined
      assertParamExists('getTaskStateTasksTaskIdStateGet', 'taskId', taskId);
      const localVarPath = `/tasks/{task_id}/state`.replace(
        `{${'task_id'}}`,
        encodeURIComponent(String(taskId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post Activity Discovery
     * @param {ActivityDiscoveryRequest} activityDiscoveryRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postActivityDiscoveryTasksActivityDiscoveryPost: async (
      activityDiscoveryRequest: ActivityDiscoveryRequest,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'activityDiscoveryRequest' is not null or undefined
      assertParamExists(
        'postActivityDiscoveryTasksActivityDiscoveryPost',
        'activityDiscoveryRequest',
        activityDiscoveryRequest,
      );
      const localVarPath = `/tasks/activity_discovery`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        activityDiscoveryRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post Cancel Task
     * @param {CancelTaskRequest} cancelTaskRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postCancelTaskTasksCancelTaskPost: async (
      cancelTaskRequest: CancelTaskRequest,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'cancelTaskRequest' is not null or undefined
      assertParamExists(
        'postCancelTaskTasksCancelTaskPost',
        'cancelTaskRequest',
        cancelTaskRequest,
      );
      const localVarPath = `/tasks/cancel_task`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        cancelTaskRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post Dispatch Task
     * @param {DispatchTaskRequest} dispatchTaskRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postDispatchTaskTasksDispatchTaskPost: async (
      dispatchTaskRequest: DispatchTaskRequest,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'dispatchTaskRequest' is not null or undefined
      assertParamExists(
        'postDispatchTaskTasksDispatchTaskPost',
        'dispatchTaskRequest',
        dispatchTaskRequest,
      );
      const localVarPath = `/tasks/dispatch_task`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        dispatchTaskRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post Favorite Task
     * @param {TaskFavorite} taskFavorite
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postFavoriteTaskFavoriteTasksPost: async (
      taskFavorite: TaskFavorite,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskFavorite' is not null or undefined
      assertParamExists('postFavoriteTaskFavoriteTasksPost', 'taskFavorite', taskFavorite);
      const localVarPath = `/favorite_tasks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        taskFavorite,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post Interrupt Task
     * @param {TaskInterruptionRequest} taskInterruptionRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postInterruptTaskTasksInterruptTaskPost: async (
      taskInterruptionRequest: TaskInterruptionRequest,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskInterruptionRequest' is not null or undefined
      assertParamExists(
        'postInterruptTaskTasksInterruptTaskPost',
        'taskInterruptionRequest',
        taskInterruptionRequest,
      );
      const localVarPath = `/tasks/interrupt_task`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        taskInterruptionRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post Kill Task
     * @param {TaskKillRequest} taskKillRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postKillTaskTasksKillTaskPost: async (
      taskKillRequest: TaskKillRequest,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskKillRequest' is not null or undefined
      assertParamExists('postKillTaskTasksKillTaskPost', 'taskKillRequest', taskKillRequest);
      const localVarPath = `/tasks/kill_task`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        taskKillRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post Resume Task
     * @param {TaskResumeRequest} taskResumeRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postResumeTaskTasksResumeTaskPost: async (
      taskResumeRequest: TaskResumeRequest,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskResumeRequest' is not null or undefined
      assertParamExists(
        'postResumeTaskTasksResumeTaskPost',
        'taskResumeRequest',
        taskResumeRequest,
      );
      const localVarPath = `/tasks/resume_task`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        taskResumeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post Rewind Task
     * @param {TaskRewindRequest} taskRewindRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postRewindTaskTasksRewindTaskPost: async (
      taskRewindRequest: TaskRewindRequest,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskRewindRequest' is not null or undefined
      assertParamExists(
        'postRewindTaskTasksRewindTaskPost',
        'taskRewindRequest',
        taskRewindRequest,
      );
      const localVarPath = `/tasks/rewind_task`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        taskRewindRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post Robot Task
     * @param {RobotTaskRequest} robotTaskRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postRobotTaskTasksRobotTaskPost: async (
      robotTaskRequest: RobotTaskRequest,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'robotTaskRequest' is not null or undefined
      assertParamExists('postRobotTaskTasksRobotTaskPost', 'robotTaskRequest', robotTaskRequest);
      const localVarPath = `/tasks/robot_task`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        robotTaskRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a scheduled task. Below are some examples of how the schedules are represented. For more examples, check the docs of the underlying library used [here](https://github.com/dbader/schedule/blob/6eb0b5346b1ce35ece5050e65789fa6e44368175/docs/examples.rst).  | every | to | period | at | description | | - | - | - | - | - | | 10 | - | minutes | - | Every 10 minutes | | - | - | hour | - | Every hour | | - | - | day | 10:30 | Every day at 10:30am | | - | - | monday | - | Every monday | | - | - | wednesday | 13:15 | Every wednesday at 01:15pm | | - | - | minute | :17 | Every 17th sec of a mintue | | 5 | 10 | seconds | - | Every 5-10 seconds (randomly) |
     * @summary Post Scheduled Task
     * @param {PostScheduledTaskRequest} postScheduledTaskRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postScheduledTaskScheduledTasksPost: async (
      postScheduledTaskRequest: PostScheduledTaskRequest,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'postScheduledTaskRequest' is not null or undefined
      assertParamExists(
        'postScheduledTaskScheduledTasksPost',
        'postScheduledTaskRequest',
        postScheduledTaskRequest,
      );
      const localVarPath = `/scheduled_tasks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        postScheduledTaskRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post Skip Phase
     * @param {TaskPhaseSkipRequest} taskPhaseSkipRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postSkipPhaseTasksSkipPhasePost: async (
      taskPhaseSkipRequest: TaskPhaseSkipRequest,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskPhaseSkipRequest' is not null or undefined
      assertParamExists(
        'postSkipPhaseTasksSkipPhasePost',
        'taskPhaseSkipRequest',
        taskPhaseSkipRequest,
      );
      const localVarPath = `/tasks/skip_phase`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        taskPhaseSkipRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post Task Discovery
     * @param {TaskDiscoveryRequest} taskDiscoveryRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postTaskDiscoveryTasksTaskDiscoveryPost: async (
      taskDiscoveryRequest: TaskDiscoveryRequest,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskDiscoveryRequest' is not null or undefined
      assertParamExists(
        'postTaskDiscoveryTasksTaskDiscoveryPost',
        'taskDiscoveryRequest',
        taskDiscoveryRequest,
      );
      const localVarPath = `/tasks/task_discovery`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        taskDiscoveryRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post Undo Skip Phase
     * @param {UndoPhaseSkipRequest} undoPhaseSkipRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUndoSkipPhaseTasksUndoSkipPhasePost: async (
      undoPhaseSkipRequest: UndoPhaseSkipRequest,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'undoPhaseSkipRequest' is not null or undefined
      assertParamExists(
        'postUndoSkipPhaseTasksUndoSkipPhasePost',
        'undoPhaseSkipRequest',
        undoPhaseSkipRequest,
      );
      const localVarPath = `/tasks/undo_skip_phase`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        undoPhaseSkipRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Query Task Requests
     * @param {string | null} [taskIds] comma separated list of task ids
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryTaskRequestsTasksRequestsGet: async (
      taskIds?: string | null,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/tasks/requests`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (taskIds !== undefined) {
        localVarQueryParameter['task_ids'] = taskIds;
      }

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Query Task States
     * @param {string | null} [taskId] comma separated list of task ids
     * @param {string | null} [category] comma separated list of task categories
     * @param {string | null} [requester] comma separated list of requester names
     * @param {string | null} [assignedTo] comma separated list of assigned robot names
     * @param {string | null} [status] comma separated list of statuses
     * @param {string | null} [label] comma separated list of labels, each item must be in the form &lt;key&gt;&#x3D;&lt;value&gt;, multiple items will filter tasks with all the labels
     * @param {string | null} [requestTimeBetween]              The period of request time to fetch, in unix millis.              This can be either a comma separated string or a string prefixed with \&#39;-\&#39; to fetch the last X millis.              Example:                 \&quot;1000,2000\&quot; - Fetch resources between unix millis 1000 and 2000.                 \&quot;-60000\&quot; - Fetch resources in the last minute.
     * @param {string | null} [startTimeBetween]              The period of request time to fetch, in unix millis.              This can be either a comma separated string or a string prefixed with \&#39;-\&#39; to fetch the last X millis.              Example:                 \&quot;1000,2000\&quot; - Fetch resources between unix millis 1000 and 2000.                 \&quot;-60000\&quot; - Fetch resources in the last minute.
     * @param {string | null} [finishTimeBetween]              The period of request time to fetch, in unix millis.              This can be either a comma separated string or a string prefixed with \&#39;-\&#39; to fetch the last X millis.              Example:                 \&quot;1000,2000\&quot; - Fetch resources between unix millis 1000 and 2000.                 \&quot;-60000\&quot; - Fetch resources in the last minute.
     * @param {number | null} [limit] defaults to 100
     * @param {number | null} [offset] defaults to 0
     * @param {string | null} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryTaskStatesTasksGet: async (
      taskId?: string | null,
      category?: string | null,
      requester?: string | null,
      assignedTo?: string | null,
      status?: string | null,
      label?: string | null,
      requestTimeBetween?: string | null,
      startTimeBetween?: string | null,
      finishTimeBetween?: string | null,
      limit?: number | null,
      offset?: number | null,
      orderBy?: string | null,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/tasks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (taskId !== undefined) {
        localVarQueryParameter['task_id'] = taskId;
      }

      if (category !== undefined) {
        localVarQueryParameter['category'] = category;
      }

      if (requester !== undefined) {
        localVarQueryParameter['requester'] = requester;
      }

      if (assignedTo !== undefined) {
        localVarQueryParameter['assigned_to'] = assignedTo;
      }

      if (status !== undefined) {
        localVarQueryParameter['status'] = status;
      }

      if (label !== undefined) {
        localVarQueryParameter['label'] = label;
      }

      if (requestTimeBetween !== undefined) {
        localVarQueryParameter['request_time_between'] = requestTimeBetween;
      }

      if (startTimeBetween !== undefined) {
        localVarQueryParameter['start_time_between'] = startTimeBetween;
      }

      if (finishTimeBetween !== undefined) {
        localVarQueryParameter['finish_time_between'] = finishTimeBetween;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['order_by'] = orderBy;
      }

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update Schedule Task
     * @param {number} taskId
     * @param {PostScheduledTaskRequest} postScheduledTaskRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateScheduleTaskScheduledTasksTaskIdUpdatePost: async (
      taskId: number,
      postScheduledTaskRequest: PostScheduledTaskRequest,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskId' is not null or undefined
      assertParamExists('updateScheduleTaskScheduledTasksTaskIdUpdatePost', 'taskId', taskId);
      // verify required parameter 'postScheduledTaskRequest' is not null or undefined
      assertParamExists(
        'updateScheduleTaskScheduledTasksTaskIdUpdatePost',
        'postScheduledTaskRequest',
        postScheduledTaskRequest,
      );
      const localVarPath = `/scheduled_tasks/{task_id}/update`.replace(
        `{${'task_id'}}`,
        encodeURIComponent(String(taskId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        postScheduledTaskRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TasksApi - functional programming interface
 * @export
 */
export const TasksApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TasksApiAxiosParamCreator(configuration);
  return {
    /**
     * Skip tasks on the excepted date
     * @summary Add Except Date
     * @param {number} taskId
     * @param {AddExceptDateRequest} addExceptDateRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addExceptDateScheduledTasksTaskIdExceptDatePost(
      taskId: number,
      addExceptDateRequest: AddExceptDateRequest,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.addExceptDateScheduledTasksTaskIdExceptDatePost(
          taskId,
          addExceptDateRequest,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.addExceptDateScheduledTasksTaskIdExceptDatePost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Del Scheduled Tasks
     * @param {number} taskId
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async delScheduledTasksScheduledTasksTaskIdDelete(
      taskId: number,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.delScheduledTasksScheduledTasksTaskIdDelete(
          taskId,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.delScheduledTasksScheduledTasksTaskIdDelete']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Delete Favorite Task
     * @param {string} favoriteTaskId
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFavoriteTaskFavoriteTasksFavoriteTaskIdDelete(
      favoriteTaskId: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteFavoriteTaskFavoriteTasksFavoriteTaskIdDelete(
          favoriteTaskId,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.deleteFavoriteTaskFavoriteTasksFavoriteTaskIdDelete']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get Favorites Tasks
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFavoritesTasksFavoriteTasksGet(
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskFavorite>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFavoritesTasksFavoriteTasksGet(
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.getFavoritesTasksFavoriteTasksGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get Scheduled Task
     * @param {number} taskId
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getScheduledTaskScheduledTasksTaskIdGet(
      taskId: number,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduledTask>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getScheduledTaskScheduledTasksTaskIdGet(
          taskId,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.getScheduledTaskScheduledTasksTaskIdGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get Scheduled Tasks
     * @param {string} startBefore Only return scheduled tasks that start before given timestamp
     * @param {string} untilAfter Only return scheduled tasks that stop after given timestamp
     * @param {number | null} [limit] defaults to 100
     * @param {number | null} [offset] defaults to 0
     * @param {string | null} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getScheduledTasksScheduledTasksGet(
      startBefore: string,
      untilAfter: string,
      limit?: number | null,
      offset?: number | null,
      orderBy?: string | null,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScheduledTask>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getScheduledTasksScheduledTasksGet(
        startBefore,
        untilAfter,
        limit,
        offset,
        orderBy,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.getScheduledTasksScheduledTasksGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get Task Booking Label
     * @param {string} taskId task_id
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTaskBookingLabelTasksTaskIdBookingLabelGet(
      taskId: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string }>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getTaskBookingLabelTasksTaskIdBookingLabelGet(
          taskId,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.getTaskBookingLabelTasksTaskIdBookingLabelGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Available in socket.io
     * @summary Get Task Log
     * @param {string} taskId task_id
     * @param {string | null} [between]              The period of request time to fetch, in unix millis.              This can be either a comma separated string or a string prefixed with \&#39;-\&#39; to fetch the last X millis.              Example:                 \&quot;1000,2000\&quot; - Fetch resources between unix millis 1000 and 2000.                 \&quot;-60000\&quot; - Fetch resources in the last minute.
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTaskLogTasksTaskIdLogGet(
      taskId: string,
      between?: string | null,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskEventLog>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskLogTasksTaskIdLogGet(
        taskId,
        between,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.getTaskLogTasksTaskIdLogGet']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get Task Request
     * @param {string} taskId task_id
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTaskRequestTasksTaskIdRequestGet(
      taskId: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskRequest>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskRequestTasksTaskIdRequestGet(
        taskId,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.getTaskRequestTasksTaskIdRequestGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Available in socket.io
     * @summary Get Task State
     * @param {string} taskId task_id
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTaskStateTasksTaskIdStateGet(
      taskId: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskStateOutput>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskStateTasksTaskIdStateGet(
        taskId,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.getTaskStateTasksTaskIdStateGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Post Activity Discovery
     * @param {ActivityDiscoveryRequest} activityDiscoveryRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postActivityDiscoveryTasksActivityDiscoveryPost(
      activityDiscoveryRequest: ActivityDiscoveryRequest,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivityDiscovery>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postActivityDiscoveryTasksActivityDiscoveryPost(
          activityDiscoveryRequest,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.postActivityDiscoveryTasksActivityDiscoveryPost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Post Cancel Task
     * @param {CancelTaskRequest} cancelTaskRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postCancelTaskTasksCancelTaskPost(
      cancelTaskRequest: CancelTaskRequest,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskCancelResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postCancelTaskTasksCancelTaskPost(
        cancelTaskRequest,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.postCancelTaskTasksCancelTaskPost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Post Dispatch Task
     * @param {DispatchTaskRequest} dispatchTaskRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postDispatchTaskTasksDispatchTaskPost(
      dispatchTaskRequest: DispatchTaskRequest,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskDispatchResponseOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postDispatchTaskTasksDispatchTaskPost(
          dispatchTaskRequest,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.postDispatchTaskTasksDispatchTaskPost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Post Favorite Task
     * @param {TaskFavorite} taskFavorite
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postFavoriteTaskFavoriteTasksPost(
      taskFavorite: TaskFavorite,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postFavoriteTaskFavoriteTasksPost(
        taskFavorite,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.postFavoriteTaskFavoriteTasksPost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Post Interrupt Task
     * @param {TaskInterruptionRequest} taskInterruptionRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postInterruptTaskTasksInterruptTaskPost(
      taskInterruptionRequest: TaskInterruptionRequest,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskInterruptionResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postInterruptTaskTasksInterruptTaskPost(
          taskInterruptionRequest,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.postInterruptTaskTasksInterruptTaskPost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Post Kill Task
     * @param {TaskKillRequest} taskKillRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postKillTaskTasksKillTaskPost(
      taskKillRequest: TaskKillRequest,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskKillResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postKillTaskTasksKillTaskPost(
        taskKillRequest,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.postKillTaskTasksKillTaskPost']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Post Resume Task
     * @param {TaskResumeRequest} taskResumeRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postResumeTaskTasksResumeTaskPost(
      taskResumeRequest: TaskResumeRequest,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResumeResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postResumeTaskTasksResumeTaskPost(
        taskResumeRequest,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.postResumeTaskTasksResumeTaskPost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Post Rewind Task
     * @param {TaskRewindRequest} taskRewindRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postRewindTaskTasksRewindTaskPost(
      taskRewindRequest: TaskRewindRequest,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskRewindResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postRewindTaskTasksRewindTaskPost(
        taskRewindRequest,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.postRewindTaskTasksRewindTaskPost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Post Robot Task
     * @param {RobotTaskRequest} robotTaskRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postRobotTaskTasksRobotTaskPost(
      robotTaskRequest: RobotTaskRequest,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RobotTaskResponseOutput>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postRobotTaskTasksRobotTaskPost(
        robotTaskRequest,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.postRobotTaskTasksRobotTaskPost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Create a scheduled task. Below are some examples of how the schedules are represented. For more examples, check the docs of the underlying library used [here](https://github.com/dbader/schedule/blob/6eb0b5346b1ce35ece5050e65789fa6e44368175/docs/examples.rst).  | every | to | period | at | description | | - | - | - | - | - | | 10 | - | minutes | - | Every 10 minutes | | - | - | hour | - | Every hour | | - | - | day | 10:30 | Every day at 10:30am | | - | - | monday | - | Every monday | | - | - | wednesday | 13:15 | Every wednesday at 01:15pm | | - | - | minute | :17 | Every 17th sec of a mintue | | 5 | 10 | seconds | - | Every 5-10 seconds (randomly) |
     * @summary Post Scheduled Task
     * @param {PostScheduledTaskRequest} postScheduledTaskRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postScheduledTaskScheduledTasksPost(
      postScheduledTaskRequest: PostScheduledTaskRequest,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduledTask>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postScheduledTaskScheduledTasksPost(
        postScheduledTaskRequest,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.postScheduledTaskScheduledTasksPost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Post Skip Phase
     * @param {TaskPhaseSkipRequest} taskPhaseSkipRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postSkipPhaseTasksSkipPhasePost(
      taskPhaseSkipRequest: TaskPhaseSkipRequest,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SkipPhaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postSkipPhaseTasksSkipPhasePost(
        taskPhaseSkipRequest,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.postSkipPhaseTasksSkipPhasePost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Post Task Discovery
     * @param {TaskDiscoveryRequest} taskDiscoveryRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postTaskDiscoveryTasksTaskDiscoveryPost(
      taskDiscoveryRequest: TaskDiscoveryRequest,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskDiscovery>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postTaskDiscoveryTasksTaskDiscoveryPost(
          taskDiscoveryRequest,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.postTaskDiscoveryTasksTaskDiscoveryPost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Post Undo Skip Phase
     * @param {UndoPhaseSkipRequest} undoPhaseSkipRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postUndoSkipPhaseTasksUndoSkipPhasePost(
      undoPhaseSkipRequest: UndoPhaseSkipRequest,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UndoPhaseSkipResponse>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postUndoSkipPhaseTasksUndoSkipPhasePost(
          undoPhaseSkipRequest,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.postUndoSkipPhaseTasksUndoSkipPhasePost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Query Task Requests
     * @param {string | null} [taskIds] comma separated list of task ids
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async queryTaskRequestsTasksRequestsGet(
      taskIds?: string | null,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskRequest>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.queryTaskRequestsTasksRequestsGet(
        taskIds,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.queryTaskRequestsTasksRequestsGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Query Task States
     * @param {string | null} [taskId] comma separated list of task ids
     * @param {string | null} [category] comma separated list of task categories
     * @param {string | null} [requester] comma separated list of requester names
     * @param {string | null} [assignedTo] comma separated list of assigned robot names
     * @param {string | null} [status] comma separated list of statuses
     * @param {string | null} [label] comma separated list of labels, each item must be in the form &lt;key&gt;&#x3D;&lt;value&gt;, multiple items will filter tasks with all the labels
     * @param {string | null} [requestTimeBetween]              The period of request time to fetch, in unix millis.              This can be either a comma separated string or a string prefixed with \&#39;-\&#39; to fetch the last X millis.              Example:                 \&quot;1000,2000\&quot; - Fetch resources between unix millis 1000 and 2000.                 \&quot;-60000\&quot; - Fetch resources in the last minute.
     * @param {string | null} [startTimeBetween]              The period of request time to fetch, in unix millis.              This can be either a comma separated string or a string prefixed with \&#39;-\&#39; to fetch the last X millis.              Example:                 \&quot;1000,2000\&quot; - Fetch resources between unix millis 1000 and 2000.                 \&quot;-60000\&quot; - Fetch resources in the last minute.
     * @param {string | null} [finishTimeBetween]              The period of request time to fetch, in unix millis.              This can be either a comma separated string or a string prefixed with \&#39;-\&#39; to fetch the last X millis.              Example:                 \&quot;1000,2000\&quot; - Fetch resources between unix millis 1000 and 2000.                 \&quot;-60000\&quot; - Fetch resources in the last minute.
     * @param {number | null} [limit] defaults to 100
     * @param {number | null} [offset] defaults to 0
     * @param {string | null} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async queryTaskStatesTasksGet(
      taskId?: string | null,
      category?: string | null,
      requester?: string | null,
      assignedTo?: string | null,
      status?: string | null,
      label?: string | null,
      requestTimeBetween?: string | null,
      startTimeBetween?: string | null,
      finishTimeBetween?: string | null,
      limit?: number | null,
      offset?: number | null,
      orderBy?: string | null,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskStateOutput>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.queryTaskStatesTasksGet(
        taskId,
        category,
        requester,
        assignedTo,
        status,
        label,
        requestTimeBetween,
        startTimeBetween,
        finishTimeBetween,
        limit,
        offset,
        orderBy,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.queryTaskStatesTasksGet']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Update Schedule Task
     * @param {number} taskId
     * @param {PostScheduledTaskRequest} postScheduledTaskRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateScheduleTaskScheduledTasksTaskIdUpdatePost(
      taskId: number,
      postScheduledTaskRequest: PostScheduledTaskRequest,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduledTask>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateScheduleTaskScheduledTasksTaskIdUpdatePost(
          taskId,
          postScheduledTaskRequest,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.updateScheduleTaskScheduledTasksTaskIdUpdatePost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * TasksApi - factory interface
 * @export
 */
export const TasksApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = TasksApiFp(configuration);
  return {
    /**
     * Skip tasks on the excepted date
     * @summary Add Except Date
     * @param {number} taskId
     * @param {AddExceptDateRequest} addExceptDateRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addExceptDateScheduledTasksTaskIdExceptDatePost(
      taskId: number,
      addExceptDateRequest: AddExceptDateRequest,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .addExceptDateScheduledTasksTaskIdExceptDatePost(
          taskId,
          addExceptDateRequest,
          authorization,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Del Scheduled Tasks
     * @param {number} taskId
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    delScheduledTasksScheduledTasksTaskIdDelete(
      taskId: number,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .delScheduledTasksScheduledTasksTaskIdDelete(taskId, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete Favorite Task
     * @param {string} favoriteTaskId
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFavoriteTaskFavoriteTasksFavoriteTaskIdDelete(
      favoriteTaskId: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .deleteFavoriteTaskFavoriteTasksFavoriteTaskIdDelete(favoriteTaskId, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Favorites Tasks
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFavoritesTasksFavoriteTasksGet(
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<Array<TaskFavorite>> {
      return localVarFp
        .getFavoritesTasksFavoriteTasksGet(authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Scheduled Task
     * @param {number} taskId
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getScheduledTaskScheduledTasksTaskIdGet(
      taskId: number,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<ScheduledTask> {
      return localVarFp
        .getScheduledTaskScheduledTasksTaskIdGet(taskId, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Scheduled Tasks
     * @param {string} startBefore Only return scheduled tasks that start before given timestamp
     * @param {string} untilAfter Only return scheduled tasks that stop after given timestamp
     * @param {number | null} [limit] defaults to 100
     * @param {number | null} [offset] defaults to 0
     * @param {string | null} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getScheduledTasksScheduledTasksGet(
      startBefore: string,
      untilAfter: string,
      limit?: number | null,
      offset?: number | null,
      orderBy?: string | null,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<Array<ScheduledTask>> {
      return localVarFp
        .getScheduledTasksScheduledTasksGet(
          startBefore,
          untilAfter,
          limit,
          offset,
          orderBy,
          authorization,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Task Booking Label
     * @param {string} taskId task_id
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskBookingLabelTasksTaskIdBookingLabelGet(
      taskId: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<{ [key: string]: string }> {
      return localVarFp
        .getTaskBookingLabelTasksTaskIdBookingLabelGet(taskId, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Available in socket.io
     * @summary Get Task Log
     * @param {string} taskId task_id
     * @param {string | null} [between]              The period of request time to fetch, in unix millis.              This can be either a comma separated string or a string prefixed with \&#39;-\&#39; to fetch the last X millis.              Example:                 \&quot;1000,2000\&quot; - Fetch resources between unix millis 1000 and 2000.                 \&quot;-60000\&quot; - Fetch resources in the last minute.
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskLogTasksTaskIdLogGet(
      taskId: string,
      between?: string | null,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<TaskEventLog> {
      return localVarFp
        .getTaskLogTasksTaskIdLogGet(taskId, between, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Task Request
     * @param {string} taskId task_id
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskRequestTasksTaskIdRequestGet(
      taskId: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<TaskRequest> {
      return localVarFp
        .getTaskRequestTasksTaskIdRequestGet(taskId, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Available in socket.io
     * @summary Get Task State
     * @param {string} taskId task_id
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskStateTasksTaskIdStateGet(
      taskId: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<TaskStateOutput> {
      return localVarFp
        .getTaskStateTasksTaskIdStateGet(taskId, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Post Activity Discovery
     * @param {ActivityDiscoveryRequest} activityDiscoveryRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postActivityDiscoveryTasksActivityDiscoveryPost(
      activityDiscoveryRequest: ActivityDiscoveryRequest,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<ActivityDiscovery> {
      return localVarFp
        .postActivityDiscoveryTasksActivityDiscoveryPost(
          activityDiscoveryRequest,
          authorization,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Post Cancel Task
     * @param {CancelTaskRequest} cancelTaskRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postCancelTaskTasksCancelTaskPost(
      cancelTaskRequest: CancelTaskRequest,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<TaskCancelResponse> {
      return localVarFp
        .postCancelTaskTasksCancelTaskPost(cancelTaskRequest, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Post Dispatch Task
     * @param {DispatchTaskRequest} dispatchTaskRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postDispatchTaskTasksDispatchTaskPost(
      dispatchTaskRequest: DispatchTaskRequest,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<TaskDispatchResponseOutput> {
      return localVarFp
        .postDispatchTaskTasksDispatchTaskPost(dispatchTaskRequest, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Post Favorite Task
     * @param {TaskFavorite} taskFavorite
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postFavoriteTaskFavoriteTasksPost(
      taskFavorite: TaskFavorite,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .postFavoriteTaskFavoriteTasksPost(taskFavorite, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Post Interrupt Task
     * @param {TaskInterruptionRequest} taskInterruptionRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postInterruptTaskTasksInterruptTaskPost(
      taskInterruptionRequest: TaskInterruptionRequest,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<TaskInterruptionResponse> {
      return localVarFp
        .postInterruptTaskTasksInterruptTaskPost(taskInterruptionRequest, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Post Kill Task
     * @param {TaskKillRequest} taskKillRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postKillTaskTasksKillTaskPost(
      taskKillRequest: TaskKillRequest,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<TaskKillResponse> {
      return localVarFp
        .postKillTaskTasksKillTaskPost(taskKillRequest, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Post Resume Task
     * @param {TaskResumeRequest} taskResumeRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postResumeTaskTasksResumeTaskPost(
      taskResumeRequest: TaskResumeRequest,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<TaskResumeResponse> {
      return localVarFp
        .postResumeTaskTasksResumeTaskPost(taskResumeRequest, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Post Rewind Task
     * @param {TaskRewindRequest} taskRewindRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postRewindTaskTasksRewindTaskPost(
      taskRewindRequest: TaskRewindRequest,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<TaskRewindResponse> {
      return localVarFp
        .postRewindTaskTasksRewindTaskPost(taskRewindRequest, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Post Robot Task
     * @param {RobotTaskRequest} robotTaskRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postRobotTaskTasksRobotTaskPost(
      robotTaskRequest: RobotTaskRequest,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<RobotTaskResponseOutput> {
      return localVarFp
        .postRobotTaskTasksRobotTaskPost(robotTaskRequest, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a scheduled task. Below are some examples of how the schedules are represented. For more examples, check the docs of the underlying library used [here](https://github.com/dbader/schedule/blob/6eb0b5346b1ce35ece5050e65789fa6e44368175/docs/examples.rst).  | every | to | period | at | description | | - | - | - | - | - | | 10 | - | minutes | - | Every 10 minutes | | - | - | hour | - | Every hour | | - | - | day | 10:30 | Every day at 10:30am | | - | - | monday | - | Every monday | | - | - | wednesday | 13:15 | Every wednesday at 01:15pm | | - | - | minute | :17 | Every 17th sec of a mintue | | 5 | 10 | seconds | - | Every 5-10 seconds (randomly) |
     * @summary Post Scheduled Task
     * @param {PostScheduledTaskRequest} postScheduledTaskRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postScheduledTaskScheduledTasksPost(
      postScheduledTaskRequest: PostScheduledTaskRequest,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<ScheduledTask> {
      return localVarFp
        .postScheduledTaskScheduledTasksPost(postScheduledTaskRequest, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Post Skip Phase
     * @param {TaskPhaseSkipRequest} taskPhaseSkipRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postSkipPhaseTasksSkipPhasePost(
      taskPhaseSkipRequest: TaskPhaseSkipRequest,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<SkipPhaseResponse> {
      return localVarFp
        .postSkipPhaseTasksSkipPhasePost(taskPhaseSkipRequest, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Post Task Discovery
     * @param {TaskDiscoveryRequest} taskDiscoveryRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postTaskDiscoveryTasksTaskDiscoveryPost(
      taskDiscoveryRequest: TaskDiscoveryRequest,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<TaskDiscovery> {
      return localVarFp
        .postTaskDiscoveryTasksTaskDiscoveryPost(taskDiscoveryRequest, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Post Undo Skip Phase
     * @param {UndoPhaseSkipRequest} undoPhaseSkipRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUndoSkipPhaseTasksUndoSkipPhasePost(
      undoPhaseSkipRequest: UndoPhaseSkipRequest,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<UndoPhaseSkipResponse> {
      return localVarFp
        .postUndoSkipPhaseTasksUndoSkipPhasePost(undoPhaseSkipRequest, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Query Task Requests
     * @param {string | null} [taskIds] comma separated list of task ids
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryTaskRequestsTasksRequestsGet(
      taskIds?: string | null,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<Array<TaskRequest>> {
      return localVarFp
        .queryTaskRequestsTasksRequestsGet(taskIds, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Query Task States
     * @param {string | null} [taskId] comma separated list of task ids
     * @param {string | null} [category] comma separated list of task categories
     * @param {string | null} [requester] comma separated list of requester names
     * @param {string | null} [assignedTo] comma separated list of assigned robot names
     * @param {string | null} [status] comma separated list of statuses
     * @param {string | null} [label] comma separated list of labels, each item must be in the form &lt;key&gt;&#x3D;&lt;value&gt;, multiple items will filter tasks with all the labels
     * @param {string | null} [requestTimeBetween]              The period of request time to fetch, in unix millis.              This can be either a comma separated string or a string prefixed with \&#39;-\&#39; to fetch the last X millis.              Example:                 \&quot;1000,2000\&quot; - Fetch resources between unix millis 1000 and 2000.                 \&quot;-60000\&quot; - Fetch resources in the last minute.
     * @param {string | null} [startTimeBetween]              The period of request time to fetch, in unix millis.              This can be either a comma separated string or a string prefixed with \&#39;-\&#39; to fetch the last X millis.              Example:                 \&quot;1000,2000\&quot; - Fetch resources between unix millis 1000 and 2000.                 \&quot;-60000\&quot; - Fetch resources in the last minute.
     * @param {string | null} [finishTimeBetween]              The period of request time to fetch, in unix millis.              This can be either a comma separated string or a string prefixed with \&#39;-\&#39; to fetch the last X millis.              Example:                 \&quot;1000,2000\&quot; - Fetch resources between unix millis 1000 and 2000.                 \&quot;-60000\&quot; - Fetch resources in the last minute.
     * @param {number | null} [limit] defaults to 100
     * @param {number | null} [offset] defaults to 0
     * @param {string | null} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryTaskStatesTasksGet(
      taskId?: string | null,
      category?: string | null,
      requester?: string | null,
      assignedTo?: string | null,
      status?: string | null,
      label?: string | null,
      requestTimeBetween?: string | null,
      startTimeBetween?: string | null,
      finishTimeBetween?: string | null,
      limit?: number | null,
      offset?: number | null,
      orderBy?: string | null,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<Array<TaskStateOutput>> {
      return localVarFp
        .queryTaskStatesTasksGet(
          taskId,
          category,
          requester,
          assignedTo,
          status,
          label,
          requestTimeBetween,
          startTimeBetween,
          finishTimeBetween,
          limit,
          offset,
          orderBy,
          authorization,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update Schedule Task
     * @param {number} taskId
     * @param {PostScheduledTaskRequest} postScheduledTaskRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateScheduleTaskScheduledTasksTaskIdUpdatePost(
      taskId: number,
      postScheduledTaskRequest: PostScheduledTaskRequest,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<ScheduledTask> {
      return localVarFp
        .updateScheduleTaskScheduledTasksTaskIdUpdatePost(
          taskId,
          postScheduledTaskRequest,
          authorization,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
export class TasksApi extends BaseAPI {
  /**
   * Skip tasks on the excepted date
   * @summary Add Except Date
   * @param {number} taskId
   * @param {AddExceptDateRequest} addExceptDateRequest
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public addExceptDateScheduledTasksTaskIdExceptDatePost(
    taskId: number,
    addExceptDateRequest: AddExceptDateRequest,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .addExceptDateScheduledTasksTaskIdExceptDatePost(
        taskId,
        addExceptDateRequest,
        authorization,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Del Scheduled Tasks
   * @param {number} taskId
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public delScheduledTasksScheduledTasksTaskIdDelete(
    taskId: number,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .delScheduledTasksScheduledTasksTaskIdDelete(taskId, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete Favorite Task
   * @param {string} favoriteTaskId
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public deleteFavoriteTaskFavoriteTasksFavoriteTaskIdDelete(
    favoriteTaskId: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .deleteFavoriteTaskFavoriteTasksFavoriteTaskIdDelete(favoriteTaskId, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Favorites Tasks
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public getFavoritesTasksFavoriteTasksGet(
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .getFavoritesTasksFavoriteTasksGet(authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Scheduled Task
   * @param {number} taskId
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public getScheduledTaskScheduledTasksTaskIdGet(
    taskId: number,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .getScheduledTaskScheduledTasksTaskIdGet(taskId, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Scheduled Tasks
   * @param {string} startBefore Only return scheduled tasks that start before given timestamp
   * @param {string} untilAfter Only return scheduled tasks that stop after given timestamp
   * @param {number | null} [limit] defaults to 100
   * @param {number | null} [offset] defaults to 0
   * @param {string | null} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public getScheduledTasksScheduledTasksGet(
    startBefore: string,
    untilAfter: string,
    limit?: number | null,
    offset?: number | null,
    orderBy?: string | null,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .getScheduledTasksScheduledTasksGet(
        startBefore,
        untilAfter,
        limit,
        offset,
        orderBy,
        authorization,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Task Booking Label
   * @param {string} taskId task_id
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public getTaskBookingLabelTasksTaskIdBookingLabelGet(
    taskId: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .getTaskBookingLabelTasksTaskIdBookingLabelGet(taskId, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Available in socket.io
   * @summary Get Task Log
   * @param {string} taskId task_id
   * @param {string | null} [between]              The period of request time to fetch, in unix millis.              This can be either a comma separated string or a string prefixed with \&#39;-\&#39; to fetch the last X millis.              Example:                 \&quot;1000,2000\&quot; - Fetch resources between unix millis 1000 and 2000.                 \&quot;-60000\&quot; - Fetch resources in the last minute.
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public getTaskLogTasksTaskIdLogGet(
    taskId: string,
    between?: string | null,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .getTaskLogTasksTaskIdLogGet(taskId, between, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Task Request
   * @param {string} taskId task_id
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public getTaskRequestTasksTaskIdRequestGet(
    taskId: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .getTaskRequestTasksTaskIdRequestGet(taskId, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Available in socket.io
   * @summary Get Task State
   * @param {string} taskId task_id
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public getTaskStateTasksTaskIdStateGet(
    taskId: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .getTaskStateTasksTaskIdStateGet(taskId, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Post Activity Discovery
   * @param {ActivityDiscoveryRequest} activityDiscoveryRequest
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public postActivityDiscoveryTasksActivityDiscoveryPost(
    activityDiscoveryRequest: ActivityDiscoveryRequest,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .postActivityDiscoveryTasksActivityDiscoveryPost(
        activityDiscoveryRequest,
        authorization,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Post Cancel Task
   * @param {CancelTaskRequest} cancelTaskRequest
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public postCancelTaskTasksCancelTaskPost(
    cancelTaskRequest: CancelTaskRequest,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .postCancelTaskTasksCancelTaskPost(cancelTaskRequest, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Post Dispatch Task
   * @param {DispatchTaskRequest} dispatchTaskRequest
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public postDispatchTaskTasksDispatchTaskPost(
    dispatchTaskRequest: DispatchTaskRequest,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .postDispatchTaskTasksDispatchTaskPost(dispatchTaskRequest, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Post Favorite Task
   * @param {TaskFavorite} taskFavorite
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public postFavoriteTaskFavoriteTasksPost(
    taskFavorite: TaskFavorite,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .postFavoriteTaskFavoriteTasksPost(taskFavorite, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Post Interrupt Task
   * @param {TaskInterruptionRequest} taskInterruptionRequest
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public postInterruptTaskTasksInterruptTaskPost(
    taskInterruptionRequest: TaskInterruptionRequest,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .postInterruptTaskTasksInterruptTaskPost(taskInterruptionRequest, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Post Kill Task
   * @param {TaskKillRequest} taskKillRequest
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public postKillTaskTasksKillTaskPost(
    taskKillRequest: TaskKillRequest,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .postKillTaskTasksKillTaskPost(taskKillRequest, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Post Resume Task
   * @param {TaskResumeRequest} taskResumeRequest
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public postResumeTaskTasksResumeTaskPost(
    taskResumeRequest: TaskResumeRequest,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .postResumeTaskTasksResumeTaskPost(taskResumeRequest, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Post Rewind Task
   * @param {TaskRewindRequest} taskRewindRequest
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public postRewindTaskTasksRewindTaskPost(
    taskRewindRequest: TaskRewindRequest,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .postRewindTaskTasksRewindTaskPost(taskRewindRequest, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Post Robot Task
   * @param {RobotTaskRequest} robotTaskRequest
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public postRobotTaskTasksRobotTaskPost(
    robotTaskRequest: RobotTaskRequest,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .postRobotTaskTasksRobotTaskPost(robotTaskRequest, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a scheduled task. Below are some examples of how the schedules are represented. For more examples, check the docs of the underlying library used [here](https://github.com/dbader/schedule/blob/6eb0b5346b1ce35ece5050e65789fa6e44368175/docs/examples.rst).  | every | to | period | at | description | | - | - | - | - | - | | 10 | - | minutes | - | Every 10 minutes | | - | - | hour | - | Every hour | | - | - | day | 10:30 | Every day at 10:30am | | - | - | monday | - | Every monday | | - | - | wednesday | 13:15 | Every wednesday at 01:15pm | | - | - | minute | :17 | Every 17th sec of a mintue | | 5 | 10 | seconds | - | Every 5-10 seconds (randomly) |
   * @summary Post Scheduled Task
   * @param {PostScheduledTaskRequest} postScheduledTaskRequest
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public postScheduledTaskScheduledTasksPost(
    postScheduledTaskRequest: PostScheduledTaskRequest,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .postScheduledTaskScheduledTasksPost(postScheduledTaskRequest, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Post Skip Phase
   * @param {TaskPhaseSkipRequest} taskPhaseSkipRequest
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public postSkipPhaseTasksSkipPhasePost(
    taskPhaseSkipRequest: TaskPhaseSkipRequest,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .postSkipPhaseTasksSkipPhasePost(taskPhaseSkipRequest, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Post Task Discovery
   * @param {TaskDiscoveryRequest} taskDiscoveryRequest
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public postTaskDiscoveryTasksTaskDiscoveryPost(
    taskDiscoveryRequest: TaskDiscoveryRequest,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .postTaskDiscoveryTasksTaskDiscoveryPost(taskDiscoveryRequest, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Post Undo Skip Phase
   * @param {UndoPhaseSkipRequest} undoPhaseSkipRequest
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public postUndoSkipPhaseTasksUndoSkipPhasePost(
    undoPhaseSkipRequest: UndoPhaseSkipRequest,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .postUndoSkipPhaseTasksUndoSkipPhasePost(undoPhaseSkipRequest, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Query Task Requests
   * @param {string | null} [taskIds] comma separated list of task ids
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public queryTaskRequestsTasksRequestsGet(
    taskIds?: string | null,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .queryTaskRequestsTasksRequestsGet(taskIds, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Query Task States
   * @param {string | null} [taskId] comma separated list of task ids
   * @param {string | null} [category] comma separated list of task categories
   * @param {string | null} [requester] comma separated list of requester names
   * @param {string | null} [assignedTo] comma separated list of assigned robot names
   * @param {string | null} [status] comma separated list of statuses
   * @param {string | null} [label] comma separated list of labels, each item must be in the form &lt;key&gt;&#x3D;&lt;value&gt;, multiple items will filter tasks with all the labels
   * @param {string | null} [requestTimeBetween]              The period of request time to fetch, in unix millis.              This can be either a comma separated string or a string prefixed with \&#39;-\&#39; to fetch the last X millis.              Example:                 \&quot;1000,2000\&quot; - Fetch resources between unix millis 1000 and 2000.                 \&quot;-60000\&quot; - Fetch resources in the last minute.
   * @param {string | null} [startTimeBetween]              The period of request time to fetch, in unix millis.              This can be either a comma separated string or a string prefixed with \&#39;-\&#39; to fetch the last X millis.              Example:                 \&quot;1000,2000\&quot; - Fetch resources between unix millis 1000 and 2000.                 \&quot;-60000\&quot; - Fetch resources in the last minute.
   * @param {string | null} [finishTimeBetween]              The period of request time to fetch, in unix millis.              This can be either a comma separated string or a string prefixed with \&#39;-\&#39; to fetch the last X millis.              Example:                 \&quot;1000,2000\&quot; - Fetch resources between unix millis 1000 and 2000.                 \&quot;-60000\&quot; - Fetch resources in the last minute.
   * @param {number | null} [limit] defaults to 100
   * @param {number | null} [offset] defaults to 0
   * @param {string | null} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public queryTaskStatesTasksGet(
    taskId?: string | null,
    category?: string | null,
    requester?: string | null,
    assignedTo?: string | null,
    status?: string | null,
    label?: string | null,
    requestTimeBetween?: string | null,
    startTimeBetween?: string | null,
    finishTimeBetween?: string | null,
    limit?: number | null,
    offset?: number | null,
    orderBy?: string | null,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .queryTaskStatesTasksGet(
        taskId,
        category,
        requester,
        assignedTo,
        status,
        label,
        requestTimeBetween,
        startTimeBetween,
        finishTimeBetween,
        limit,
        offset,
        orderBy,
        authorization,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update Schedule Task
   * @param {number} taskId
   * @param {PostScheduledTaskRequest} postScheduledTaskRequest
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public updateScheduleTaskScheduledTasksTaskIdUpdatePost(
    taskId: number,
    postScheduledTaskRequest: PostScheduledTaskRequest,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .updateScheduleTaskScheduledTasksTaskIdUpdatePost(
        taskId,
        postScheduledTaskRequest,
        authorization,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}
