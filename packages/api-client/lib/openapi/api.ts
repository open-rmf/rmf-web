/* tslint:disable */
/* eslint-disable */
/**
 * RMF API Server
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface Activity
 */
export interface Activity {
  /**
   * The category of this activity. There must not be any duplicate activity categories per fleet.
   * @type {string}
   * @memberof Activity
   */
  category: string;
  /**
   * Details about the behavior of the activity.
   * @type {string}
   * @memberof Activity
   */
  detail: string;
  /**
   * The schema for this activity description
   * @type {object}
   * @memberof Activity
   */
  description_schema?: object;
}
/**
 *
 * @export
 * @interface ActivityDiscovery
 */
export interface ActivityDiscovery {
  /**
   *
   * @type {Array<Datum>}
   * @memberof ActivityDiscovery
   */
  data?: Array<Datum>;
}
/**
 *
 * @export
 * @interface ActivityDiscoveryRequest
 */
export interface ActivityDiscoveryRequest {
  /**
   * Indicate that this is an activity discovery request
   * @type {string}
   * @memberof ActivityDiscoveryRequest
   */
  type: ActivityDiscoveryRequestTypeEnum;
}

export const ActivityDiscoveryRequestTypeEnum = {
  ActivitiyDiscoveryRequest: 'activitiy_discovery_request',
} as const;

export type ActivityDiscoveryRequestTypeEnum =
  typeof ActivityDiscoveryRequestTypeEnum[keyof typeof ActivityDiscoveryRequestTypeEnum];

/**
 *
 * @export
 * @interface AffineImage
 */
export interface AffineImage {
  /**
   *
   * @type {string}
   * @memberof AffineImage
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof AffineImage
   */
  x_offset: number;
  /**
   *
   * @type {number}
   * @memberof AffineImage
   */
  y_offset: number;
  /**
   *
   * @type {number}
   * @memberof AffineImage
   */
  yaw: number;
  /**
   *
   * @type {number}
   * @memberof AffineImage
   */
  scale: number;
  /**
   *
   * @type {string}
   * @memberof AffineImage
   */
  encoding: string;
  /**
   *
   * @type {string}
   * @memberof AffineImage
   */
  data: string;
}
/**
 *
 * @export
 * @interface ApiServerModelsRmfApiFleetLogFleetState
 */
export interface ApiServerModelsRmfApiFleetLogFleetState {
  /**
   *
   * @type {string}
   * @memberof ApiServerModelsRmfApiFleetLogFleetState
   */
  name?: string;
  /**
   * Log for the overall fleet
   * @type {Array<LogEntry>}
   * @memberof ApiServerModelsRmfApiFleetLogFleetState
   */
  log?: Array<LogEntry>;
  /**
   * Dictionary of logs for the individual robots. The keys (property names) are the robot names.
   * @type {{ [key: string]: Array<LogEntry>; }}
   * @memberof ApiServerModelsRmfApiFleetLogFleetState
   */
  robots?: { [key: string]: Array<LogEntry> };
}
/**
 *
 * @export
 * @interface ApiServerModelsRmfApiFleetStateFleetState
 */
export interface ApiServerModelsRmfApiFleetStateFleetState {
  /**
   *
   * @type {string}
   * @memberof ApiServerModelsRmfApiFleetStateFleetState
   */
  name?: string;
  /**
   * A dictionary of the states of the robots that belong to this fleet
   * @type {{ [key: string]: RobotState; }}
   * @memberof ApiServerModelsRmfApiFleetStateFleetState
   */
  robots?: { [key: string]: RobotState };
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
export type ApiServerModelsRmfApiSimpleResponseFailure = false;

/**
 * An enumeration.
 * @export
 * @enum {string}
 */
export type ApiServerModelsRmfApiSimpleResponseSuccess = true;

/**
 * An enumeration.
 * @export
 * @enum {string}
 */
export type ApiServerModelsRmfApiTokenResponseFailure = false;

/**
 * An enumeration.
 * @export
 * @enum {string}
 */
export type ApiServerModelsRmfApiTokenResponseSuccess = true;

/**
 * General alert that can be triggered by events.
 * @export
 * @interface ApiServerModelsTortoiseModelsAlertsAlertLeaf
 */
export interface ApiServerModelsTortoiseModelsAlertsAlertLeaf {
  /**
   *
   * @type {string}
   * @memberof ApiServerModelsTortoiseModelsAlertsAlertLeaf
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof ApiServerModelsTortoiseModelsAlertsAlertLeaf
   */
  original_id: string;
  /**
   * Default: default<br/>Task: task<br/>Fleet: fleet<br/>Robot: robot
   * @type {string}
   * @memberof ApiServerModelsTortoiseModelsAlertsAlertLeaf
   */
  category: string;
  /**
   *
   * @type {number}
   * @memberof ApiServerModelsTortoiseModelsAlertsAlertLeaf
   */
  unix_millis_created_time: number;
  /**
   *
   * @type {string}
   * @memberof ApiServerModelsTortoiseModelsAlertsAlertLeaf
   */
  acknowledged_by?: string | null;
  /**
   *
   * @type {number}
   * @memberof ApiServerModelsTortoiseModelsAlertsAlertLeaf
   */
  unix_millis_acknowledged_time?: number | null;
}
/**
 *
 * @export
 * @interface ApiServerModelsTortoiseModelsBeaconsBeaconStateLeaf
 */
export interface ApiServerModelsTortoiseModelsBeaconsBeaconStateLeaf {
  /**
   *
   * @type {string}
   * @memberof ApiServerModelsTortoiseModelsBeaconsBeaconStateLeaf
   */
  id: string;
  /**
   *
   * @type {boolean}
   * @memberof ApiServerModelsTortoiseModelsBeaconsBeaconStateLeaf
   */
  online: boolean;
  /**
   *
   * @type {string}
   * @memberof ApiServerModelsTortoiseModelsBeaconsBeaconStateLeaf
   */
  category?: string | null;
  /**
   *
   * @type {boolean}
   * @memberof ApiServerModelsTortoiseModelsBeaconsBeaconStateLeaf
   */
  activated: boolean;
  /**
   *
   * @type {string}
   * @memberof ApiServerModelsTortoiseModelsBeaconsBeaconStateLeaf
   */
  level?: string | null;
}
/**
 *
 * @export
 * @interface ApiServerModelsTortoiseModelsScheduledTaskScheduledTask
 */
export interface ApiServerModelsTortoiseModelsScheduledTaskScheduledTask {
  /**
   *
   * @type {number}
   * @memberof ApiServerModelsTortoiseModelsScheduledTaskScheduledTask
   */
  id: number;
  /**
   *
   * @type {any}
   * @memberof ApiServerModelsTortoiseModelsScheduledTaskScheduledTask
   */
  task_request?: any;
  /**
   *
   * @type {string}
   * @memberof ApiServerModelsTortoiseModelsScheduledTaskScheduledTask
   */
  created_by: string;
  /**
   *
   * @type {string}
   * @memberof ApiServerModelsTortoiseModelsScheduledTaskScheduledTask
   */
  last_ran?: string | null;
  /**
   *
   * @type {any}
   * @memberof ApiServerModelsTortoiseModelsScheduledTaskScheduledTask
   */
  except_dates?: any;
  /**
   *
   * @type {Array<ApiServerModelsTortoiseModelsScheduledTaskScheduledTaskScheduleLeaf>}
   * @memberof ApiServerModelsTortoiseModelsScheduledTaskScheduledTask
   */
  schedules: Array<ApiServerModelsTortoiseModelsScheduledTaskScheduledTaskScheduleLeaf>;
}
/**
 * The schedules for a scheduled task request.<br/>A scheduled task may have multiple schedules.
 * @export
 * @interface ApiServerModelsTortoiseModelsScheduledTaskScheduledTaskScheduleLeaf
 */
export interface ApiServerModelsTortoiseModelsScheduledTaskScheduledTaskScheduleLeaf {
  /**
   *
   * @type {number}
   * @memberof ApiServerModelsTortoiseModelsScheduledTaskScheduledTaskScheduleLeaf
   */
  every?: number | null;
  /**
   *
   * @type {string}
   * @memberof ApiServerModelsTortoiseModelsScheduledTaskScheduledTaskScheduleLeaf
   */
  start_from?: string | null;
  /**
   *
   * @type {string}
   * @memberof ApiServerModelsTortoiseModelsScheduledTaskScheduledTaskScheduleLeaf
   */
  until?: string | null;
  /**
   * Monday: monday<br/>Tuesday: tuesday<br/>Wednesday: wednesday<br/>Thursday: thursday<br/>Friday: friday<br/>Saturday: saturday<br/>Sunday: sunday<br/>Day: day<br/>Hour: hour<br/>Minute: minute
   * @type {string}
   * @memberof ApiServerModelsTortoiseModelsScheduledTaskScheduledTaskScheduleLeaf
   */
  period: string;
  /**
   *
   * @type {string}
   * @memberof ApiServerModelsTortoiseModelsScheduledTaskScheduledTaskScheduleLeaf
   */
  at?: string | null;
}
/**
 *
 * @export
 * @interface ApiServerModelsTortoiseModelsTasksTaskFavoriteLeaf
 */
export interface ApiServerModelsTortoiseModelsTasksTaskFavoriteLeaf {
  /**
   *
   * @type {string}
   * @memberof ApiServerModelsTortoiseModelsTasksTaskFavoriteLeaf
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof ApiServerModelsTortoiseModelsTasksTaskFavoriteLeaf
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof ApiServerModelsTortoiseModelsTasksTaskFavoriteLeaf
   */
  unix_millis_earliest_start_time?: string | null;
  /**
   *
   * @type {any}
   * @memberof ApiServerModelsTortoiseModelsTasksTaskFavoriteLeaf
   */
  priority?: any;
  /**
   *
   * @type {string}
   * @memberof ApiServerModelsTortoiseModelsTasksTaskFavoriteLeaf
   */
  category: string;
  /**
   *
   * @type {any}
   * @memberof ApiServerModelsTortoiseModelsTasksTaskFavoriteLeaf
   */
  description?: any;
  /**
   *
   * @type {string}
   * @memberof ApiServerModelsTortoiseModelsTasksTaskFavoriteLeaf
   */
  user: string;
}
/**
 * Which agent (robot) is the task assigned to
 * @export
 * @interface AssignedTo
 */
export interface AssignedTo {
  /**
   *
   * @type {string}
   * @memberof AssignedTo
   */
  group: string;
  /**
   *
   * @type {string}
   * @memberof AssignedTo
   */
  name: string;
}
/**
 *
 * @export
 * @interface Assignment
 */
export interface Assignment {
  /**
   *
   * @type {string}
   * @memberof Assignment
   */
  fleet_name?: string;
  /**
   *
   * @type {string}
   * @memberof Assignment
   */
  expected_robot_name?: string;
}
/**
 *
 * @export
 * @interface Booking
 */
export interface Booking {
  /**
   * The unique identifier for this task
   * @type {string}
   * @memberof Booking
   */
  id: string;
  /**
   *
   * @type {number}
   * @memberof Booking
   */
  unix_millis_earliest_start_time?: number;
  /**
   *
   * @type {number}
   * @memberof Booking
   */
  unix_millis_request_time?: number;
  /**
   *
   * @type {Priority}
   * @memberof Booking
   */
  priority?: Priority;
  /**
   * Information about how and why this task was booked
   * @type {Array<string>}
   * @memberof Booking
   */
  labels?: Array<string>;
  /**
   * (Optional) An identifier for the entity that requested this task
   * @type {string}
   * @memberof Booking
   */
  requester?: string;
}
/**
 *
 * @export
 * @interface BuildingMap
 */
export interface BuildingMap {
  /**
   *
   * @type {string}
   * @memberof BuildingMap
   */
  name: string;
  /**
   *
   * @type {Array<Level>}
   * @memberof BuildingMap
   */
  levels: Array<Level>;
  /**
   *
   * @type {Array<Lift>}
   * @memberof BuildingMap
   */
  lifts: Array<Lift>;
}
/**
 *
 * @export
 * @interface CancelTaskRequest
 */
export interface CancelTaskRequest {
  /**
   * Indicate that this is a task cancellation request
   * @type {string}
   * @memberof CancelTaskRequest
   */
  type: CancelTaskRequestTypeEnum;
  /**
   * Specify the task ID to cancel
   * @type {string}
   * @memberof CancelTaskRequest
   */
  task_id: string;
  /**
   * Labels to describe the purpose of the cancellation
   * @type {Array<string>}
   * @memberof CancelTaskRequest
   */
  labels?: Array<string>;
}

export const CancelTaskRequestTypeEnum = {
  CancelTaskRequest: 'cancel_task_request',
} as const;

export type CancelTaskRequestTypeEnum =
  typeof CancelTaskRequestTypeEnum[keyof typeof CancelTaskRequestTypeEnum];

/**
 *
 * @export
 * @interface Cancellation
 */
export interface Cancellation {
  /**
   * The time that the cancellation request arrived
   * @type {number}
   * @memberof Cancellation
   */
  unix_millis_request_time: number;
  /**
   * Labels to describe the cancel request
   * @type {Array<string>}
   * @memberof Cancellation
   */
  labels: Array<string>;
}
/**
 * If the task was cancelled, this will describe information about the request.
 * @export
 * @interface Cancellation1
 */
export interface Cancellation1 {
  /**
   * The time that the cancellation request arrived
   * @type {number}
   * @memberof Cancellation1
   */
  unix_millis_request_time: number;
  /**
   * Labels to describe the cancel request
   * @type {Array<string>}
   * @memberof Cancellation1
   */
  labels: Array<string>;
}
/**
 *
 * @export
 * @interface CurrentMode
 */
export interface CurrentMode {
  /**
   *
   * @type {number}
   * @memberof CurrentMode
   */
  value: number;
}
/**
 *
 * @export
 * @interface Data
 */
export interface Data {
  /**
   * Name of the fleet that supports these tasks
   * @type {string}
   * @memberof Data
   */
  fleet_name?: string;
  /**
   * (list:replace) List of tasks that the fleet supports
   * @type {Array<Task>}
   * @memberof Data
   */
  tasks?: Array<Task>;
}
/**
 *
 * @export
 * @interface Datum
 */
export interface Datum {
  /**
   * Name of the fleet that supports these activities
   * @type {string}
   * @memberof Datum
   */
  fleet_name: string;
  /**
   * List of activities that the fleet supports
   * @type {Array<Activity>}
   * @memberof Datum
   */
  activities: Array<Activity>;
}
/**
 * Detailed information about a task, phase, or event
 * @export
 * @interface Detail
 */
export interface Detail {}
/**
 * Detailed information about the event
 * @export
 * @interface Detail1
 */
export interface Detail1 {}
/**
 * Detailed information about the issue
 * @export
 * @interface Detail2
 */
export interface Detail2 {}
/**
 *
 * @export
 * @interface Dispatch
 */
export interface Dispatch {
  /**
   *
   * @type {Status1}
   * @memberof Dispatch
   */
  status: Status1;
  /**
   *
   * @type {Assignment}
   * @memberof Dispatch
   */
  assignment?: Assignment;
  /**
   *
   * @type {Array<Error>}
   * @memberof Dispatch
   */
  errors?: Array<Error>;
}
/**
 *
 * @export
 * @interface DispatchTaskRequest
 */
export interface DispatchTaskRequest {
  /**
   * Indicate that this is a task dispatch request
   * @type {string}
   * @memberof DispatchTaskRequest
   */
  type: DispatchTaskRequestTypeEnum;
  /**
   *
   * @type {TaskRequest}
   * @memberof DispatchTaskRequest
   */
  request: TaskRequest;
}

export const DispatchTaskRequestTypeEnum = {
  DispatchTaskRequest: 'dispatch_task_request',
} as const;

export type DispatchTaskRequestTypeEnum =
  typeof DispatchTaskRequestTypeEnum[keyof typeof DispatchTaskRequestTypeEnum];

/**
 *
 * @export
 * @interface Dispenser
 */
export interface Dispenser {
  /**
   *
   * @type {string}
   * @memberof Dispenser
   */
  guid: string;
}
/**
 *
 * @export
 * @interface DispenserHealth
 */
export interface DispenserHealth {
  /**
   *
   * @type {string}
   * @memberof DispenserHealth
   */
  health_status: string | null;
  /**
   *
   * @type {string}
   * @memberof DispenserHealth
   */
  health_message?: string | null;
  /**
   *
   * @type {string}
   * @memberof DispenserHealth
   */
  id_: string;
}
/**
 *
 * @export
 * @interface DispenserState
 */
export interface DispenserState {
  /**
   *
   * @type {Time1}
   * @memberof DispenserState
   */
  time: Time1;
  /**
   *
   * @type {string}
   * @memberof DispenserState
   */
  guid: string;
  /**
   *
   * @type {number}
   * @memberof DispenserState
   */
  mode: number;
  /**
   *
   * @type {Array<string>}
   * @memberof DispenserState
   */
  request_guid_queue: Array<string>;
  /**
   *
   * @type {number}
   * @memberof DispenserState
   */
  seconds_remaining: number;
}
/**
 *
 * @export
 * @interface Door
 */
export interface Door {
  /**
   *
   * @type {string}
   * @memberof Door
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof Door
   */
  v1_x: number;
  /**
   *
   * @type {number}
   * @memberof Door
   */
  v1_y: number;
  /**
   *
   * @type {number}
   * @memberof Door
   */
  v2_x: number;
  /**
   *
   * @type {number}
   * @memberof Door
   */
  v2_y: number;
  /**
   *
   * @type {number}
   * @memberof Door
   */
  door_type: number;
  /**
   *
   * @type {number}
   * @memberof Door
   */
  motion_range: number;
  /**
   *
   * @type {number}
   * @memberof Door
   */
  motion_direction: number;
}
/**
 *
 * @export
 * @interface DoorHealth
 */
export interface DoorHealth {
  /**
   *
   * @type {string}
   * @memberof DoorHealth
   */
  health_status: string | null;
  /**
   *
   * @type {string}
   * @memberof DoorHealth
   */
  health_message?: string | null;
  /**
   *
   * @type {string}
   * @memberof DoorHealth
   */
  id_: string;
}
/**
 *
 * @export
 * @interface DoorMode
 */
export interface DoorMode {
  /**
   *
   * @type {number}
   * @memberof DoorMode
   */
  value: number;
}
/**
 *
 * @export
 * @interface DoorRequest
 */
export interface DoorRequest {
  /**
   * https://github.com/open-rmf/rmf_internal_msgs/blob/main/rmf_door_msgs/msg/DoorMode.msg
   * @type {number}
   * @memberof DoorRequest
   */
  mode: number;
}
/**
 *
 * @export
 * @interface DoorState
 */
export interface DoorState {
  /**
   *
   * @type {DoorTime}
   * @memberof DoorState
   */
  door_time: DoorTime;
  /**
   *
   * @type {string}
   * @memberof DoorState
   */
  door_name: string;
  /**
   *
   * @type {CurrentMode}
   * @memberof DoorState
   */
  current_mode: CurrentMode;
}
/**
 *
 * @export
 * @interface DoorTime
 */
export interface DoorTime {
  /**
   *
   * @type {number}
   * @memberof DoorTime
   */
  sec: number;
  /**
   *
   * @type {number}
   * @memberof DoorTime
   */
  nanosec: number;
}
/**
 *
 * @export
 * @interface EventState
 */
export interface EventState {
  /**
   *
   * @type {number}
   * @memberof EventState
   */
  id: number;
  /**
   *
   * @type {Status}
   * @memberof EventState
   */
  status?: Status;
  /**
   * The brief name of the event
   * @type {string}
   * @memberof EventState
   */
  name?: string;
  /**
   *
   * @type {Detail1}
   * @memberof EventState
   */
  detail?: Detail1;
  /**
   * This event may depend on other events. This array contains the IDs of those other event dependencies.
   * @type {Array<number>}
   * @memberof EventState
   */
  deps?: Array<number>;
}
/**
 *
 * @export
 * @interface Graph
 */
export interface Graph {
  /**
   *
   * @type {string}
   * @memberof Graph
   */
  name: string;
  /**
   *
   * @type {Array<GraphNode>}
   * @memberof Graph
   */
  vertices: Array<GraphNode>;
  /**
   *
   * @type {Array<GraphEdge>}
   * @memberof Graph
   */
  edges: Array<GraphEdge>;
  /**
   *
   * @type {Array<Param>}
   * @memberof Graph
   */
  params: Array<Param>;
}
/**
 *
 * @export
 * @interface GraphEdge
 */
export interface GraphEdge {
  /**
   *
   * @type {number}
   * @memberof GraphEdge
   */
  v1_idx: number;
  /**
   *
   * @type {number}
   * @memberof GraphEdge
   */
  v2_idx: number;
  /**
   *
   * @type {Array<Param>}
   * @memberof GraphEdge
   */
  params: Array<Param>;
  /**
   *
   * @type {number}
   * @memberof GraphEdge
   */
  edge_type: number;
}
/**
 *
 * @export
 * @interface GraphNode
 */
export interface GraphNode {
  /**
   *
   * @type {number}
   * @memberof GraphNode
   */
  x: number;
  /**
   *
   * @type {number}
   * @memberof GraphNode
   */
  y: number;
  /**
   *
   * @type {string}
   * @memberof GraphNode
   */
  name: string;
  /**
   *
   * @type {Array<Param>}
   * @memberof GraphNode
   */
  params: Array<Param>;
}
/**
 *
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
  /**
   *
   * @type {Array<ValidationError>}
   * @memberof HTTPValidationError
   */
  detail?: Array<ValidationError>;
}
/**
 *
 * @export
 * @interface Ingestor
 */
export interface Ingestor {
  /**
   *
   * @type {string}
   * @memberof Ingestor
   */
  guid: string;
}
/**
 *
 * @export
 * @interface IngestorHealth
 */
export interface IngestorHealth {
  /**
   *
   * @type {string}
   * @memberof IngestorHealth
   */
  health_status: string | null;
  /**
   *
   * @type {string}
   * @memberof IngestorHealth
   */
  health_message?: string | null;
  /**
   *
   * @type {string}
   * @memberof IngestorHealth
   */
  id_: string;
}
/**
 *
 * @export
 * @interface IngestorState
 */
export interface IngestorState {
  /**
   *
   * @type {Time1}
   * @memberof IngestorState
   */
  time: Time1;
  /**
   *
   * @type {string}
   * @memberof IngestorState
   */
  guid: string;
  /**
   *
   * @type {number}
   * @memberof IngestorState
   */
  mode: number;
  /**
   *
   * @type {Array<string>}
   * @memberof IngestorState
   */
  request_guid_queue: Array<string>;
  /**
   *
   * @type {number}
   * @memberof IngestorState
   */
  seconds_remaining: number;
}
/**
 *
 * @export
 * @interface Interruption
 */
export interface Interruption {
  /**
   * The time that the interruption request arrived
   * @type {number}
   * @memberof Interruption
   */
  unix_millis_request_time: number;
  /**
   * Labels to describe the purpose of the interruption
   * @type {Array<string>}
   * @memberof Interruption
   */
  labels: Array<string>;
  /**
   *
   * @type {ResumedBy}
   * @memberof Interruption
   */
  resumed_by?: ResumedBy;
}
/**
 *
 * @export
 * @interface Issue
 */
export interface Issue {
  /**
   * Category of the robot\'s issue
   * @type {string}
   * @memberof Issue
   */
  category?: string;
  /**
   *
   * @type {Detail2}
   * @memberof Issue
   */
  detail?: Detail2;
}
/**
 *
 * @export
 * @interface Killed
 */
export interface Killed {
  /**
   * The time that the cancellation request arrived
   * @type {number}
   * @memberof Killed
   */
  unix_millis_request_time: number;
  /**
   * Labels to describe the kill request
   * @type {Array<string>}
   * @memberof Killed
   */
  labels: Array<string>;
}
/**
 * If the task was killed, this will describe information about the request.
 * @export
 * @interface Killed1
 */
export interface Killed1 {
  /**
   * The time that the cancellation request arrived
   * @type {number}
   * @memberof Killed1
   */
  unix_millis_request_time: number;
  /**
   * Labels to describe the kill request
   * @type {Array<string>}
   * @memberof Killed1
   */
  labels: Array<string>;
}
/**
 *
 * @export
 * @interface Level
 */
export interface Level {
  /**
   *
   * @type {string}
   * @memberof Level
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof Level
   */
  elevation: number;
  /**
   *
   * @type {Array<AffineImage>}
   * @memberof Level
   */
  images: Array<AffineImage>;
  /**
   *
   * @type {Array<Place>}
   * @memberof Level
   */
  places: Array<Place>;
  /**
   *
   * @type {Array<Door>}
   * @memberof Level
   */
  doors: Array<Door>;
  /**
   *
   * @type {Array<Graph>}
   * @memberof Level
   */
  nav_graphs: Array<Graph>;
  /**
   *
   * @type {WallGraph}
   * @memberof Level
   */
  wall_graph: WallGraph;
}
/**
 *
 * @export
 * @interface Lift
 */
export interface Lift {
  /**
   *
   * @type {string}
   * @memberof Lift
   */
  name: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Lift
   */
  levels: Array<string>;
  /**
   *
   * @type {Array<Door>}
   * @memberof Lift
   */
  doors: Array<Door>;
  /**
   *
   * @type {WallGraph}
   * @memberof Lift
   */
  wall_graph: WallGraph;
  /**
   *
   * @type {number}
   * @memberof Lift
   */
  ref_x: number;
  /**
   *
   * @type {number}
   * @memberof Lift
   */
  ref_y: number;
  /**
   *
   * @type {number}
   * @memberof Lift
   */
  ref_yaw: number;
  /**
   *
   * @type {number}
   * @memberof Lift
   */
  width: number;
  /**
   *
   * @type {number}
   * @memberof Lift
   */
  depth: number;
}
/**
 *
 * @export
 * @interface LiftHealth
 */
export interface LiftHealth {
  /**
   *
   * @type {string}
   * @memberof LiftHealth
   */
  health_status: string | null;
  /**
   *
   * @type {string}
   * @memberof LiftHealth
   */
  health_message?: string | null;
  /**
   *
   * @type {string}
   * @memberof LiftHealth
   */
  id_: string;
}
/**
 *
 * @export
 * @interface LiftRequest
 */
export interface LiftRequest {
  /**
   * https://github.com/open-rmf/rmf_internal_msgs/blob/main/rmf_lift_msgs/msg/LiftRequest.msg
   * @type {number}
   * @memberof LiftRequest
   */
  request_type: number;
  /**
   * https://github.com/open-rmf/rmf_internal_msgs/blob/main/rmf_lift_msgs/msg/LiftRequest.msg
   * @type {number}
   * @memberof LiftRequest
   */
  door_mode: number;
  /**
   *
   * @type {string}
   * @memberof LiftRequest
   */
  destination: string;
}
/**
 *
 * @export
 * @interface LiftState
 */
export interface LiftState {
  /**
   *
   * @type {LiftTime}
   * @memberof LiftState
   */
  lift_time: LiftTime;
  /**
   *
   * @type {string}
   * @memberof LiftState
   */
  lift_name: string;
  /**
   *
   * @type {Array<string>}
   * @memberof LiftState
   */
  available_floors: Array<string>;
  /**
   *
   * @type {string}
   * @memberof LiftState
   */
  current_floor: string;
  /**
   *
   * @type {string}
   * @memberof LiftState
   */
  destination_floor: string;
  /**
   *
   * @type {number}
   * @memberof LiftState
   */
  door_state: number;
  /**
   *
   * @type {number}
   * @memberof LiftState
   */
  motion_state: number;
  /**
   *
   * @type {Array<number>}
   * @memberof LiftState
   */
  available_modes: Array<number>;
  /**
   *
   * @type {number}
   * @memberof LiftState
   */
  current_mode: number;
  /**
   *
   * @type {string}
   * @memberof LiftState
   */
  session_id: string;
}
/**
 *
 * @export
 * @interface LiftTime
 */
export interface LiftTime {
  /**
   *
   * @type {number}
   * @memberof LiftTime
   */
  sec: number;
  /**
   *
   * @type {number}
   * @memberof LiftTime
   */
  nanosec: number;
}
/**
 *
 * @export
 * @interface Location2D
 */
export interface Location2D {
  /**
   *
   * @type {string}
   * @memberof Location2D
   */
  map: string;
  /**
   *
   * @type {number}
   * @memberof Location2D
   */
  x: number;
  /**
   *
   * @type {number}
   * @memberof Location2D
   */
  y: number;
  /**
   *
   * @type {number}
   * @memberof Location2D
   */
  yaw: number;
}
/**
 *
 * @export
 * @interface LocationInner
 */
export interface LocationInner {}
/**
 *
 * @export
 * @interface LogEntry
 */
export interface LogEntry {
  /**
   * Sequence number for this entry. Each entry has a unique sequence number which monotonically increase, until integer overflow causes a wrap around.
   * @type {number}
   * @memberof LogEntry
   */
  seq: number;
  /**
   * The importance level of the log entry
   * @type {Tier}
   * @memberof LogEntry
   */
  tier: Tier;
  /**
   *
   * @type {number}
   * @memberof LogEntry
   */
  unix_millis_time: number;
  /**
   * The text of the log entry
   * @type {string}
   * @memberof LogEntry
   */
  text: string;
}
/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
  /**
   * A standard code for the kind of error that has occurred
   * @type {number}
   * @memberof ModelError
   */
  code?: number;
  /**
   * The category of the error
   * @type {string}
   * @memberof ModelError
   */
  category?: string;
  /**
   * Details about the error
   * @type {string}
   * @memberof ModelError
   */
  detail?: string;
}
/**
 *
 * @export
 * @interface Param
 */
export interface Param {
  /**
   *
   * @type {string}
   * @memberof Param
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof Param
   */
  type: number;
  /**
   *
   * @type {number}
   * @memberof Param
   */
  value_int: number;
  /**
   *
   * @type {number}
   * @memberof Param
   */
  value_float: number;
  /**
   *
   * @type {string}
   * @memberof Param
   */
  value_string: string;
  /**
   *
   * @type {boolean}
   * @memberof Param
   */
  value_bool: boolean;
}
/**
 *
 * @export
 * @interface Permission
 */
export interface Permission {
  /**
   *
   * @type {string}
   * @memberof Permission
   */
  authz_grp: string;
  /**
   *
   * @type {string}
   * @memberof Permission
   */
  action: string;
}
/**
 *
 * @export
 * @interface Phase
 */
export interface Phase {
  /**
   *
   * @type {number}
   * @memberof Phase
   */
  id: number;
  /**
   * The category of this task or phase
   * @type {string}
   * @memberof Phase
   */
  category?: string;
  /**
   *
   * @type {Detail}
   * @memberof Phase
   */
  detail?: Detail;
  /**
   *
   * @type {number}
   * @memberof Phase
   */
  unix_millis_start_time?: number;
  /**
   *
   * @type {number}
   * @memberof Phase
   */
  unix_millis_finish_time?: number;
  /**
   * An estimate, in milliseconds, of how long the subject will take to complete
   * @type {number}
   * @memberof Phase
   */
  original_estimate_millis?: number;
  /**
   * An estimate, in milliseconds, of how long the subject will take to complete
   * @type {number}
   * @memberof Phase
   */
  estimate_millis?: number;
  /**
   *
   * @type {number}
   * @memberof Phase
   */
  final_event_id?: number;
  /**
   * A dictionary of events for this phase. The keys (property names) are the event IDs, which are integers.
   * @type {{ [key: string]: EventState; }}
   * @memberof Phase
   */
  events?: { [key: string]: EventState };
  /**
   * Information about any skip requests that have been received
   * @type {{ [key: string]: SkipPhaseRequest; }}
   * @memberof Phase
   */
  skip_requests?: { [key: string]: SkipPhaseRequest };
}
/**
 *
 * @export
 * @interface Phases
 */
export interface Phases {
  /**
   * Log entries related to the overall phase
   * @type {Array<LogEntry>}
   * @memberof Phases
   */
  log?: Array<LogEntry>;
  /**
   * A dictionary whose keys (property names) are the indices of an event in the phase
   * @type {{ [key: string]: Array<LogEntry>; }}
   * @memberof Phases
   */
  events?: { [key: string]: Array<LogEntry> };
}
/**
 *
 * @export
 * @interface Place
 */
export interface Place {
  /**
   *
   * @type {string}
   * @memberof Place
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof Place
   */
  x: number;
  /**
   *
   * @type {number}
   * @memberof Place
   */
  y: number;
  /**
   *
   * @type {number}
   * @memberof Place
   */
  yaw: number;
  /**
   *
   * @type {number}
   * @memberof Place
   */
  position_tolerance: number;
  /**
   *
   * @type {number}
   * @memberof Place
   */
  yaw_tolerance: number;
}
/**
 *
 * @export
 * @interface PostMakeAdmin
 */
export interface PostMakeAdmin {
  /**
   *
   * @type {boolean}
   * @memberof PostMakeAdmin
   */
  admin: boolean;
}
/**
 *
 * @export
 * @interface PostRoles
 */
export interface PostRoles {
  /**
   *
   * @type {string}
   * @memberof PostRoles
   */
  name: string;
}
/**
 *
 * @export
 * @interface PostScheduledTaskRequest
 */
export interface PostScheduledTaskRequest {
  /**
   *
   * @type {TaskRequest}
   * @memberof PostScheduledTaskRequest
   */
  task_request: TaskRequest;
  /**
   *
   * @type {Array<ApiServerModelsTortoiseModelsScheduledTaskScheduledTaskScheduleLeaf>}
   * @memberof PostScheduledTaskRequest
   */
  schedules: Array<ApiServerModelsTortoiseModelsScheduledTaskScheduledTaskScheduleLeaf>;
}
/**
 *
 * @export
 * @interface PostUsers
 */
export interface PostUsers {
  /**
   *
   * @type {string}
   * @memberof PostUsers
   */
  username: string;
  /**
   *
   * @type {boolean}
   * @memberof PostUsers
   */
  is_admin?: boolean;
}
/**
 * Priority information about this task
 * @export
 * @interface Priority
 */
export interface Priority {}
/**
 * Information about the resume request that ended this interruption. This field will be missing if the interruption is still active.
 * @export
 * @interface ResumedBy
 */
export interface ResumedBy {
  /**
   * The time that the resume request arrived
   * @type {number}
   * @memberof ResumedBy
   */
  unix_millis_request_time?: number;
  /**
   * Labels to describe the resume request
   * @type {Array<string>}
   * @memberof ResumedBy
   */
  labels: Array<string>;
}
/**
 *
 * @export
 * @interface RobotState
 */
export interface RobotState {
  /**
   *
   * @type {string}
   * @memberof RobotState
   */
  name?: string;
  /**
   * A simple token representing the status of the robot
   * @type {Status2}
   * @memberof RobotState
   */
  status?: Status2;
  /**
   * The ID of the task this robot is currently working on. Empty string if the robot is not working on a task.
   * @type {string}
   * @memberof RobotState
   */
  task_id?: string;
  /**
   *
   * @type {number}
   * @memberof RobotState
   */
  unix_millis_time?: number;
  /**
   *
   * @type {Location2D}
   * @memberof RobotState
   */
  location?: Location2D;
  /**
   * State of charge of the battery. Values range from 0.0 (depleted) to 1.0 (fully charged)
   * @type {number}
   * @memberof RobotState
   */
  battery?: number;
  /**
   * A list of issues with the robot that operators need to address
   * @type {Array<Issue>}
   * @memberof RobotState
   */
  issues?: Array<Issue>;
}
/**
 *
 * @export
 * @interface RobotTaskRequest
 */
export interface RobotTaskRequest {
  /**
   * Indicate that this is a task dispatch request
   * @type {string}
   * @memberof RobotTaskRequest
   */
  type: string;
  /**
   * The name of the robot
   * @type {string}
   * @memberof RobotTaskRequest
   */
  robot: string;
  /**
   * The fleet the robot belongs to
   * @type {string}
   * @memberof RobotTaskRequest
   */
  fleet: string;
  /**
   *
   * @type {TaskRequest}
   * @memberof RobotTaskRequest
   */
  request: TaskRequest;
}
/**
 * Response to a robot task request
 * @export
 * @interface RobotTaskResponse
 */
export interface RobotTaskResponse {
  /**
   *
   * @type {boolean}
   * @memberof RobotTaskResponse
   */
  success: RobotTaskResponseSuccessEnum;
  /**
   *
   * @type {TaskState}
   * @memberof RobotTaskResponse
   */
  state: TaskState;
  /**
   * Any error messages explaining why the request failed
   * @type {Array<Error>}
   * @memberof RobotTaskResponse
   */
  errors?: Array<Error>;
}

export const RobotTaskResponseSuccessEnum = {
  False: false,
} as const;

export type RobotTaskResponseSuccessEnum =
  typeof RobotTaskResponseSuccessEnum[keyof typeof RobotTaskResponseSuccessEnum];

/**
 * Template for defining a response message that only indicates success and describes any errors
 * @export
 * @interface SimpleResponse
 */
export interface SimpleResponse {
  /**
   *
   * @type {ApiServerModelsRmfApiSimpleResponseFailure}
   * @memberof SimpleResponse
   */
  success: ApiServerModelsRmfApiSimpleResponseFailure;
  /**
   * If the request failed, these error messages will explain why
   * @type {Array<Error>}
   * @memberof SimpleResponse
   */
  errors: Array<Error>;
}
/**
 *
 * @export
 * @interface SimpleResponseItem
 */
export interface SimpleResponseItem {
  /**
   *
   * @type {ApiServerModelsRmfApiSimpleResponseSuccess}
   * @memberof SimpleResponseItem
   */
  success: ApiServerModelsRmfApiSimpleResponseSuccess;
}
/**
 *
 * @export
 * @interface SimpleResponseItem1
 */
export interface SimpleResponseItem1 {
  /**
   *
   * @type {ApiServerModelsRmfApiSimpleResponseFailure}
   * @memberof SimpleResponseItem1
   */
  success: ApiServerModelsRmfApiSimpleResponseFailure;
  /**
   * If the request failed, these error messages will explain why
   * @type {Array<Error>}
   * @memberof SimpleResponseItem1
   */
  errors: Array<Error>;
}
/**
 *
 * @export
 * @interface SkipPhaseRequest
 */
export interface SkipPhaseRequest {
  /**
   * The time that the skip request arrived
   * @type {number}
   * @memberof SkipPhaseRequest
   */
  unix_millis_request_time: number;
  /**
   * Labels to describe the purpose of the skip request
   * @type {Array<string>}
   * @memberof SkipPhaseRequest
   */
  labels: Array<string>;
  /**
   *
   * @type {Undo1}
   * @memberof SkipPhaseRequest
   */
  undo?: Undo1;
}
/**
 * Response to a request for a phase to be skipped
 * @export
 * @interface SkipPhaseResponse
 */
export interface SkipPhaseResponse {
  /**
   *
   * @type {ApiServerModelsRmfApiTokenResponseFailure}
   * @memberof SkipPhaseResponse
   */
  success: ApiServerModelsRmfApiTokenResponseFailure;
  /**
   * A token for the request. The value of this token is unique within the scope of this request and can be used by other requests to reference this request.
   * @type {string}
   * @memberof SkipPhaseResponse
   */
  token: string;
  /**
   * Any error messages explaining why the request failed.
   * @type {Array<Error>}
   * @memberof SkipPhaseResponse
   */
  errors: Array<Error>;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const Status = {
  Uninitialized: 'uninitialized',
  Blocked: 'blocked',
  Error: 'error',
  Failed: 'failed',
  Queued: 'queued',
  Standby: 'standby',
  Underway: 'underway',
  Delayed: 'delayed',
  Skipped: 'skipped',
  Canceled: 'canceled',
  Killed: 'killed',
  Completed: 'completed',
} as const;

export type Status = typeof Status[keyof typeof Status];

/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const Status1 = {
  Queued: 'queued',
  Selected: 'selected',
  Dispatched: 'dispatched',
  FailedToAssign: 'failed_to_assign',
  CanceledInFlight: 'canceled_in_flight',
} as const;

export type Status1 = typeof Status1[keyof typeof Status1];

/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const Status2 = {
  Uninitialized: 'uninitialized',
  Offline: 'offline',
  Shutdown: 'shutdown',
  Idle: 'idle',
  Charging: 'charging',
  Working: 'working',
  Error: 'error',
} as const;

export type Status2 = typeof Status2[keyof typeof Status2];

/**
 *
 * @export
 * @interface Task
 */
export interface Task {
  /**
   * The category of this task. There must not be any duplicate task categories per fleet.
   * @type {string}
   * @memberof Task
   */
  category: string;
  /**
   * Details about the behavior of the task.
   * @type {string}
   * @memberof Task
   */
  detail: string;
  /**
   * The schema for this task description
   * @type {object}
   * @memberof Task
   */
  description_schema?: object;
}
/**
 * Response to a request to cancel a task
 * @export
 * @interface TaskCancelResponse
 */
export interface TaskCancelResponse {
  /**
   *
   * @type {ApiServerModelsRmfApiSimpleResponseFailure}
   * @memberof TaskCancelResponse
   */
  success: ApiServerModelsRmfApiSimpleResponseFailure;
  /**
   * If the request failed, these error messages will explain why
   * @type {Array<Error>}
   * @memberof TaskCancelResponse
   */
  errors: Array<Error>;
}
/**
 *
 * @export
 * @interface TaskDiscovery
 */
export interface TaskDiscovery {
  /**
   * Indicate that this is an task discovery update
   * @type {string}
   * @memberof TaskDiscovery
   */
  type: TaskDiscoveryTypeEnum;
  /**
   *
   * @type {Data}
   * @memberof TaskDiscovery
   */
  data: Data;
}

export const TaskDiscoveryTypeEnum = {
  TaskDiscoveryUpdate: 'task_discovery_update',
} as const;

export type TaskDiscoveryTypeEnum =
  typeof TaskDiscoveryTypeEnum[keyof typeof TaskDiscoveryTypeEnum];

/**
 *
 * @export
 * @interface TaskDiscoveryRequest
 */
export interface TaskDiscoveryRequest {
  /**
   * Indicate that this is a task discovery request
   * @type {string}
   * @memberof TaskDiscoveryRequest
   */
  type: TaskDiscoveryRequestTypeEnum;
}

export const TaskDiscoveryRequestTypeEnum = {
  TaskDiscoveryRequest: 'task_discovery_request',
} as const;

export type TaskDiscoveryRequestTypeEnum =
  typeof TaskDiscoveryRequestTypeEnum[keyof typeof TaskDiscoveryRequestTypeEnum];

/**
 * Response to a task dispatch request
 * @export
 * @interface TaskDispatchResponse
 */
export interface TaskDispatchResponse {
  /**
   *
   * @type {boolean}
   * @memberof TaskDispatchResponse
   */
  success: TaskDispatchResponseSuccessEnum;
  /**
   *
   * @type {TaskState}
   * @memberof TaskDispatchResponse
   */
  state: TaskState;
  /**
   * Any error messages explaining why the request failed
   * @type {Array<Error>}
   * @memberof TaskDispatchResponse
   */
  errors?: Array<Error>;
}

export const TaskDispatchResponseSuccessEnum = {
  False: false,
} as const;

export type TaskDispatchResponseSuccessEnum =
  typeof TaskDispatchResponseSuccessEnum[keyof typeof TaskDispatchResponseSuccessEnum];

/**
 *
 * @export
 * @interface TaskDispatchResponseItem
 */
export interface TaskDispatchResponseItem {
  /**
   *
   * @type {boolean}
   * @memberof TaskDispatchResponseItem
   */
  success: TaskDispatchResponseItemSuccessEnum;
  /**
   *
   * @type {TaskState}
   * @memberof TaskDispatchResponseItem
   */
  state: TaskState;
}

export const TaskDispatchResponseItemSuccessEnum = {
  True: true,
} as const;

export type TaskDispatchResponseItemSuccessEnum =
  typeof TaskDispatchResponseItemSuccessEnum[keyof typeof TaskDispatchResponseItemSuccessEnum];

/**
 *
 * @export
 * @interface TaskDispatchResponseItem1
 */
export interface TaskDispatchResponseItem1 {
  /**
   *
   * @type {boolean}
   * @memberof TaskDispatchResponseItem1
   */
  success?: TaskDispatchResponseItem1SuccessEnum;
  /**
   * Any error messages explaining why the request failed
   * @type {Array<Error>}
   * @memberof TaskDispatchResponseItem1
   */
  errors?: Array<Error>;
}

export const TaskDispatchResponseItem1SuccessEnum = {
  False: false,
} as const;

export type TaskDispatchResponseItem1SuccessEnum =
  typeof TaskDispatchResponseItem1SuccessEnum[keyof typeof TaskDispatchResponseItem1SuccessEnum];

/**
 *
 * @export
 * @interface TaskEventLog
 */
export interface TaskEventLog {
  /**
   *
   * @type {string}
   * @memberof TaskEventLog
   */
  task_id: string;
  /**
   * Log entries related to the overall task
   * @type {Array<LogEntry>}
   * @memberof TaskEventLog
   */
  log?: Array<LogEntry>;
  /**
   * A dictionary whose keys (property names) are the indices of a phase
   * @type {{ [key: string]: Phases; }}
   * @memberof TaskEventLog
   */
  phases?: { [key: string]: Phases };
}
/**
 *
 * @export
 * @interface TaskFavoritePydantic
 */
export interface TaskFavoritePydantic {
  /**
   *
   * @type {string}
   * @memberof TaskFavoritePydantic
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof TaskFavoritePydantic
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof TaskFavoritePydantic
   */
  unix_millis_earliest_start_time: number;
  /**
   *
   * @type {object}
   * @memberof TaskFavoritePydantic
   */
  priority?: object;
  /**
   *
   * @type {string}
   * @memberof TaskFavoritePydantic
   */
  category: string;
  /**
   *
   * @type {object}
   * @memberof TaskFavoritePydantic
   */
  description?: object;
  /**
   *
   * @type {string}
   * @memberof TaskFavoritePydantic
   */
  user: string;
}
/**
 *
 * @export
 * @interface TaskInterruptionRequest
 */
export interface TaskInterruptionRequest {
  /**
   * Indicate that this is a task interruption request
   * @type {string}
   * @memberof TaskInterruptionRequest
   */
  type: TaskInterruptionRequestTypeEnum;
  /**
   * Specify the task ID to interrupt
   * @type {string}
   * @memberof TaskInterruptionRequest
   */
  task_id: string;
  /**
   * Labels to describe the purpose of the interruption
   * @type {Array<string>}
   * @memberof TaskInterruptionRequest
   */
  labels?: Array<string>;
}

export const TaskInterruptionRequestTypeEnum = {
  InterruptTaskRequest: 'interrupt_task_request',
} as const;

export type TaskInterruptionRequestTypeEnum =
  typeof TaskInterruptionRequestTypeEnum[keyof typeof TaskInterruptionRequestTypeEnum];

/**
 * Response to a request for a task to be interrupted
 * @export
 * @interface TaskInterruptionResponse
 */
export interface TaskInterruptionResponse {
  /**
   *
   * @type {ApiServerModelsRmfApiTokenResponseFailure}
   * @memberof TaskInterruptionResponse
   */
  success: ApiServerModelsRmfApiTokenResponseFailure;
  /**
   * A token for the request. The value of this token is unique within the scope of this request and can be used by other requests to reference this request.
   * @type {string}
   * @memberof TaskInterruptionResponse
   */
  token: string;
  /**
   * Any error messages explaining why the request failed.
   * @type {Array<Error>}
   * @memberof TaskInterruptionResponse
   */
  errors: Array<Error>;
}
/**
 *
 * @export
 * @interface TaskKillRequest
 */
export interface TaskKillRequest {
  /**
   * Indicate that this is a task kill request
   * @type {string}
   * @memberof TaskKillRequest
   */
  type: TaskKillRequestTypeEnum;
  /**
   * Specify the task ID to kill
   * @type {string}
   * @memberof TaskKillRequest
   */
  task_id: string;
  /**
   * Labels to describe the purpose of the kill
   * @type {Array<string>}
   * @memberof TaskKillRequest
   */
  labels?: Array<string>;
}

export const TaskKillRequestTypeEnum = {
  KillTaskRequest: 'kill_task_request',
} as const;

export type TaskKillRequestTypeEnum =
  typeof TaskKillRequestTypeEnum[keyof typeof TaskKillRequestTypeEnum];

/**
 * Response to a request to kill a task
 * @export
 * @interface TaskKillResponse
 */
export interface TaskKillResponse {
  /**
   *
   * @type {ApiServerModelsRmfApiSimpleResponseFailure}
   * @memberof TaskKillResponse
   */
  success: ApiServerModelsRmfApiSimpleResponseFailure;
  /**
   * If the request failed, these error messages will explain why
   * @type {Array<Error>}
   * @memberof TaskKillResponse
   */
  errors: Array<Error>;
}
/**
 *
 * @export
 * @interface TaskPhaseSkipRequest
 */
export interface TaskPhaseSkipRequest {
  /**
   * Indicate that this is a phase skip request
   * @type {string}
   * @memberof TaskPhaseSkipRequest
   */
  type: TaskPhaseSkipRequestTypeEnum;
  /**
   * Specify the task ID whose phase should be skipped
   * @type {string}
   * @memberof TaskPhaseSkipRequest
   */
  task_id: string;
  /**
   * Specify the phase that should be skipped
   * @type {number}
   * @memberof TaskPhaseSkipRequest
   */
  phase_id: number;
  /**
   * Labels to describe the purpose of the skip
   * @type {Array<string>}
   * @memberof TaskPhaseSkipRequest
   */
  labels?: Array<string>;
}

export const TaskPhaseSkipRequestTypeEnum = {
  SkipPhaseRequest: 'skip_phase_request',
} as const;

export type TaskPhaseSkipRequestTypeEnum =
  typeof TaskPhaseSkipRequestTypeEnum[keyof typeof TaskPhaseSkipRequestTypeEnum];

/**
 *
 * @export
 * @interface TaskRequest
 */
export interface TaskRequest {
  /**
   * (Optional) The earliest time that this task may start
   * @type {number}
   * @memberof TaskRequest
   */
  unix_millis_earliest_start_time?: number;
  /**
   * (Optional) The time that this request was initiated
   * @type {number}
   * @memberof TaskRequest
   */
  unix_millis_request_time?: number;
  /**
   * (Optional) The priority of this task. This must match a priority schema supported by a fleet.
   * @type {object}
   * @memberof TaskRequest
   */
  priority?: object;
  /**
   *
   * @type {string}
   * @memberof TaskRequest
   */
  category: string;
  /**
   * A description of the task. This must match a schema supported by a fleet for the category of this task request.
   * @type {any}
   * @memberof TaskRequest
   */
  description: any;
  /**
   * Labels to describe the purpose of the task dispatch request
   * @type {Array<string>}
   * @memberof TaskRequest
   */
  labels?: Array<string>;
  /**
   * (Optional) An identifier for the entity that requested this task
   * @type {string}
   * @memberof TaskRequest
   */
  requester?: string;
}
/**
 *
 * @export
 * @interface TaskResumeRequest
 */
export interface TaskResumeRequest {
  /**
   * Indicate that this is a task resuming request
   * @type {string}
   * @memberof TaskResumeRequest
   */
  type?: TaskResumeRequestTypeEnum;
  /**
   * Specify task ID to resume.
   * @type {string}
   * @memberof TaskResumeRequest
   */
  for_task?: string;
  /**
   * A list of tokens of interruption requests which should be resumed. The interruption request associated with each token will be discarded.
   * @type {Array<string>}
   * @memberof TaskResumeRequest
   */
  for_tokens?: Array<string>;
  /**
   * Labels describing this request
   * @type {Array<string>}
   * @memberof TaskResumeRequest
   */
  labels?: Array<string>;
}

export const TaskResumeRequestTypeEnum = {
  ResumeTaskRequest: 'resume_task_request',
} as const;

export type TaskResumeRequestTypeEnum =
  typeof TaskResumeRequestTypeEnum[keyof typeof TaskResumeRequestTypeEnum];

/**
 * Response to a request to resume a task
 * @export
 * @interface TaskResumeResponse
 */
export interface TaskResumeResponse {
  /**
   *
   * @type {ApiServerModelsRmfApiSimpleResponseFailure}
   * @memberof TaskResumeResponse
   */
  success: ApiServerModelsRmfApiSimpleResponseFailure;
  /**
   * If the request failed, these error messages will explain why
   * @type {Array<Error>}
   * @memberof TaskResumeResponse
   */
  errors: Array<Error>;
}
/**
 *
 * @export
 * @interface TaskRewindRequest
 */
export interface TaskRewindRequest {
  /**
   * Indicate that this is a task rewind request
   * @type {string}
   * @memberof TaskRewindRequest
   */
  type: TaskRewindRequestTypeEnum;
  /**
   * Specify the ID of the task that should rewind
   * @type {string}
   * @memberof TaskRewindRequest
   */
  task_id: string;
  /**
   * Specify the phase that should be rewound to. The task will restart at the beginning of this phase.
   * @type {number}
   * @memberof TaskRewindRequest
   */
  phase_id: number;
}

export const TaskRewindRequestTypeEnum = {
  RewindTaskRequest: 'rewind_task_request',
} as const;

export type TaskRewindRequestTypeEnum =
  typeof TaskRewindRequestTypeEnum[keyof typeof TaskRewindRequestTypeEnum];

/**
 * Response to a request to rewind a task
 * @export
 * @interface TaskRewindResponse
 */
export interface TaskRewindResponse {
  /**
   *
   * @type {ApiServerModelsRmfApiSimpleResponseFailure}
   * @memberof TaskRewindResponse
   */
  success: ApiServerModelsRmfApiSimpleResponseFailure;
  /**
   * If the request failed, these error messages will explain why
   * @type {Array<Error>}
   * @memberof TaskRewindResponse
   */
  errors: Array<Error>;
}
/**
 *
 * @export
 * @interface TaskState
 */
export interface TaskState {
  /**
   *
   * @type {Booking}
   * @memberof TaskState
   */
  booking: Booking;
  /**
   * The category of this task or phase
   * @type {string}
   * @memberof TaskState
   */
  category?: string;
  /**
   *
   * @type {Detail}
   * @memberof TaskState
   */
  detail?: Detail;
  /**
   *
   * @type {number}
   * @memberof TaskState
   */
  unix_millis_start_time?: number;
  /**
   *
   * @type {number}
   * @memberof TaskState
   */
  unix_millis_finish_time?: number;
  /**
   * An estimate, in milliseconds, of how long the subject will take to complete
   * @type {number}
   * @memberof TaskState
   */
  original_estimate_millis?: number;
  /**
   * An estimate, in milliseconds, of how long the subject will take to complete
   * @type {number}
   * @memberof TaskState
   */
  estimate_millis?: number;
  /**
   *
   * @type {AssignedTo}
   * @memberof TaskState
   */
  assigned_to?: AssignedTo;
  /**
   *
   * @type {Status}
   * @memberof TaskState
   */
  status?: Status;
  /**
   *
   * @type {Dispatch}
   * @memberof TaskState
   */
  dispatch?: Dispatch;
  /**
   * A dictionary of the states of the phases of the task. The keys (property names) are phase IDs, which are integers.
   * @type {{ [key: string]: Phase; }}
   * @memberof TaskState
   */
  phases?: { [key: string]: Phase };
  /**
   * An array of the IDs of completed phases of this task
   * @type {Array<number>}
   * @memberof TaskState
   */
  completed?: Array<number>;
  /**
   * The ID of the active phase for this task
   * @type {number}
   * @memberof TaskState
   */
  active?: number;
  /**
   * An array of the pending phases of this task
   * @type {Array<number>}
   * @memberof TaskState
   */
  pending?: Array<number>;
  /**
   * A dictionary of interruptions that have been applied to this task. The keys (property names) are the unique token of the interruption request.
   * @type {{ [key: string]: Interruption; }}
   * @memberof TaskState
   */
  interruptions?: { [key: string]: Interruption };
  /**
   *
   * @type {Cancellation1}
   * @memberof TaskState
   */
  cancellation?: Cancellation1;
  /**
   *
   * @type {Killed1}
   * @memberof TaskState
   */
  killed?: Killed1;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const Tier = {
  Uninitialized: 'uninitialized',
  Info: 'info',
  Warning: 'warning',
  Error: 'error',
} as const;

export type Tier = typeof Tier[keyof typeof Tier];

/**
 *
 * @export
 * @interface Time
 */
export interface Time {
  /**
   *
   * @type {number}
   * @memberof Time
   */
  sec: number;
  /**
   *
   * @type {number}
   * @memberof Time
   */
  nanosec: number;
}
/**
 *
 * @export
 * @interface Time1
 */
export interface Time1 {
  /**
   *
   * @type {number}
   * @memberof Time1
   */
  sec: number;
  /**
   *
   * @type {number}
   * @memberof Time1
   */
  nanosec: number;
}
/**
 * Template for defining a response message that provides a token upon success or errors upon failure
 * @export
 * @interface TokenResponse
 */
export interface TokenResponse {
  /**
   *
   * @type {ApiServerModelsRmfApiTokenResponseFailure}
   * @memberof TokenResponse
   */
  success: ApiServerModelsRmfApiTokenResponseFailure;
  /**
   * A token for the request. The value of this token is unique within the scope of this request and can be used by other requests to reference this request.
   * @type {string}
   * @memberof TokenResponse
   */
  token: string;
  /**
   * Any error messages explaining why the request failed.
   * @type {Array<Error>}
   * @memberof TokenResponse
   */
  errors: Array<Error>;
}
/**
 *
 * @export
 * @interface TokenResponseItem
 */
export interface TokenResponseItem {
  /**
   *
   * @type {ApiServerModelsRmfApiTokenResponseSuccess}
   * @memberof TokenResponseItem
   */
  success: ApiServerModelsRmfApiTokenResponseSuccess;
  /**
   * A token for the request. The value of this token is unique within the scope of this request and can be used by other requests to reference this request.
   * @type {string}
   * @memberof TokenResponseItem
   */
  token: string;
}
/**
 *
 * @export
 * @interface TokenResponseItem1
 */
export interface TokenResponseItem1 {
  /**
   *
   * @type {ApiServerModelsRmfApiTokenResponseFailure}
   * @memberof TokenResponseItem1
   */
  success: ApiServerModelsRmfApiTokenResponseFailure;
  /**
   * Any error messages explaining why the request failed.
   * @type {Array<Error>}
   * @memberof TokenResponseItem1
   */
  errors: Array<Error>;
}
/**
 *
 * @export
 * @interface Undo
 */
export interface Undo {
  /**
   * The time that the undo skip request arrived
   * @type {number}
   * @memberof Undo
   */
  unix_millis_request_time: number;
  /**
   * Labels to describe the undo skip request
   * @type {Array<string>}
   * @memberof Undo
   */
  labels: Array<string>;
}
/**
 * Information about an undo skip request that applied to this request
 * @export
 * @interface Undo1
 */
export interface Undo1 {
  /**
   * The time that the undo skip request arrived
   * @type {number}
   * @memberof Undo1
   */
  unix_millis_request_time: number;
  /**
   * Labels to describe the undo skip request
   * @type {Array<string>}
   * @memberof Undo1
   */
  labels: Array<string>;
}
/**
 *
 * @export
 * @interface UndoPhaseSkipRequest
 */
export interface UndoPhaseSkipRequest {
  /**
   * Indicate that this is a request to undo a phase skip request
   * @type {string}
   * @memberof UndoPhaseSkipRequest
   */
  type?: UndoPhaseSkipRequestTypeEnum;
  /**
   * Specify the relevant task ID
   * @type {string}
   * @memberof UndoPhaseSkipRequest
   */
  for_task?: string;
  /**
   * A list of the tokens of skip requests which should be undone. The skips associated with each token will be discarded.
   * @type {Array<string>}
   * @memberof UndoPhaseSkipRequest
   */
  for_tokens?: Array<string>;
  /**
   * Labels describing this request
   * @type {Array<string>}
   * @memberof UndoPhaseSkipRequest
   */
  labels?: Array<string>;
}

export const UndoPhaseSkipRequestTypeEnum = {
  UndoPhaseSkipRequest: 'undo_phase_skip_request',
} as const;

export type UndoPhaseSkipRequestTypeEnum =
  typeof UndoPhaseSkipRequestTypeEnum[keyof typeof UndoPhaseSkipRequestTypeEnum];

/**
 * Response to an undo phase skip request
 * @export
 * @interface UndoPhaseSkipResponse
 */
export interface UndoPhaseSkipResponse {
  /**
   *
   * @type {ApiServerModelsRmfApiSimpleResponseFailure}
   * @memberof UndoPhaseSkipResponse
   */
  success: ApiServerModelsRmfApiSimpleResponseFailure;
  /**
   * If the request failed, these error messages will explain why
   * @type {Array<Error>}
   * @memberof UndoPhaseSkipResponse
   */
  errors: Array<Error>;
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {string}
   * @memberof User
   */
  username: string;
  /**
   *
   * @type {boolean}
   * @memberof User
   */
  is_admin: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof User
   */
  roles: Array<string>;
}
/**
 *
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
  /**
   *
   * @type {Array<LocationInner>}
   * @memberof ValidationError
   */
  loc: Array<LocationInner>;
  /**
   *
   * @type {string}
   * @memberof ValidationError
   */
  msg: string;
  /**
   *
   * @type {string}
   * @memberof ValidationError
   */
  type: string;
}
/**
 *
 * @export
 * @interface WallGraph
 */
export interface WallGraph {
  /**
   *
   * @type {string}
   * @memberof WallGraph
   */
  name: string;
  /**
   *
   * @type {Array<GraphNode>}
   * @memberof WallGraph
   */
  vertices: Array<GraphNode>;
  /**
   *
   * @type {Array<GraphEdge>}
   * @memberof WallGraph
   */
  edges: Array<GraphEdge>;
  /**
   *
   * @type {Array<Param>}
   * @memberof WallGraph
   */
  params: Array<Param>;
}

/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Add a permission to a role
     * @summary Add Role Permission
     * @param {string} role
     * @param {Permission} permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addRolePermissionAdminRolesRolePermissionsPost: async (
      role: string,
      permission: Permission,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'role' is not null or undefined
      assertParamExists('addRolePermissionAdminRolesRolePermissionsPost', 'role', role);
      // verify required parameter 'permission' is not null or undefined
      assertParamExists('addRolePermissionAdminRolesRolePermissionsPost', 'permission', permission);
      const localVarPath = `/admin/roles/{role}/permissions`.replace(
        `{${'role'}}`,
        encodeURIComponent(String(role)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        permission,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Add role to a user
     * @summary Add User Role
     * @param {string} username
     * @param {PostRoles} postRoles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUserRoleAdminUsersUsernameRolesPost: async (
      username: string,
      postRoles: PostRoles,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists('addUserRoleAdminUsersUsernameRolesPost', 'username', username);
      // verify required parameter 'postRoles' is not null or undefined
      assertParamExists('addUserRoleAdminUsersUsernameRolesPost', 'postRoles', postRoles);
      const localVarPath = `/admin/users/{username}/roles`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        postRoles,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a new role
     * @summary Create Role
     * @param {PostRoles} postRoles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRoleAdminRolesPost: async (
      postRoles: PostRoles,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'postRoles' is not null or undefined
      assertParamExists('createRoleAdminRolesPost', 'postRoles', postRoles);
      const localVarPath = `/admin/roles`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        postRoles,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a user
     * @summary Create User
     * @param {PostUsers} postUsers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUserAdminUsersPost: async (
      postUsers: PostUsers,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'postUsers' is not null or undefined
      assertParamExists('createUserAdminUsersPost', 'postUsers', postUsers);
      const localVarPath = `/admin/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        postUsers,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a role
     * @summary Delete Role
     * @param {string} role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRoleAdminRolesRoleDelete: async (
      role: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'role' is not null or undefined
      assertParamExists('deleteRoleAdminRolesRoleDelete', 'role', role);
      const localVarPath = `/admin/roles/{role}`.replace(
        `{${'role'}}`,
        encodeURIComponent(String(role)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a user  This only performs a soft delete, while the user is deleted from the app database, it still exists in the idp so they can still log in, the user will then be re-created with the default permissions.
     * @summary Delete User
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserAdminUsersUsernameDelete: async (
      username: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists('deleteUserAdminUsersUsernameDelete', 'username', username);
      const localVarPath = `/admin/users/{username}`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Remove role from a user
     * @summary Delete User Role
     * @param {string} username
     * @param {string} role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserRoleAdminUsersUsernameRolesRoleDelete: async (
      username: string,
      role: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists('deleteUserRoleAdminUsersUsernameRolesRoleDelete', 'username', username);
      // verify required parameter 'role' is not null or undefined
      assertParamExists('deleteUserRoleAdminUsersUsernameRolesRoleDelete', 'role', role);
      const localVarPath = `/admin/users/{username}/roles/{role}`
        .replace(`{${'username'}}`, encodeURIComponent(String(username)))
        .replace(`{${'role'}}`, encodeURIComponent(String(role)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get all permissions of a role
     * @summary Get Role Permissions
     * @param {string} role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRolePermissionsAdminRolesRolePermissionsGet: async (
      role: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'role' is not null or undefined
      assertParamExists('getRolePermissionsAdminRolesRolePermissionsGet', 'role', role);
      const localVarPath = `/admin/roles/{role}/permissions`.replace(
        `{${'role'}}`,
        encodeURIComponent(String(role)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get all roles
     * @summary Get Roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRolesAdminRolesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/admin/roles`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a user
     * @summary Get User
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserAdminUsersUsernameGet: async (
      username: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists('getUserAdminUsersUsernameGet', 'username', username);
      const localVarPath = `/admin/users/{username}`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Search users
     * @summary Get Users
     * @param {string} [username] filters username that starts with the value
     * @param {boolean} [isAdmin]
     * @param {number} [limit] defaults to 100
     * @param {number} [offset] defaults to 0
     * @param {string} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersAdminUsersGet: async (
      username?: string,
      isAdmin?: boolean,
      limit?: number,
      offset?: number,
      orderBy?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/admin/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (username !== undefined) {
        localVarQueryParameter['username'] = username;
      }

      if (isAdmin !== undefined) {
        localVarQueryParameter['is_admin'] = isAdmin;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['order_by'] = orderBy;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Make or remove admin privilege from a user
     * @summary Make Admin
     * @param {string} username
     * @param {PostMakeAdmin} postMakeAdmin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    makeAdminAdminUsersUsernameMakeAdminPost: async (
      username: string,
      postMakeAdmin: PostMakeAdmin,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists('makeAdminAdminUsersUsernameMakeAdminPost', 'username', username);
      // verify required parameter 'postMakeAdmin' is not null or undefined
      assertParamExists('makeAdminAdminUsersUsernameMakeAdminPost', 'postMakeAdmin', postMakeAdmin);
      const localVarPath = `/admin/users/{username}/make_admin`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        postMakeAdmin,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a permission from a role
     * @summary Remove Role Permission
     * @param {string} role
     * @param {Permission} permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeRolePermissionAdminRolesRolePermissionsRemovePost: async (
      role: string,
      permission: Permission,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'role' is not null or undefined
      assertParamExists('removeRolePermissionAdminRolesRolePermissionsRemovePost', 'role', role);
      // verify required parameter 'permission' is not null or undefined
      assertParamExists(
        'removeRolePermissionAdminRolesRolePermissionsRemovePost',
        'permission',
        permission,
      );
      const localVarPath = `/admin/roles/{role}/permissions/remove`.replace(
        `{${'role'}}`,
        encodeURIComponent(String(role)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        permission,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Set the roles of a user
     * @summary Set User Roles
     * @param {string} username
     * @param {Array<PostRoles>} postRoles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserRolesAdminUsersUsernameRolesPut: async (
      username: string,
      postRoles: Array<PostRoles>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists('setUserRolesAdminUsersUsernameRolesPut', 'username', username);
      // verify required parameter 'postRoles' is not null or undefined
      assertParamExists('setUserRolesAdminUsersUsernameRolesPut', 'postRoles', postRoles);
      const localVarPath = `/admin/users/{username}/roles`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        postRoles,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration);
  return {
    /**
     * Add a permission to a role
     * @summary Add Role Permission
     * @param {string} role
     * @param {Permission} permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addRolePermissionAdminRolesRolePermissionsPost(
      role: string,
      permission: Permission,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.addRolePermissionAdminRolesRolePermissionsPost(
          role,
          permission,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Add role to a user
     * @summary Add User Role
     * @param {string} username
     * @param {PostRoles} postRoles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addUserRoleAdminUsersUsernameRolesPost(
      username: string,
      postRoles: PostRoles,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.addUserRoleAdminUsersUsernameRolesPost(
          username,
          postRoles,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Create a new role
     * @summary Create Role
     * @param {PostRoles} postRoles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRoleAdminRolesPost(
      postRoles: PostRoles,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createRoleAdminRolesPost(
        postRoles,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Create a user
     * @summary Create User
     * @param {PostUsers} postUsers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createUserAdminUsersPost(
      postUsers: PostUsers,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createUserAdminUsersPost(
        postUsers,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Delete a role
     * @summary Delete Role
     * @param {string} role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteRoleAdminRolesRoleDelete(
      role: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRoleAdminRolesRoleDelete(
        role,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Delete a user  This only performs a soft delete, while the user is deleted from the app database, it still exists in the idp so they can still log in, the user will then be re-created with the default permissions.
     * @summary Delete User
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUserAdminUsersUsernameDelete(
      username: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserAdminUsersUsernameDelete(
        username,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Remove role from a user
     * @summary Delete User Role
     * @param {string} username
     * @param {string} role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUserRoleAdminUsersUsernameRolesRoleDelete(
      username: string,
      role: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteUserRoleAdminUsersUsernameRolesRoleDelete(
          username,
          role,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get all permissions of a role
     * @summary Get Role Permissions
     * @param {string} role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRolePermissionsAdminRolesRolePermissionsGet(
      role: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Permission>>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getRolePermissionsAdminRolesRolePermissionsGet(
          role,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get all roles
     * @summary Get Roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRolesAdminRolesGet(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRolesAdminRolesGet(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get a user
     * @summary Get User
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserAdminUsersUsernameGet(
      username: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAdminUsersUsernameGet(
        username,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Search users
     * @summary Get Users
     * @param {string} [username] filters username that starts with the value
     * @param {boolean} [isAdmin]
     * @param {number} [limit] defaults to 100
     * @param {number} [offset] defaults to 0
     * @param {string} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsersAdminUsersGet(
      username?: string,
      isAdmin?: boolean,
      limit?: number,
      offset?: number,
      orderBy?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersAdminUsersGet(
        username,
        isAdmin,
        limit,
        offset,
        orderBy,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Make or remove admin privilege from a user
     * @summary Make Admin
     * @param {string} username
     * @param {PostMakeAdmin} postMakeAdmin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async makeAdminAdminUsersUsernameMakeAdminPost(
      username: string,
      postMakeAdmin: PostMakeAdmin,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.makeAdminAdminUsersUsernameMakeAdminPost(
          username,
          postMakeAdmin,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Delete a permission from a role
     * @summary Remove Role Permission
     * @param {string} role
     * @param {Permission} permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeRolePermissionAdminRolesRolePermissionsRemovePost(
      role: string,
      permission: Permission,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.removeRolePermissionAdminRolesRolePermissionsRemovePost(
          role,
          permission,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Set the roles of a user
     * @summary Set User Roles
     * @param {string} username
     * @param {Array<PostRoles>} postRoles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setUserRolesAdminUsersUsernameRolesPut(
      username: string,
      postRoles: Array<PostRoles>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.setUserRolesAdminUsersUsernameRolesPut(
          username,
          postRoles,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AdminApiFp(configuration);
  return {
    /**
     * Add a permission to a role
     * @summary Add Role Permission
     * @param {string} role
     * @param {Permission} permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addRolePermissionAdminRolesRolePermissionsPost(
      role: string,
      permission: Permission,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .addRolePermissionAdminRolesRolePermissionsPost(role, permission, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Add role to a user
     * @summary Add User Role
     * @param {string} username
     * @param {PostRoles} postRoles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUserRoleAdminUsersUsernameRolesPost(
      username: string,
      postRoles: PostRoles,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .addUserRoleAdminUsersUsernameRolesPost(username, postRoles, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a new role
     * @summary Create Role
     * @param {PostRoles} postRoles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRoleAdminRolesPost(postRoles: PostRoles, options?: any): AxiosPromise<any> {
      return localVarFp
        .createRoleAdminRolesPost(postRoles, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a user
     * @summary Create User
     * @param {PostUsers} postUsers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUserAdminUsersPost(postUsers: PostUsers, options?: any): AxiosPromise<any> {
      return localVarFp
        .createUserAdminUsersPost(postUsers, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete a role
     * @summary Delete Role
     * @param {string} role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRoleAdminRolesRoleDelete(role: string, options?: any): AxiosPromise<any> {
      return localVarFp
        .deleteRoleAdminRolesRoleDelete(role, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete a user  This only performs a soft delete, while the user is deleted from the app database, it still exists in the idp so they can still log in, the user will then be re-created with the default permissions.
     * @summary Delete User
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserAdminUsersUsernameDelete(username: string, options?: any): AxiosPromise<any> {
      return localVarFp
        .deleteUserAdminUsersUsernameDelete(username, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Remove role from a user
     * @summary Delete User Role
     * @param {string} username
     * @param {string} role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserRoleAdminUsersUsernameRolesRoleDelete(
      username: string,
      role: string,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .deleteUserRoleAdminUsersUsernameRolesRoleDelete(username, role, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get all permissions of a role
     * @summary Get Role Permissions
     * @param {string} role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRolePermissionsAdminRolesRolePermissionsGet(
      role: string,
      options?: any,
    ): AxiosPromise<Array<Permission>> {
      return localVarFp
        .getRolePermissionsAdminRolesRolePermissionsGet(role, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get all roles
     * @summary Get Roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRolesAdminRolesGet(options?: any): AxiosPromise<Array<string>> {
      return localVarFp.getRolesAdminRolesGet(options).then((request) => request(axios, basePath));
    },
    /**
     * Get a user
     * @summary Get User
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserAdminUsersUsernameGet(username: string, options?: any): AxiosPromise<User> {
      return localVarFp
        .getUserAdminUsersUsernameGet(username, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Search users
     * @summary Get Users
     * @param {string} [username] filters username that starts with the value
     * @param {boolean} [isAdmin]
     * @param {number} [limit] defaults to 100
     * @param {number} [offset] defaults to 0
     * @param {string} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersAdminUsersGet(
      username?: string,
      isAdmin?: boolean,
      limit?: number,
      offset?: number,
      orderBy?: string,
      options?: any,
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .getUsersAdminUsersGet(username, isAdmin, limit, offset, orderBy, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Make or remove admin privilege from a user
     * @summary Make Admin
     * @param {string} username
     * @param {PostMakeAdmin} postMakeAdmin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    makeAdminAdminUsersUsernameMakeAdminPost(
      username: string,
      postMakeAdmin: PostMakeAdmin,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .makeAdminAdminUsersUsernameMakeAdminPost(username, postMakeAdmin, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete a permission from a role
     * @summary Remove Role Permission
     * @param {string} role
     * @param {Permission} permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeRolePermissionAdminRolesRolePermissionsRemovePost(
      role: string,
      permission: Permission,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .removeRolePermissionAdminRolesRolePermissionsRemovePost(role, permission, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Set the roles of a user
     * @summary Set User Roles
     * @param {string} username
     * @param {Array<PostRoles>} postRoles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserRolesAdminUsersUsernameRolesPut(
      username: string,
      postRoles: Array<PostRoles>,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .setUserRolesAdminUsersUsernameRolesPut(username, postRoles, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
  /**
   * Add a permission to a role
   * @summary Add Role Permission
   * @param {string} role
   * @param {Permission} permission
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public addRolePermissionAdminRolesRolePermissionsPost(
    role: string,
    permission: Permission,
    options?: AxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .addRolePermissionAdminRolesRolePermissionsPost(role, permission, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Add role to a user
   * @summary Add User Role
   * @param {string} username
   * @param {PostRoles} postRoles
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public addUserRoleAdminUsersUsernameRolesPost(
    username: string,
    postRoles: PostRoles,
    options?: AxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .addUserRoleAdminUsersUsernameRolesPost(username, postRoles, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a new role
   * @summary Create Role
   * @param {PostRoles} postRoles
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public createRoleAdminRolesPost(postRoles: PostRoles, options?: AxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .createRoleAdminRolesPost(postRoles, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a user
   * @summary Create User
   * @param {PostUsers} postUsers
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public createUserAdminUsersPost(postUsers: PostUsers, options?: AxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .createUserAdminUsersPost(postUsers, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete a role
   * @summary Delete Role
   * @param {string} role
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public deleteRoleAdminRolesRoleDelete(role: string, options?: AxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .deleteRoleAdminRolesRoleDelete(role, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete a user  This only performs a soft delete, while the user is deleted from the app database, it still exists in the idp so they can still log in, the user will then be re-created with the default permissions.
   * @summary Delete User
   * @param {string} username
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public deleteUserAdminUsersUsernameDelete(username: string, options?: AxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .deleteUserAdminUsersUsernameDelete(username, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Remove role from a user
   * @summary Delete User Role
   * @param {string} username
   * @param {string} role
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public deleteUserRoleAdminUsersUsernameRolesRoleDelete(
    username: string,
    role: string,
    options?: AxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .deleteUserRoleAdminUsersUsernameRolesRoleDelete(username, role, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get all permissions of a role
   * @summary Get Role Permissions
   * @param {string} role
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public getRolePermissionsAdminRolesRolePermissionsGet(
    role: string,
    options?: AxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .getRolePermissionsAdminRolesRolePermissionsGet(role, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get all roles
   * @summary Get Roles
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public getRolesAdminRolesGet(options?: AxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .getRolesAdminRolesGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a user
   * @summary Get User
   * @param {string} username
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public getUserAdminUsersUsernameGet(username: string, options?: AxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .getUserAdminUsersUsernameGet(username, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Search users
   * @summary Get Users
   * @param {string} [username] filters username that starts with the value
   * @param {boolean} [isAdmin]
   * @param {number} [limit] defaults to 100
   * @param {number} [offset] defaults to 0
   * @param {string} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public getUsersAdminUsersGet(
    username?: string,
    isAdmin?: boolean,
    limit?: number,
    offset?: number,
    orderBy?: string,
    options?: AxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .getUsersAdminUsersGet(username, isAdmin, limit, offset, orderBy, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Make or remove admin privilege from a user
   * @summary Make Admin
   * @param {string} username
   * @param {PostMakeAdmin} postMakeAdmin
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public makeAdminAdminUsersUsernameMakeAdminPost(
    username: string,
    postMakeAdmin: PostMakeAdmin,
    options?: AxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .makeAdminAdminUsersUsernameMakeAdminPost(username, postMakeAdmin, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete a permission from a role
   * @summary Remove Role Permission
   * @param {string} role
   * @param {Permission} permission
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public removeRolePermissionAdminRolesRolePermissionsRemovePost(
    role: string,
    permission: Permission,
    options?: AxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .removeRolePermissionAdminRolesRolePermissionsRemovePost(role, permission, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Set the roles of a user
   * @summary Set User Roles
   * @param {string} username
   * @param {Array<PostRoles>} postRoles
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public setUserRolesAdminUsersUsernameRolesPut(
    username: string,
    postRoles: Array<PostRoles>,
    options?: AxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .setUserRolesAdminUsersUsernameRolesPut(username, postRoles, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * AlertsApi - axios parameter creator
 * @export
 */
export const AlertsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Acknowledge Alert
     * @param {string} alertId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    acknowledgeAlertAlertsAlertIdPost: async (
      alertId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'alertId' is not null or undefined
      assertParamExists('acknowledgeAlertAlertsAlertIdPost', 'alertId', alertId);
      const localVarPath = `/alerts/{alert_id}`.replace(
        `{${'alert_id'}}`,
        encodeURIComponent(String(alertId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create Alert
     * @param {string} alertId
     * @param {string} category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAlertAlertsPost: async (
      alertId: string,
      category: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'alertId' is not null or undefined
      assertParamExists('createAlertAlertsPost', 'alertId', alertId);
      // verify required parameter 'category' is not null or undefined
      assertParamExists('createAlertAlertsPost', 'category', category);
      const localVarPath = `/alerts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (alertId !== undefined) {
        localVarQueryParameter['alert_id'] = alertId;
      }

      if (category !== undefined) {
        localVarQueryParameter['category'] = category;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Alert
     * @param {string} alertId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAlertAlertsAlertIdGet: async (
      alertId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'alertId' is not null or undefined
      assertParamExists('getAlertAlertsAlertIdGet', 'alertId', alertId);
      const localVarPath = `/alerts/{alert_id}`.replace(
        `{${'alert_id'}}`,
        encodeURIComponent(String(alertId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Alerts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAlertsAlertsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/alerts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AlertsApi - functional programming interface
 * @export
 */
export const AlertsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AlertsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Acknowledge Alert
     * @param {string} alertId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async acknowledgeAlertAlertsAlertIdPost(
      alertId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ApiServerModelsTortoiseModelsAlertsAlertLeaf>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.acknowledgeAlertAlertsAlertIdPost(
        alertId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Create Alert
     * @param {string} alertId
     * @param {string} category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createAlertAlertsPost(
      alertId: string,
      category: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ApiServerModelsTortoiseModelsAlertsAlertLeaf>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createAlertAlertsPost(
        alertId,
        category,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get Alert
     * @param {string} alertId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAlertAlertsAlertIdGet(
      alertId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ApiServerModelsTortoiseModelsAlertsAlertLeaf>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAlertAlertsAlertIdGet(
        alertId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get Alerts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAlertsAlertsGet(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<ApiServerModelsTortoiseModelsAlertsAlertLeaf>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAlertsAlertsGet(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * AlertsApi - factory interface
 * @export
 */
export const AlertsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AlertsApiFp(configuration);
  return {
    /**
     *
     * @summary Acknowledge Alert
     * @param {string} alertId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    acknowledgeAlertAlertsAlertIdPost(
      alertId: string,
      options?: any,
    ): AxiosPromise<ApiServerModelsTortoiseModelsAlertsAlertLeaf> {
      return localVarFp
        .acknowledgeAlertAlertsAlertIdPost(alertId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create Alert
     * @param {string} alertId
     * @param {string} category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAlertAlertsPost(
      alertId: string,
      category: string,
      options?: any,
    ): AxiosPromise<ApiServerModelsTortoiseModelsAlertsAlertLeaf> {
      return localVarFp
        .createAlertAlertsPost(alertId, category, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Alert
     * @param {string} alertId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAlertAlertsAlertIdGet(
      alertId: string,
      options?: any,
    ): AxiosPromise<ApiServerModelsTortoiseModelsAlertsAlertLeaf> {
      return localVarFp
        .getAlertAlertsAlertIdGet(alertId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Alerts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAlertsAlertsGet(
      options?: any,
    ): AxiosPromise<Array<ApiServerModelsTortoiseModelsAlertsAlertLeaf>> {
      return localVarFp.getAlertsAlertsGet(options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * AlertsApi - object-oriented interface
 * @export
 * @class AlertsApi
 * @extends {BaseAPI}
 */
export class AlertsApi extends BaseAPI {
  /**
   *
   * @summary Acknowledge Alert
   * @param {string} alertId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AlertsApi
   */
  public acknowledgeAlertAlertsAlertIdPost(alertId: string, options?: AxiosRequestConfig) {
    return AlertsApiFp(this.configuration)
      .acknowledgeAlertAlertsAlertIdPost(alertId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create Alert
   * @param {string} alertId
   * @param {string} category
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AlertsApi
   */
  public createAlertAlertsPost(alertId: string, category: string, options?: AxiosRequestConfig) {
    return AlertsApiFp(this.configuration)
      .createAlertAlertsPost(alertId, category, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Alert
   * @param {string} alertId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AlertsApi
   */
  public getAlertAlertsAlertIdGet(alertId: string, options?: AxiosRequestConfig) {
    return AlertsApiFp(this.configuration)
      .getAlertAlertsAlertIdGet(alertId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Alerts
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AlertsApi
   */
  public getAlertsAlertsGet(options?: AxiosRequestConfig) {
    return AlertsApiFp(this.configuration)
      .getAlertsAlertsGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * BeaconsApi - axios parameter creator
 * @export
 */
export const BeaconsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get Beacon
     * @param {string} beaconId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBeaconBeaconsBeaconIdGet: async (
      beaconId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'beaconId' is not null or undefined
      assertParamExists('getBeaconBeaconsBeaconIdGet', 'beaconId', beaconId);
      const localVarPath = `/beacons/{beacon_id}`.replace(
        `{${'beacon_id'}}`,
        encodeURIComponent(String(beaconId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Beacons
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBeaconsBeaconsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/beacons`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Save Beacon State
     * @param {string} beaconId
     * @param {boolean} online
     * @param {string} category
     * @param {boolean} activated
     * @param {string} level
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveBeaconStateBeaconsPost: async (
      beaconId: string,
      online: boolean,
      category: string,
      activated: boolean,
      level: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'beaconId' is not null or undefined
      assertParamExists('saveBeaconStateBeaconsPost', 'beaconId', beaconId);
      // verify required parameter 'online' is not null or undefined
      assertParamExists('saveBeaconStateBeaconsPost', 'online', online);
      // verify required parameter 'category' is not null or undefined
      assertParamExists('saveBeaconStateBeaconsPost', 'category', category);
      // verify required parameter 'activated' is not null or undefined
      assertParamExists('saveBeaconStateBeaconsPost', 'activated', activated);
      // verify required parameter 'level' is not null or undefined
      assertParamExists('saveBeaconStateBeaconsPost', 'level', level);
      const localVarPath = `/beacons`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (beaconId !== undefined) {
        localVarQueryParameter['beacon_id'] = beaconId;
      }

      if (online !== undefined) {
        localVarQueryParameter['online'] = online;
      }

      if (category !== undefined) {
        localVarQueryParameter['category'] = category;
      }

      if (activated !== undefined) {
        localVarQueryParameter['activated'] = activated;
      }

      if (level !== undefined) {
        localVarQueryParameter['level'] = level;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * BeaconsApi - functional programming interface
 * @export
 */
export const BeaconsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = BeaconsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Get Beacon
     * @param {string} beaconId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBeaconBeaconsBeaconIdGet(
      beaconId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ApiServerModelsTortoiseModelsBeaconsBeaconStateLeaf>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBeaconBeaconsBeaconIdGet(
        beaconId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get Beacons
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBeaconsBeaconsGet(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<ApiServerModelsTortoiseModelsBeaconsBeaconStateLeaf>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBeaconsBeaconsGet(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Save Beacon State
     * @param {string} beaconId
     * @param {boolean} online
     * @param {string} category
     * @param {boolean} activated
     * @param {string} level
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async saveBeaconStateBeaconsPost(
      beaconId: string,
      online: boolean,
      category: string,
      activated: boolean,
      level: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ApiServerModelsTortoiseModelsBeaconsBeaconStateLeaf>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.saveBeaconStateBeaconsPost(
        beaconId,
        online,
        category,
        activated,
        level,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * BeaconsApi - factory interface
 * @export
 */
export const BeaconsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = BeaconsApiFp(configuration);
  return {
    /**
     *
     * @summary Get Beacon
     * @param {string} beaconId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBeaconBeaconsBeaconIdGet(
      beaconId: string,
      options?: any,
    ): AxiosPromise<ApiServerModelsTortoiseModelsBeaconsBeaconStateLeaf> {
      return localVarFp
        .getBeaconBeaconsBeaconIdGet(beaconId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Beacons
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBeaconsBeaconsGet(
      options?: any,
    ): AxiosPromise<Array<ApiServerModelsTortoiseModelsBeaconsBeaconStateLeaf>> {
      return localVarFp.getBeaconsBeaconsGet(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Save Beacon State
     * @param {string} beaconId
     * @param {boolean} online
     * @param {string} category
     * @param {boolean} activated
     * @param {string} level
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveBeaconStateBeaconsPost(
      beaconId: string,
      online: boolean,
      category: string,
      activated: boolean,
      level: string,
      options?: any,
    ): AxiosPromise<ApiServerModelsTortoiseModelsBeaconsBeaconStateLeaf> {
      return localVarFp
        .saveBeaconStateBeaconsPost(beaconId, online, category, activated, level, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * BeaconsApi - object-oriented interface
 * @export
 * @class BeaconsApi
 * @extends {BaseAPI}
 */
export class BeaconsApi extends BaseAPI {
  /**
   *
   * @summary Get Beacon
   * @param {string} beaconId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconsApi
   */
  public getBeaconBeaconsBeaconIdGet(beaconId: string, options?: AxiosRequestConfig) {
    return BeaconsApiFp(this.configuration)
      .getBeaconBeaconsBeaconIdGet(beaconId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Beacons
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconsApi
   */
  public getBeaconsBeaconsGet(options?: AxiosRequestConfig) {
    return BeaconsApiFp(this.configuration)
      .getBeaconsBeaconsGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Save Beacon State
   * @param {string} beaconId
   * @param {boolean} online
   * @param {string} category
   * @param {boolean} activated
   * @param {string} level
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconsApi
   */
  public saveBeaconStateBeaconsPost(
    beaconId: string,
    online: boolean,
    category: string,
    activated: boolean,
    level: string,
    options?: AxiosRequestConfig,
  ) {
    return BeaconsApiFp(this.configuration)
      .saveBeaconStateBeaconsPost(beaconId, online, category, activated, level, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * BuildingApi - axios parameter creator
 * @export
 */
export const BuildingApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Available in socket.io
     * @summary Get Building Map
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildingMapBuildingMapGet: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/building_map`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * BuildingApi - functional programming interface
 * @export
 */
export const BuildingApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = BuildingApiAxiosParamCreator(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Building Map
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBuildingMapBuildingMapGet(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BuildingMap>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBuildingMapBuildingMapGet(
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * BuildingApi - factory interface
 * @export
 */
export const BuildingApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = BuildingApiFp(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Building Map
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildingMapBuildingMapGet(options?: any): AxiosPromise<BuildingMap> {
      return localVarFp
        .getBuildingMapBuildingMapGet(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * BuildingApi - object-oriented interface
 * @export
 * @class BuildingApi
 * @extends {BaseAPI}
 */
export class BuildingApi extends BaseAPI {
  /**
   * Available in socket.io
   * @summary Get Building Map
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildingApi
   */
  public getBuildingMapBuildingMapGet(options?: AxiosRequestConfig) {
    return BuildingApiFp(this.configuration)
      .getBuildingMapBuildingMapGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Get the effective permissions of the current user
     * @summary Get Effective Permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEffectivePermissionsPermissionsGet: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/permissions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the current rmf time in unix milliseconds
     * @summary Get Time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTimeTimeGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/time`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the currently logged in user
     * @summary Get User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserUserGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/user`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  # NOTE: This endpoint is here for documentation purposes only, this is _not_ a REST endpoint.  ## About This exposes a minimal pubsub system built on top of socket.io. It works similar to a normal socket.io endpoint, except that are 2 special rooms which control subscriptions.  ## Rooms ### subscribe Clients must send a message to this room to start receiving messages on other rooms. The message must be of the form:  ``` {     \"room\": \"<room_name>\" } ```  ### unsubscribe Clients can send a message to this room to stop receiving messages on other rooms. The message must be of the form:  ``` {     \"room\": \"<room_name>\" } ```              ### /alerts   ``` {   \"title\": \"Alert\",   \"description\": \"General alert that can be triggered by events.\",   \"type\": \"object\",   \"properties\": {     \"id\": {       \"title\": \"Id\",       \"maxLength\": 255,       \"type\": \"string\"     },     \"original_id\": {       \"title\": \"Original Id\",       \"maxLength\": 255,       \"type\": \"string\"     },     \"category\": {       \"title\": \"Category\",       \"description\": \"Default: default<br/>Task: task<br/>Fleet: fleet<br/>Robot: robot\",       \"maxLength\": 7,       \"type\": \"string\"     },     \"unix_millis_created_time\": {       \"title\": \"Unix Millis Created Time\",       \"minimum\": -9223372036854775808,       \"maximum\": 9223372036854775807,       \"type\": \"integer\"     },     \"acknowledged_by\": {       \"title\": \"Acknowledged By\",       \"maxLength\": 255,       \"nullable\": true,       \"type\": \"string\"     },     \"unix_millis_acknowledged_time\": {       \"title\": \"Unix Millis Acknowledged Time\",       \"minimum\": -9223372036854775808,       \"maximum\": 9223372036854775807,       \"nullable\": true,       \"type\": \"integer\"     }   },   \"required\": [     \"id\",     \"original_id\",     \"category\",     \"unix_millis_created_time\"   ],   \"additionalProperties\": false } ```   ### /beacons   ``` {   \"title\": \"BeaconState\",   \"type\": \"object\",   \"properties\": {     \"id\": {       \"title\": \"Id\",       \"maxLength\": 255,       \"type\": \"string\"     },     \"online\": {       \"title\": \"Online\",       \"type\": \"boolean\"     },     \"category\": {       \"title\": \"Category\",       \"maxLength\": 255,       \"nullable\": true,       \"type\": \"string\"     },     \"activated\": {       \"title\": \"Activated\",       \"type\": \"boolean\"     },     \"level\": {       \"title\": \"Level\",       \"maxLength\": 255,       \"nullable\": true,       \"type\": \"string\"     }   },   \"required\": [     \"id\",     \"online\",     \"activated\"   ],   \"additionalProperties\": false } ```   ### /building_map   ``` {   \"title\": \"BuildingMap\",   \"type\": \"object\",   \"properties\": {     \"name\": {       \"title\": \"Name\",       \"default\": \"\",       \"type\": \"string\"     },     \"levels\": {       \"title\": \"Levels\",       \"type\": \"array\",       \"items\": {         \"$ref\": \"#/definitions/Level\"       }     },     \"lifts\": {       \"title\": \"Lifts\",       \"default\": [],       \"type\": \"array\",       \"items\": {         \"$ref\": \"#/definitions/Lift\"       }     }   },   \"required\": [     \"name\",     \"levels\",     \"lifts\"   ],   \"definitions\": {     \"AffineImage\": {       \"title\": \"AffineImage\",       \"type\": \"object\",       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"default\": \"\",           \"type\": \"string\"         },         \"x_offset\": {           \"title\": \"X Offset\",           \"default\": 0,           \"type\": \"number\"         },         \"y_offset\": {           \"title\": \"Y Offset\",           \"default\": 0,           \"type\": \"number\"         },         \"yaw\": {           \"title\": \"Yaw\",           \"default\": 0,           \"type\": \"number\"         },         \"scale\": {           \"title\": \"Scale\",           \"default\": 0,           \"type\": \"number\"         },         \"encoding\": {           \"title\": \"Encoding\",           \"default\": \"\",           \"type\": \"string\"         },         \"data\": {           \"title\": \"Data\",           \"type\": \"string\"         }       },       \"required\": [         \"name\",         \"x_offset\",         \"y_offset\",         \"yaw\",         \"scale\",         \"encoding\",         \"data\"       ]     },     \"Place\": {       \"title\": \"Place\",       \"type\": \"object\",       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"default\": \"\",           \"type\": \"string\"         },         \"x\": {           \"title\": \"X\",           \"default\": 0,           \"type\": \"number\"         },         \"y\": {           \"title\": \"Y\",           \"default\": 0,           \"type\": \"number\"         },         \"yaw\": {           \"title\": \"Yaw\",           \"default\": 0,           \"type\": \"number\"         },         \"position_tolerance\": {           \"title\": \"Position Tolerance\",           \"default\": 0,           \"type\": \"number\"         },         \"yaw_tolerance\": {           \"title\": \"Yaw Tolerance\",           \"default\": 0,           \"type\": \"number\"         }       },       \"required\": [         \"name\",         \"x\",         \"y\",         \"yaw\",         \"position_tolerance\",         \"yaw_tolerance\"       ]     },     \"Door\": {       \"title\": \"Door\",       \"type\": \"object\",       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"default\": \"\",           \"type\": \"string\"         },         \"v1_x\": {           \"title\": \"V1 X\",           \"default\": 0,           \"type\": \"number\"         },         \"v1_y\": {           \"title\": \"V1 Y\",           \"default\": 0,           \"type\": \"number\"         },         \"v2_x\": {           \"title\": \"V2 X\",           \"default\": 0,           \"type\": \"number\"         },         \"v2_y\": {           \"title\": \"V2 Y\",           \"default\": 0,           \"type\": \"number\"         },         \"door_type\": {           \"title\": \"Door Type\",           \"default\": 0,           \"minimum\": 0,           \"maximum\": 255,           \"type\": \"integer\"         },         \"motion_range\": {           \"title\": \"Motion Range\",           \"default\": 0,           \"type\": \"number\"         },         \"motion_direction\": {           \"title\": \"Motion Direction\",           \"default\": 0,           \"minimum\": -2147483648,           \"maximum\": 2147483647,           \"type\": \"integer\"         }       },       \"required\": [         \"name\",         \"v1_x\",         \"v1_y\",         \"v2_x\",         \"v2_y\",         \"door_type\",         \"motion_range\",         \"motion_direction\"       ]     },     \"Param\": {       \"title\": \"Param\",       \"type\": \"object\",       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"default\": \"\",           \"type\": \"string\"         },         \"type\": {           \"title\": \"Type\",           \"default\": 0,           \"minimum\": 0,           \"maximum\": 4294967295,           \"type\": \"integer\"         },         \"value_int\": {           \"title\": \"Value Int\",           \"default\": 0,           \"minimum\": -2147483648,           \"maximum\": 2147483647,           \"type\": \"integer\"         },         \"value_float\": {           \"title\": \"Value Float\",           \"default\": 0,           \"type\": \"number\"         },         \"value_string\": {           \"title\": \"Value String\",           \"default\": \"\",           \"type\": \"string\"         },         \"value_bool\": {           \"title\": \"Value Bool\",           \"default\": false,           \"type\": \"boolean\"         }       },       \"required\": [         \"name\",         \"type\",         \"value_int\",         \"value_float\",         \"value_string\",         \"value_bool\"       ]     },     \"GraphNode\": {       \"title\": \"GraphNode\",       \"type\": \"object\",       \"properties\": {         \"x\": {           \"title\": \"X\",           \"default\": 0,           \"type\": \"number\"         },         \"y\": {           \"title\": \"Y\",           \"default\": 0,           \"type\": \"number\"         },         \"name\": {           \"title\": \"Name\",           \"default\": \"\",           \"type\": \"string\"         },         \"params\": {           \"title\": \"Params\",           \"default\": [],           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/Param\"           }         }       },       \"required\": [         \"x\",         \"y\",         \"name\",         \"params\"       ]     },     \"GraphEdge\": {       \"title\": \"GraphEdge\",       \"type\": \"object\",       \"properties\": {         \"v1_idx\": {           \"title\": \"V1 Idx\",           \"default\": 0,           \"minimum\": 0,           \"maximum\": 4294967295,           \"type\": \"integer\"         },         \"v2_idx\": {           \"title\": \"V2 Idx\",           \"default\": 0,           \"minimum\": 0,           \"maximum\": 4294967295,           \"type\": \"integer\"         },         \"params\": {           \"title\": \"Params\",           \"default\": [],           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/Param\"           }         },         \"edge_type\": {           \"title\": \"Edge Type\",           \"default\": 0,           \"minimum\": 0,           \"maximum\": 255,           \"type\": \"integer\"         }       },       \"required\": [         \"v1_idx\",         \"v2_idx\",         \"params\",         \"edge_type\"       ]     },     \"Graph\": {       \"title\": \"Graph\",       \"type\": \"object\",       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"default\": \"\",           \"type\": \"string\"         },         \"vertices\": {           \"title\": \"Vertices\",           \"default\": [],           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/GraphNode\"           }         },         \"edges\": {           \"title\": \"Edges\",           \"default\": [],           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/GraphEdge\"           }         },         \"params\": {           \"title\": \"Params\",           \"default\": [],           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/Param\"           }         }       },       \"required\": [         \"name\",         \"vertices\",         \"edges\",         \"params\"       ]     },     \"Level\": {       \"title\": \"Level\",       \"type\": \"object\",       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"default\": \"\",           \"type\": \"string\"         },         \"elevation\": {           \"title\": \"Elevation\",           \"default\": 0,           \"type\": \"number\"         },         \"images\": {           \"title\": \"Images\",           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/AffineImage\"           }         },         \"places\": {           \"title\": \"Places\",           \"default\": [],           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/Place\"           }         },         \"doors\": {           \"title\": \"Doors\",           \"default\": [],           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/Door\"           }         },         \"nav_graphs\": {           \"title\": \"Nav Graphs\",           \"default\": [],           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/Graph\"           }         },         \"wall_graph\": {           \"title\": \"Wall Graph\",           \"default\": {             \"name\": \"\",             \"vertices\": [],             \"edges\": [],             \"params\": []           },           \"allOf\": [             {               \"$ref\": \"#/definitions/Graph\"             }           ]         }       },       \"required\": [         \"name\",         \"elevation\",         \"images\",         \"places\",         \"doors\",         \"nav_graphs\",         \"wall_graph\"       ]     },     \"Lift\": {       \"title\": \"Lift\",       \"type\": \"object\",       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"default\": \"\",           \"type\": \"string\"         },         \"levels\": {           \"title\": \"Levels\",           \"default\": [],           \"type\": \"array\",           \"items\": {             \"type\": \"string\"           }         },         \"doors\": {           \"title\": \"Doors\",           \"default\": [],           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/Door\"           }         },         \"wall_graph\": {           \"title\": \"Wall Graph\",           \"default\": {             \"name\": \"\",             \"vertices\": [],             \"edges\": [],             \"params\": []           },           \"allOf\": [             {               \"$ref\": \"#/definitions/Graph\"             }           ]         },         \"ref_x\": {           \"title\": \"Ref X\",           \"default\": 0,           \"type\": \"number\"         },         \"ref_y\": {           \"title\": \"Ref Y\",           \"default\": 0,           \"type\": \"number\"         },         \"ref_yaw\": {           \"title\": \"Ref Yaw\",           \"default\": 0,           \"type\": \"number\"         },         \"width\": {           \"title\": \"Width\",           \"default\": 0,           \"type\": \"number\"         },         \"depth\": {           \"title\": \"Depth\",           \"default\": 0,           \"type\": \"number\"         }       },       \"required\": [         \"name\",         \"levels\",         \"doors\",         \"wall_graph\",         \"ref_x\",         \"ref_y\",         \"ref_yaw\",         \"width\",         \"depth\"       ]     }   } } ```   ### /doors/{door_name}/state   ``` {   \"title\": \"DoorState\",   \"type\": \"object\",   \"properties\": {     \"door_time\": {       \"title\": \"Door Time\",       \"default\": {         \"sec\": 0,         \"nanosec\": 0       },       \"allOf\": [         {           \"$ref\": \"#/definitions/Time\"         }       ]     },     \"door_name\": {       \"title\": \"Door Name\",       \"default\": \"\",       \"type\": \"string\"     },     \"current_mode\": {       \"title\": \"Current Mode\",       \"default\": {         \"value\": 0       },       \"allOf\": [         {           \"$ref\": \"#/definitions/DoorMode\"         }       ]     }   },   \"required\": [     \"door_time\",     \"door_name\",     \"current_mode\"   ],   \"definitions\": {     \"Time\": {       \"title\": \"Time\",       \"type\": \"object\",       \"properties\": {         \"sec\": {           \"title\": \"Sec\",           \"default\": 0,           \"minimum\": -2147483648,           \"maximum\": 2147483647,           \"type\": \"integer\"         },         \"nanosec\": {           \"title\": \"Nanosec\",           \"default\": 0,           \"minimum\": 0,           \"maximum\": 4294967295,           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ]     },     \"DoorMode\": {       \"title\": \"DoorMode\",       \"type\": \"object\",       \"properties\": {         \"value\": {           \"title\": \"Value\",           \"default\": 0,           \"minimum\": 0,           \"maximum\": 4294967295,           \"type\": \"integer\"         }       },       \"required\": [         \"value\"       ]     }   } } ```   ### /doors/{door_name}/health   ``` {   \"title\": \"DoorHealth\",   \"type\": \"object\",   \"properties\": {     \"health_status\": {       \"title\": \"Health Status\",       \"maxLength\": 255,       \"nullable\": true,       \"type\": \"string\"     },     \"health_message\": {       \"title\": \"Health Message\",       \"nullable\": true,       \"type\": \"string\"     },     \"id_\": {       \"title\": \"Id \",       \"maxLength\": 255,       \"type\": \"string\"     }   },   \"required\": [     \"health_status\",     \"id_\"   ],   \"additionalProperties\": false } ```   ### /lifts/{lift_name}/state   ``` {   \"title\": \"LiftState\",   \"type\": \"object\",   \"properties\": {     \"lift_time\": {       \"title\": \"Lift Time\",       \"default\": {         \"sec\": 0,         \"nanosec\": 0       },       \"allOf\": [         {           \"$ref\": \"#/definitions/Time\"         }       ]     },     \"lift_name\": {       \"title\": \"Lift Name\",       \"default\": \"\",       \"type\": \"string\"     },     \"available_floors\": {       \"title\": \"Available Floors\",       \"default\": [],       \"type\": \"array\",       \"items\": {         \"type\": \"string\"       }     },     \"current_floor\": {       \"title\": \"Current Floor\",       \"default\": \"\",       \"type\": \"string\"     },     \"destination_floor\": {       \"title\": \"Destination Floor\",       \"default\": \"\",       \"type\": \"string\"     },     \"door_state\": {       \"title\": \"Door State\",       \"default\": 0,       \"minimum\": 0,       \"maximum\": 255,       \"type\": \"integer\"     },     \"motion_state\": {       \"title\": \"Motion State\",       \"default\": 0,       \"minimum\": 0,       \"maximum\": 255,       \"type\": \"integer\"     },     \"available_modes\": {       \"title\": \"Available Modes\",       \"type\": \"array\",       \"items\": {         \"type\": \"integer\"       }     },     \"current_mode\": {       \"title\": \"Current Mode\",       \"default\": 0,       \"minimum\": 0,       \"maximum\": 255,       \"type\": \"integer\"     },     \"session_id\": {       \"title\": \"Session Id\",       \"default\": \"\",       \"type\": \"string\"     }   },   \"required\": [     \"lift_time\",     \"lift_name\",     \"available_floors\",     \"current_floor\",     \"destination_floor\",     \"door_state\",     \"motion_state\",     \"available_modes\",     \"current_mode\",     \"session_id\"   ],   \"definitions\": {     \"Time\": {       \"title\": \"Time\",       \"type\": \"object\",       \"properties\": {         \"sec\": {           \"title\": \"Sec\",           \"default\": 0,           \"minimum\": -2147483648,           \"maximum\": 2147483647,           \"type\": \"integer\"         },         \"nanosec\": {           \"title\": \"Nanosec\",           \"default\": 0,           \"minimum\": 0,           \"maximum\": 4294967295,           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ]     }   } } ```   ### /lifts/{lift_name}/health   ``` {   \"title\": \"LiftHealth\",   \"type\": \"object\",   \"properties\": {     \"health_status\": {       \"title\": \"Health Status\",       \"maxLength\": 255,       \"nullable\": true,       \"type\": \"string\"     },     \"health_message\": {       \"title\": \"Health Message\",       \"nullable\": true,       \"type\": \"string\"     },     \"id_\": {       \"title\": \"Id \",       \"maxLength\": 255,       \"type\": \"string\"     }   },   \"required\": [     \"health_status\",     \"id_\"   ],   \"additionalProperties\": false } ```   ### /tasks/{task_id}/state   ``` {   \"title\": \"TaskState\",   \"type\": \"object\",   \"properties\": {     \"booking\": {       \"$ref\": \"#/definitions/Booking\"     },     \"category\": {       \"$ref\": \"#/definitions/Category\"     },     \"detail\": {       \"$ref\": \"#/definitions/Detail\"     },     \"unix_millis_start_time\": {       \"title\": \"Unix Millis Start Time\",       \"type\": \"integer\"     },     \"unix_millis_finish_time\": {       \"title\": \"Unix Millis Finish Time\",       \"type\": \"integer\"     },     \"original_estimate_millis\": {       \"$ref\": \"#/definitions/EstimateMillis\"     },     \"estimate_millis\": {       \"$ref\": \"#/definitions/EstimateMillis\"     },     \"assigned_to\": {       \"title\": \"Assigned To\",       \"description\": \"Which agent (robot) is the task assigned to\",       \"allOf\": [         {           \"$ref\": \"#/definitions/AssignedTo\"         }       ]     },     \"status\": {       \"$ref\": \"#/definitions/Status\"     },     \"dispatch\": {       \"$ref\": \"#/definitions/Dispatch\"     },     \"phases\": {       \"title\": \"Phases\",       \"description\": \"A dictionary of the states of the phases of the task. The keys (property names) are phase IDs, which are integers.\",       \"type\": \"object\",       \"additionalProperties\": {         \"$ref\": \"#/definitions/Phase\"       }     },     \"completed\": {       \"title\": \"Completed\",       \"description\": \"An array of the IDs of completed phases of this task\",       \"type\": \"array\",       \"items\": {         \"$ref\": \"#/definitions/Id\"       }     },     \"active\": {       \"title\": \"Active\",       \"description\": \"The ID of the active phase for this task\",       \"allOf\": [         {           \"$ref\": \"#/definitions/Id\"         }       ]     },     \"pending\": {       \"title\": \"Pending\",       \"description\": \"An array of the pending phases of this task\",       \"type\": \"array\",       \"items\": {         \"$ref\": \"#/definitions/Id\"       }     },     \"interruptions\": {       \"title\": \"Interruptions\",       \"description\": \"A dictionary of interruptions that have been applied to this task. The keys (property names) are the unique token of the interruption request.\",       \"type\": \"object\",       \"additionalProperties\": {         \"$ref\": \"#/definitions/Interruption\"       }     },     \"cancellation\": {       \"title\": \"Cancellation\",       \"description\": \"If the task was cancelled, this will describe information about the request.\",       \"allOf\": [         {           \"$ref\": \"#/definitions/Cancellation\"         }       ]     },     \"killed\": {       \"title\": \"Killed\",       \"description\": \"If the task was killed, this will describe information about the request.\",       \"allOf\": [         {           \"$ref\": \"#/definitions/Killed\"         }       ]     }   },   \"required\": [     \"booking\"   ],   \"definitions\": {     \"Booking\": {       \"title\": \"Booking\",       \"type\": \"object\",       \"properties\": {         \"id\": {           \"title\": \"Id\",           \"description\": \"The unique identifier for this task\",           \"type\": \"string\"         },         \"unix_millis_earliest_start_time\": {           \"title\": \"Unix Millis Earliest Start Time\",           \"type\": \"integer\"         },         \"unix_millis_request_time\": {           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"priority\": {           \"title\": \"Priority\",           \"description\": \"Priority information about this task\",           \"anyOf\": [             {               \"type\": \"object\"             },             {               \"type\": \"string\"             }           ]         },         \"labels\": {           \"title\": \"Labels\",           \"description\": \"Information about how and why this task was booked\",           \"type\": \"array\",           \"items\": {             \"type\": \"string\"           }         },         \"requester\": {           \"title\": \"Requester\",           \"description\": \"(Optional) An identifier for the entity that requested this task\",           \"type\": \"string\"         }       },       \"required\": [         \"id\"       ]     },     \"Category\": {       \"title\": \"Category\",       \"description\": \"The category of this task or phase\",       \"type\": \"string\"     },     \"Detail\": {       \"title\": \"Detail\",       \"description\": \"Detailed information about a task, phase, or event\",       \"anyOf\": [         {           \"type\": \"object\"         },         {           \"type\": \"array\",           \"items\": {}         },         {           \"type\": \"string\"         }       ]     },     \"EstimateMillis\": {       \"title\": \"EstimateMillis\",       \"description\": \"An estimate, in milliseconds, of how long the subject will take to complete\",       \"minimum\": 0,       \"type\": \"integer\"     },     \"AssignedTo\": {       \"title\": \"AssignedTo\",       \"type\": \"object\",       \"properties\": {         \"group\": {           \"title\": \"Group\",           \"type\": \"string\"         },         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         }       },       \"required\": [         \"group\",         \"name\"       ]     },     \"Status\": {       \"title\": \"Status\",       \"description\": \"An enumeration.\",       \"enum\": [         \"uninitialized\",         \"blocked\",         \"error\",         \"failed\",         \"queued\",         \"standby\",         \"underway\",         \"delayed\",         \"skipped\",         \"canceled\",         \"killed\",         \"completed\"       ]     },     \"Status1\": {       \"title\": \"Status1\",       \"description\": \"An enumeration.\",       \"enum\": [         \"queued\",         \"selected\",         \"dispatched\",         \"failed_to_assign\",         \"canceled_in_flight\"       ]     },     \"Assignment\": {       \"title\": \"Assignment\",       \"type\": \"object\",       \"properties\": {         \"fleet_name\": {           \"title\": \"Fleet Name\",           \"type\": \"string\"         },         \"expected_robot_name\": {           \"title\": \"Expected Robot Name\",           \"type\": \"string\"         }       }     },     \"Error\": {       \"title\": \"Error\",       \"type\": \"object\",       \"properties\": {         \"code\": {           \"title\": \"Code\",           \"description\": \"A standard code for the kind of error that has occurred\",           \"minimum\": 0,           \"type\": \"integer\"         },         \"category\": {           \"title\": \"Category\",           \"description\": \"The category of the error\",           \"type\": \"string\"         },         \"detail\": {           \"title\": \"Detail\",           \"description\": \"Details about the error\",           \"type\": \"string\"         }       }     },     \"Dispatch\": {       \"title\": \"Dispatch\",       \"type\": \"object\",       \"properties\": {         \"status\": {           \"$ref\": \"#/definitions/Status1\"         },         \"assignment\": {           \"$ref\": \"#/definitions/Assignment\"         },         \"errors\": {           \"title\": \"Errors\",           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/Error\"           }         }       },       \"required\": [         \"status\"       ]     },     \"Id\": {       \"title\": \"Id\",       \"minimum\": 0,       \"type\": \"integer\"     },     \"EventState\": {       \"title\": \"EventState\",       \"type\": \"object\",       \"properties\": {         \"id\": {           \"$ref\": \"#/definitions/Id\"         },         \"status\": {           \"$ref\": \"#/definitions/Status\"         },         \"name\": {           \"title\": \"Name\",           \"description\": \"The brief name of the event\",           \"type\": \"string\"         },         \"detail\": {           \"title\": \"Detail\",           \"description\": \"Detailed information about the event\",           \"allOf\": [             {               \"$ref\": \"#/definitions/Detail\"             }           ]         },         \"deps\": {           \"title\": \"Deps\",           \"description\": \"This event may depend on other events. This array contains the IDs of those other event dependencies.\",           \"type\": \"array\",           \"items\": {             \"type\": \"integer\",             \"minimum\": 0           }         }       },       \"required\": [         \"id\"       ]     },     \"Undo\": {       \"title\": \"Undo\",       \"type\": \"object\",       \"properties\": {         \"unix_millis_request_time\": {           \"title\": \"Unix Millis Request Time\",           \"description\": \"The time that the undo skip request arrived\",           \"type\": \"integer\"         },         \"labels\": {           \"title\": \"Labels\",           \"description\": \"Labels to describe the undo skip request\",           \"type\": \"array\",           \"items\": {             \"type\": \"string\"           }         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ]     },     \"SkipPhaseRequest\": {       \"title\": \"SkipPhaseRequest\",       \"type\": \"object\",       \"properties\": {         \"unix_millis_request_time\": {           \"title\": \"Unix Millis Request Time\",           \"description\": \"The time that the skip request arrived\",           \"type\": \"integer\"         },         \"labels\": {           \"title\": \"Labels\",           \"description\": \"Labels to describe the purpose of the skip request\",           \"type\": \"array\",           \"items\": {             \"type\": \"string\"           }         },         \"undo\": {           \"title\": \"Undo\",           \"description\": \"Information about an undo skip request that applied to this request\",           \"allOf\": [             {               \"$ref\": \"#/definitions/Undo\"             }           ]         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ]     },     \"Phase\": {       \"title\": \"Phase\",       \"type\": \"object\",       \"properties\": {         \"id\": {           \"$ref\": \"#/definitions/Id\"         },         \"category\": {           \"$ref\": \"#/definitions/Category\"         },         \"detail\": {           \"$ref\": \"#/definitions/Detail\"         },         \"unix_millis_start_time\": {           \"title\": \"Unix Millis Start Time\",           \"type\": \"integer\"         },         \"unix_millis_finish_time\": {           \"title\": \"Unix Millis Finish Time\",           \"type\": \"integer\"         },         \"original_estimate_millis\": {           \"$ref\": \"#/definitions/EstimateMillis\"         },         \"estimate_millis\": {           \"$ref\": \"#/definitions/EstimateMillis\"         },         \"final_event_id\": {           \"$ref\": \"#/definitions/Id\"         },         \"events\": {           \"title\": \"Events\",           \"description\": \"A dictionary of events for this phase. The keys (property names) are the event IDs, which are integers.\",           \"type\": \"object\",           \"additionalProperties\": {             \"$ref\": \"#/definitions/EventState\"           }         },         \"skip_requests\": {           \"title\": \"Skip Requests\",           \"description\": \"Information about any skip requests that have been received\",           \"type\": \"object\",           \"additionalProperties\": {             \"$ref\": \"#/definitions/SkipPhaseRequest\"           }         }       },       \"required\": [         \"id\"       ]     },     \"ResumedBy\": {       \"title\": \"ResumedBy\",       \"type\": \"object\",       \"properties\": {         \"unix_millis_request_time\": {           \"title\": \"Unix Millis Request Time\",           \"description\": \"The time that the resume request arrived\",           \"type\": \"integer\"         },         \"labels\": {           \"title\": \"Labels\",           \"description\": \"Labels to describe the resume request\",           \"type\": \"array\",           \"items\": {             \"type\": \"string\"           }         }       },       \"required\": [         \"labels\"       ]     },     \"Interruption\": {       \"title\": \"Interruption\",       \"type\": \"object\",       \"properties\": {         \"unix_millis_request_time\": {           \"title\": \"Unix Millis Request Time\",           \"description\": \"The time that the interruption request arrived\",           \"type\": \"integer\"         },         \"labels\": {           \"title\": \"Labels\",           \"description\": \"Labels to describe the purpose of the interruption\",           \"type\": \"array\",           \"items\": {             \"type\": \"string\"           }         },         \"resumed_by\": {           \"title\": \"Resumed By\",           \"description\": \"Information about the resume request that ended this interruption. This field will be missing if the interruption is still active.\",           \"allOf\": [             {               \"$ref\": \"#/definitions/ResumedBy\"             }           ]         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ]     },     \"Cancellation\": {       \"title\": \"Cancellation\",       \"type\": \"object\",       \"properties\": {         \"unix_millis_request_time\": {           \"title\": \"Unix Millis Request Time\",           \"description\": \"The time that the cancellation request arrived\",           \"type\": \"integer\"         },         \"labels\": {           \"title\": \"Labels\",           \"description\": \"Labels to describe the cancel request\",           \"type\": \"array\",           \"items\": {             \"type\": \"string\"           }         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ]     },     \"Killed\": {       \"title\": \"Killed\",       \"type\": \"object\",       \"properties\": {         \"unix_millis_request_time\": {           \"title\": \"Unix Millis Request Time\",           \"description\": \"The time that the cancellation request arrived\",           \"type\": \"integer\"         },         \"labels\": {           \"title\": \"Labels\",           \"description\": \"Labels to describe the kill request\",           \"type\": \"array\",           \"items\": {             \"type\": \"string\"           }         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ]     }   } } ```   ### /tasks/{task_id}/log   ``` {   \"title\": \"TaskEventLog\",   \"type\": \"object\",   \"properties\": {     \"task_id\": {       \"title\": \"Task Id\",       \"type\": \"string\"     },     \"log\": {       \"title\": \"Log\",       \"description\": \"Log entries related to the overall task\",       \"type\": \"array\",       \"items\": {         \"$ref\": \"#/definitions/LogEntry\"       }     },     \"phases\": {       \"title\": \"Phases\",       \"description\": \"A dictionary whose keys (property names) are the indices of a phase\",       \"type\": \"object\",       \"additionalProperties\": {         \"$ref\": \"#/definitions/Phases\"       }     }   },   \"required\": [     \"task_id\"   ],   \"additionalProperties\": false,   \"definitions\": {     \"Tier\": {       \"title\": \"Tier\",       \"description\": \"An enumeration.\",       \"enum\": [         \"uninitialized\",         \"info\",         \"warning\",         \"error\"       ]     },     \"LogEntry\": {       \"title\": \"LogEntry\",       \"type\": \"object\",       \"properties\": {         \"seq\": {           \"title\": \"Seq\",           \"description\": \"Sequence number for this entry. Each entry has a unique sequence number which monotonically increase, until integer overflow causes a wrap around.\",           \"exclusiveMaximum\": 4294967296,           \"minimum\": 0,           \"type\": \"integer\"         },         \"tier\": {           \"description\": \"The importance level of the log entry\",           \"allOf\": [             {               \"$ref\": \"#/definitions/Tier\"             }           ]         },         \"unix_millis_time\": {           \"title\": \"Unix Millis Time\",           \"type\": \"integer\"         },         \"text\": {           \"title\": \"Text\",           \"description\": \"The text of the log entry\",           \"type\": \"string\"         }       },       \"required\": [         \"seq\",         \"tier\",         \"unix_millis_time\",         \"text\"       ]     },     \"Phases\": {       \"title\": \"Phases\",       \"type\": \"object\",       \"properties\": {         \"log\": {           \"title\": \"Log\",           \"description\": \"Log entries related to the overall phase\",           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/LogEntry\"           }         },         \"events\": {           \"title\": \"Events\",           \"description\": \"A dictionary whose keys (property names) are the indices of an event in the phase\",           \"type\": \"object\",           \"additionalProperties\": {             \"type\": \"array\",             \"items\": {               \"$ref\": \"#/definitions/LogEntry\"             }           }         }       },       \"additionalProperties\": false     }   } } ```   ### /dispensers/{guid}/state   ``` {   \"title\": \"DispenserState\",   \"type\": \"object\",   \"properties\": {     \"time\": {       \"title\": \"Time\",       \"default\": {         \"sec\": 0,         \"nanosec\": 0       },       \"allOf\": [         {           \"$ref\": \"#/definitions/Time\"         }       ]     },     \"guid\": {       \"title\": \"Guid\",       \"default\": \"\",       \"type\": \"string\"     },     \"mode\": {       \"title\": \"Mode\",       \"default\": 0,       \"minimum\": -2147483648,       \"maximum\": 2147483647,       \"type\": \"integer\"     },     \"request_guid_queue\": {       \"title\": \"Request Guid Queue\",       \"default\": [],       \"type\": \"array\",       \"items\": {         \"type\": \"string\"       }     },     \"seconds_remaining\": {       \"title\": \"Seconds Remaining\",       \"default\": 0,       \"type\": \"number\"     }   },   \"required\": [     \"time\",     \"guid\",     \"mode\",     \"request_guid_queue\",     \"seconds_remaining\"   ],   \"definitions\": {     \"Time\": {       \"title\": \"Time\",       \"type\": \"object\",       \"properties\": {         \"sec\": {           \"title\": \"Sec\",           \"default\": 0,           \"minimum\": -2147483648,           \"maximum\": 2147483647,           \"type\": \"integer\"         },         \"nanosec\": {           \"title\": \"Nanosec\",           \"default\": 0,           \"minimum\": 0,           \"maximum\": 4294967295,           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ]     }   } } ```   ### /dispensers/{guid}/health   ``` {   \"title\": \"DispenserHealth\",   \"type\": \"object\",   \"properties\": {     \"health_status\": {       \"title\": \"Health Status\",       \"maxLength\": 255,       \"nullable\": true,       \"type\": \"string\"     },     \"health_message\": {       \"title\": \"Health Message\",       \"nullable\": true,       \"type\": \"string\"     },     \"id_\": {       \"title\": \"Id \",       \"maxLength\": 255,       \"type\": \"string\"     }   },   \"required\": [     \"health_status\",     \"id_\"   ],   \"additionalProperties\": false } ```   ### /ingestors/{guid}/state   ``` {   \"title\": \"IngestorState\",   \"type\": \"object\",   \"properties\": {     \"time\": {       \"title\": \"Time\",       \"default\": {         \"sec\": 0,         \"nanosec\": 0       },       \"allOf\": [         {           \"$ref\": \"#/definitions/Time\"         }       ]     },     \"guid\": {       \"title\": \"Guid\",       \"default\": \"\",       \"type\": \"string\"     },     \"mode\": {       \"title\": \"Mode\",       \"default\": 0,       \"minimum\": -2147483648,       \"maximum\": 2147483647,       \"type\": \"integer\"     },     \"request_guid_queue\": {       \"title\": \"Request Guid Queue\",       \"default\": [],       \"type\": \"array\",       \"items\": {         \"type\": \"string\"       }     },     \"seconds_remaining\": {       \"title\": \"Seconds Remaining\",       \"default\": 0,       \"type\": \"number\"     }   },   \"required\": [     \"time\",     \"guid\",     \"mode\",     \"request_guid_queue\",     \"seconds_remaining\"   ],   \"definitions\": {     \"Time\": {       \"title\": \"Time\",       \"type\": \"object\",       \"properties\": {         \"sec\": {           \"title\": \"Sec\",           \"default\": 0,           \"minimum\": -2147483648,           \"maximum\": 2147483647,           \"type\": \"integer\"         },         \"nanosec\": {           \"title\": \"Nanosec\",           \"default\": 0,           \"minimum\": 0,           \"maximum\": 4294967295,           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ]     }   } } ```   ### /ingestors/{guid}/health   ``` {   \"title\": \"IngestorHealth\",   \"type\": \"object\",   \"properties\": {     \"health_status\": {       \"title\": \"Health Status\",       \"maxLength\": 255,       \"nullable\": true,       \"type\": \"string\"     },     \"health_message\": {       \"title\": \"Health Message\",       \"nullable\": true,       \"type\": \"string\"     },     \"id_\": {       \"title\": \"Id \",       \"maxLength\": 255,       \"type\": \"string\"     }   },   \"required\": [     \"health_status\",     \"id_\"   ],   \"additionalProperties\": false } ```   ### /fleets/{name}/state   ``` {   \"title\": \"FleetState\",   \"type\": \"object\",   \"properties\": {     \"name\": {       \"title\": \"Name\",       \"type\": \"string\"     },     \"robots\": {       \"title\": \"Robots\",       \"description\": \"A dictionary of the states of the robots that belong to this fleet\",       \"type\": \"object\",       \"additionalProperties\": {         \"$ref\": \"#/definitions/RobotState\"       }     }   },   \"definitions\": {     \"Status2\": {       \"title\": \"Status2\",       \"description\": \"An enumeration.\",       \"enum\": [         \"uninitialized\",         \"offline\",         \"shutdown\",         \"idle\",         \"charging\",         \"working\",         \"error\"       ]     },     \"Location2D\": {       \"title\": \"Location2D\",       \"type\": \"object\",       \"properties\": {         \"map\": {           \"title\": \"Map\",           \"type\": \"string\"         },         \"x\": {           \"title\": \"X\",           \"type\": \"number\"         },         \"y\": {           \"title\": \"Y\",           \"type\": \"number\"         },         \"yaw\": {           \"title\": \"Yaw\",           \"type\": \"number\"         }       },       \"required\": [         \"map\",         \"x\",         \"y\",         \"yaw\"       ]     },     \"Issue\": {       \"title\": \"Issue\",       \"type\": \"object\",       \"properties\": {         \"category\": {           \"title\": \"Category\",           \"description\": \"Category of the robot\'s issue\",           \"type\": \"string\"         },         \"detail\": {           \"title\": \"Detail\",           \"description\": \"Detailed information about the issue\",           \"anyOf\": [             {               \"type\": \"object\"             },             {               \"type\": \"array\",               \"items\": {}             },             {               \"type\": \"string\"             }           ]         }       }     },     \"RobotState\": {       \"title\": \"RobotState\",       \"type\": \"object\",       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"status\": {           \"description\": \"A simple token representing the status of the robot\",           \"allOf\": [             {               \"$ref\": \"#/definitions/Status2\"             }           ]         },         \"task_id\": {           \"title\": \"Task Id\",           \"description\": \"The ID of the task this robot is currently working on. Empty string if the robot is not working on a task.\",           \"type\": \"string\"         },         \"unix_millis_time\": {           \"title\": \"Unix Millis Time\",           \"type\": \"integer\"         },         \"location\": {           \"$ref\": \"#/definitions/Location2D\"         },         \"battery\": {           \"title\": \"Battery\",           \"description\": \"State of charge of the battery. Values range from 0.0 (depleted) to 1.0 (fully charged)\",           \"minimum\": 0.0,           \"maximum\": 1.0,           \"type\": \"number\"         },         \"issues\": {           \"title\": \"Issues\",           \"description\": \"A list of issues with the robot that operators need to address\",           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/Issue\"           }         }       }     }   } } ```   ### /fleets/{name}/log   ``` {   \"title\": \"FleetState\",   \"type\": \"object\",   \"properties\": {     \"name\": {       \"title\": \"Name\",       \"type\": \"string\"     },     \"log\": {       \"title\": \"Log\",       \"description\": \"Log for the overall fleet\",       \"type\": \"array\",       \"items\": {         \"$ref\": \"#/definitions/LogEntry\"       }     },     \"robots\": {       \"title\": \"Robots\",       \"description\": \"Dictionary of logs for the individual robots. The keys (property names) are the robot names.\",       \"type\": \"object\",       \"additionalProperties\": {         \"type\": \"array\",         \"items\": {           \"$ref\": \"#/definitions/LogEntry\"         }       }     }   },   \"definitions\": {     \"Tier\": {       \"title\": \"Tier\",       \"description\": \"An enumeration.\",       \"enum\": [         \"uninitialized\",         \"info\",         \"warning\",         \"error\"       ]     },     \"LogEntry\": {       \"title\": \"LogEntry\",       \"type\": \"object\",       \"properties\": {         \"seq\": {           \"title\": \"Seq\",           \"description\": \"Sequence number for this entry. Each entry has a unique sequence number which monotonically increase, until integer overflow causes a wrap around.\",           \"exclusiveMaximum\": 4294967296,           \"minimum\": 0,           \"type\": \"integer\"         },         \"tier\": {           \"description\": \"The importance level of the log entry\",           \"allOf\": [             {               \"$ref\": \"#/definitions/Tier\"             }           ]         },         \"unix_millis_time\": {           \"title\": \"Unix Millis Time\",           \"type\": \"integer\"         },         \"text\": {           \"title\": \"Text\",           \"description\": \"The text of the log entry\",           \"type\": \"string\"         }       },       \"required\": [         \"seq\",         \"tier\",         \"unix_millis_time\",         \"text\"       ]     }   } } ```
     * @summary Socket.io endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lambdaSocketIoGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/socket.io`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration);
  return {
    /**
     * Get the effective permissions of the current user
     * @summary Get Effective Permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEffectivePermissionsPermissionsGet(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Permission>>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getEffectivePermissionsPermissionsGet(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get the current rmf time in unix milliseconds
     * @summary Get Time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTimeTimeGet(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTimeTimeGet(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get the currently logged in user
     * @summary Get User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserUserGet(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserUserGet(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *  # NOTE: This endpoint is here for documentation purposes only, this is _not_ a REST endpoint.  ## About This exposes a minimal pubsub system built on top of socket.io. It works similar to a normal socket.io endpoint, except that are 2 special rooms which control subscriptions.  ## Rooms ### subscribe Clients must send a message to this room to start receiving messages on other rooms. The message must be of the form:  ``` {     \"room\": \"<room_name>\" } ```  ### unsubscribe Clients can send a message to this room to stop receiving messages on other rooms. The message must be of the form:  ``` {     \"room\": \"<room_name>\" } ```              ### /alerts   ``` {   \"title\": \"Alert\",   \"description\": \"General alert that can be triggered by events.\",   \"type\": \"object\",   \"properties\": {     \"id\": {       \"title\": \"Id\",       \"maxLength\": 255,       \"type\": \"string\"     },     \"original_id\": {       \"title\": \"Original Id\",       \"maxLength\": 255,       \"type\": \"string\"     },     \"category\": {       \"title\": \"Category\",       \"description\": \"Default: default<br/>Task: task<br/>Fleet: fleet<br/>Robot: robot\",       \"maxLength\": 7,       \"type\": \"string\"     },     \"unix_millis_created_time\": {       \"title\": \"Unix Millis Created Time\",       \"minimum\": -9223372036854775808,       \"maximum\": 9223372036854775807,       \"type\": \"integer\"     },     \"acknowledged_by\": {       \"title\": \"Acknowledged By\",       \"maxLength\": 255,       \"nullable\": true,       \"type\": \"string\"     },     \"unix_millis_acknowledged_time\": {       \"title\": \"Unix Millis Acknowledged Time\",       \"minimum\": -9223372036854775808,       \"maximum\": 9223372036854775807,       \"nullable\": true,       \"type\": \"integer\"     }   },   \"required\": [     \"id\",     \"original_id\",     \"category\",     \"unix_millis_created_time\"   ],   \"additionalProperties\": false } ```   ### /beacons   ``` {   \"title\": \"BeaconState\",   \"type\": \"object\",   \"properties\": {     \"id\": {       \"title\": \"Id\",       \"maxLength\": 255,       \"type\": \"string\"     },     \"online\": {       \"title\": \"Online\",       \"type\": \"boolean\"     },     \"category\": {       \"title\": \"Category\",       \"maxLength\": 255,       \"nullable\": true,       \"type\": \"string\"     },     \"activated\": {       \"title\": \"Activated\",       \"type\": \"boolean\"     },     \"level\": {       \"title\": \"Level\",       \"maxLength\": 255,       \"nullable\": true,       \"type\": \"string\"     }   },   \"required\": [     \"id\",     \"online\",     \"activated\"   ],   \"additionalProperties\": false } ```   ### /building_map   ``` {   \"title\": \"BuildingMap\",   \"type\": \"object\",   \"properties\": {     \"name\": {       \"title\": \"Name\",       \"default\": \"\",       \"type\": \"string\"     },     \"levels\": {       \"title\": \"Levels\",       \"type\": \"array\",       \"items\": {         \"$ref\": \"#/definitions/Level\"       }     },     \"lifts\": {       \"title\": \"Lifts\",       \"default\": [],       \"type\": \"array\",       \"items\": {         \"$ref\": \"#/definitions/Lift\"       }     }   },   \"required\": [     \"name\",     \"levels\",     \"lifts\"   ],   \"definitions\": {     \"AffineImage\": {       \"title\": \"AffineImage\",       \"type\": \"object\",       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"default\": \"\",           \"type\": \"string\"         },         \"x_offset\": {           \"title\": \"X Offset\",           \"default\": 0,           \"type\": \"number\"         },         \"y_offset\": {           \"title\": \"Y Offset\",           \"default\": 0,           \"type\": \"number\"         },         \"yaw\": {           \"title\": \"Yaw\",           \"default\": 0,           \"type\": \"number\"         },         \"scale\": {           \"title\": \"Scale\",           \"default\": 0,           \"type\": \"number\"         },         \"encoding\": {           \"title\": \"Encoding\",           \"default\": \"\",           \"type\": \"string\"         },         \"data\": {           \"title\": \"Data\",           \"type\": \"string\"         }       },       \"required\": [         \"name\",         \"x_offset\",         \"y_offset\",         \"yaw\",         \"scale\",         \"encoding\",         \"data\"       ]     },     \"Place\": {       \"title\": \"Place\",       \"type\": \"object\",       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"default\": \"\",           \"type\": \"string\"         },         \"x\": {           \"title\": \"X\",           \"default\": 0,           \"type\": \"number\"         },         \"y\": {           \"title\": \"Y\",           \"default\": 0,           \"type\": \"number\"         },         \"yaw\": {           \"title\": \"Yaw\",           \"default\": 0,           \"type\": \"number\"         },         \"position_tolerance\": {           \"title\": \"Position Tolerance\",           \"default\": 0,           \"type\": \"number\"         },         \"yaw_tolerance\": {           \"title\": \"Yaw Tolerance\",           \"default\": 0,           \"type\": \"number\"         }       },       \"required\": [         \"name\",         \"x\",         \"y\",         \"yaw\",         \"position_tolerance\",         \"yaw_tolerance\"       ]     },     \"Door\": {       \"title\": \"Door\",       \"type\": \"object\",       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"default\": \"\",           \"type\": \"string\"         },         \"v1_x\": {           \"title\": \"V1 X\",           \"default\": 0,           \"type\": \"number\"         },         \"v1_y\": {           \"title\": \"V1 Y\",           \"default\": 0,           \"type\": \"number\"         },         \"v2_x\": {           \"title\": \"V2 X\",           \"default\": 0,           \"type\": \"number\"         },         \"v2_y\": {           \"title\": \"V2 Y\",           \"default\": 0,           \"type\": \"number\"         },         \"door_type\": {           \"title\": \"Door Type\",           \"default\": 0,           \"minimum\": 0,           \"maximum\": 255,           \"type\": \"integer\"         },         \"motion_range\": {           \"title\": \"Motion Range\",           \"default\": 0,           \"type\": \"number\"         },         \"motion_direction\": {           \"title\": \"Motion Direction\",           \"default\": 0,           \"minimum\": -2147483648,           \"maximum\": 2147483647,           \"type\": \"integer\"         }       },       \"required\": [         \"name\",         \"v1_x\",         \"v1_y\",         \"v2_x\",         \"v2_y\",         \"door_type\",         \"motion_range\",         \"motion_direction\"       ]     },     \"Param\": {       \"title\": \"Param\",       \"type\": \"object\",       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"default\": \"\",           \"type\": \"string\"         },         \"type\": {           \"title\": \"Type\",           \"default\": 0,           \"minimum\": 0,           \"maximum\": 4294967295,           \"type\": \"integer\"         },         \"value_int\": {           \"title\": \"Value Int\",           \"default\": 0,           \"minimum\": -2147483648,           \"maximum\": 2147483647,           \"type\": \"integer\"         },         \"value_float\": {           \"title\": \"Value Float\",           \"default\": 0,           \"type\": \"number\"         },         \"value_string\": {           \"title\": \"Value String\",           \"default\": \"\",           \"type\": \"string\"         },         \"value_bool\": {           \"title\": \"Value Bool\",           \"default\": false,           \"type\": \"boolean\"         }       },       \"required\": [         \"name\",         \"type\",         \"value_int\",         \"value_float\",         \"value_string\",         \"value_bool\"       ]     },     \"GraphNode\": {       \"title\": \"GraphNode\",       \"type\": \"object\",       \"properties\": {         \"x\": {           \"title\": \"X\",           \"default\": 0,           \"type\": \"number\"         },         \"y\": {           \"title\": \"Y\",           \"default\": 0,           \"type\": \"number\"         },         \"name\": {           \"title\": \"Name\",           \"default\": \"\",           \"type\": \"string\"         },         \"params\": {           \"title\": \"Params\",           \"default\": [],           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/Param\"           }         }       },       \"required\": [         \"x\",         \"y\",         \"name\",         \"params\"       ]     },     \"GraphEdge\": {       \"title\": \"GraphEdge\",       \"type\": \"object\",       \"properties\": {         \"v1_idx\": {           \"title\": \"V1 Idx\",           \"default\": 0,           \"minimum\": 0,           \"maximum\": 4294967295,           \"type\": \"integer\"         },         \"v2_idx\": {           \"title\": \"V2 Idx\",           \"default\": 0,           \"minimum\": 0,           \"maximum\": 4294967295,           \"type\": \"integer\"         },         \"params\": {           \"title\": \"Params\",           \"default\": [],           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/Param\"           }         },         \"edge_type\": {           \"title\": \"Edge Type\",           \"default\": 0,           \"minimum\": 0,           \"maximum\": 255,           \"type\": \"integer\"         }       },       \"required\": [         \"v1_idx\",         \"v2_idx\",         \"params\",         \"edge_type\"       ]     },     \"Graph\": {       \"title\": \"Graph\",       \"type\": \"object\",       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"default\": \"\",           \"type\": \"string\"         },         \"vertices\": {           \"title\": \"Vertices\",           \"default\": [],           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/GraphNode\"           }         },         \"edges\": {           \"title\": \"Edges\",           \"default\": [],           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/GraphEdge\"           }         },         \"params\": {           \"title\": \"Params\",           \"default\": [],           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/Param\"           }         }       },       \"required\": [         \"name\",         \"vertices\",         \"edges\",         \"params\"       ]     },     \"Level\": {       \"title\": \"Level\",       \"type\": \"object\",       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"default\": \"\",           \"type\": \"string\"         },         \"elevation\": {           \"title\": \"Elevation\",           \"default\": 0,           \"type\": \"number\"         },         \"images\": {           \"title\": \"Images\",           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/AffineImage\"           }         },         \"places\": {           \"title\": \"Places\",           \"default\": [],           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/Place\"           }         },         \"doors\": {           \"title\": \"Doors\",           \"default\": [],           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/Door\"           }         },         \"nav_graphs\": {           \"title\": \"Nav Graphs\",           \"default\": [],           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/Graph\"           }         },         \"wall_graph\": {           \"title\": \"Wall Graph\",           \"default\": {             \"name\": \"\",             \"vertices\": [],             \"edges\": [],             \"params\": []           },           \"allOf\": [             {               \"$ref\": \"#/definitions/Graph\"             }           ]         }       },       \"required\": [         \"name\",         \"elevation\",         \"images\",         \"places\",         \"doors\",         \"nav_graphs\",         \"wall_graph\"       ]     },     \"Lift\": {       \"title\": \"Lift\",       \"type\": \"object\",       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"default\": \"\",           \"type\": \"string\"         },         \"levels\": {           \"title\": \"Levels\",           \"default\": [],           \"type\": \"array\",           \"items\": {             \"type\": \"string\"           }         },         \"doors\": {           \"title\": \"Doors\",           \"default\": [],           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/Door\"           }         },         \"wall_graph\": {           \"title\": \"Wall Graph\",           \"default\": {             \"name\": \"\",             \"vertices\": [],             \"edges\": [],             \"params\": []           },           \"allOf\": [             {               \"$ref\": \"#/definitions/Graph\"             }           ]         },         \"ref_x\": {           \"title\": \"Ref X\",           \"default\": 0,           \"type\": \"number\"         },         \"ref_y\": {           \"title\": \"Ref Y\",           \"default\": 0,           \"type\": \"number\"         },         \"ref_yaw\": {           \"title\": \"Ref Yaw\",           \"default\": 0,           \"type\": \"number\"         },         \"width\": {           \"title\": \"Width\",           \"default\": 0,           \"type\": \"number\"         },         \"depth\": {           \"title\": \"Depth\",           \"default\": 0,           \"type\": \"number\"         }       },       \"required\": [         \"name\",         \"levels\",         \"doors\",         \"wall_graph\",         \"ref_x\",         \"ref_y\",         \"ref_yaw\",         \"width\",         \"depth\"       ]     }   } } ```   ### /doors/{door_name}/state   ``` {   \"title\": \"DoorState\",   \"type\": \"object\",   \"properties\": {     \"door_time\": {       \"title\": \"Door Time\",       \"default\": {         \"sec\": 0,         \"nanosec\": 0       },       \"allOf\": [         {           \"$ref\": \"#/definitions/Time\"         }       ]     },     \"door_name\": {       \"title\": \"Door Name\",       \"default\": \"\",       \"type\": \"string\"     },     \"current_mode\": {       \"title\": \"Current Mode\",       \"default\": {         \"value\": 0       },       \"allOf\": [         {           \"$ref\": \"#/definitions/DoorMode\"         }       ]     }   },   \"required\": [     \"door_time\",     \"door_name\",     \"current_mode\"   ],   \"definitions\": {     \"Time\": {       \"title\": \"Time\",       \"type\": \"object\",       \"properties\": {         \"sec\": {           \"title\": \"Sec\",           \"default\": 0,           \"minimum\": -2147483648,           \"maximum\": 2147483647,           \"type\": \"integer\"         },         \"nanosec\": {           \"title\": \"Nanosec\",           \"default\": 0,           \"minimum\": 0,           \"maximum\": 4294967295,           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ]     },     \"DoorMode\": {       \"title\": \"DoorMode\",       \"type\": \"object\",       \"properties\": {         \"value\": {           \"title\": \"Value\",           \"default\": 0,           \"minimum\": 0,           \"maximum\": 4294967295,           \"type\": \"integer\"         }       },       \"required\": [         \"value\"       ]     }   } } ```   ### /doors/{door_name}/health   ``` {   \"title\": \"DoorHealth\",   \"type\": \"object\",   \"properties\": {     \"health_status\": {       \"title\": \"Health Status\",       \"maxLength\": 255,       \"nullable\": true,       \"type\": \"string\"     },     \"health_message\": {       \"title\": \"Health Message\",       \"nullable\": true,       \"type\": \"string\"     },     \"id_\": {       \"title\": \"Id \",       \"maxLength\": 255,       \"type\": \"string\"     }   },   \"required\": [     \"health_status\",     \"id_\"   ],   \"additionalProperties\": false } ```   ### /lifts/{lift_name}/state   ``` {   \"title\": \"LiftState\",   \"type\": \"object\",   \"properties\": {     \"lift_time\": {       \"title\": \"Lift Time\",       \"default\": {         \"sec\": 0,         \"nanosec\": 0       },       \"allOf\": [         {           \"$ref\": \"#/definitions/Time\"         }       ]     },     \"lift_name\": {       \"title\": \"Lift Name\",       \"default\": \"\",       \"type\": \"string\"     },     \"available_floors\": {       \"title\": \"Available Floors\",       \"default\": [],       \"type\": \"array\",       \"items\": {         \"type\": \"string\"       }     },     \"current_floor\": {       \"title\": \"Current Floor\",       \"default\": \"\",       \"type\": \"string\"     },     \"destination_floor\": {       \"title\": \"Destination Floor\",       \"default\": \"\",       \"type\": \"string\"     },     \"door_state\": {       \"title\": \"Door State\",       \"default\": 0,       \"minimum\": 0,       \"maximum\": 255,       \"type\": \"integer\"     },     \"motion_state\": {       \"title\": \"Motion State\",       \"default\": 0,       \"minimum\": 0,       \"maximum\": 255,       \"type\": \"integer\"     },     \"available_modes\": {       \"title\": \"Available Modes\",       \"type\": \"array\",       \"items\": {         \"type\": \"integer\"       }     },     \"current_mode\": {       \"title\": \"Current Mode\",       \"default\": 0,       \"minimum\": 0,       \"maximum\": 255,       \"type\": \"integer\"     },     \"session_id\": {       \"title\": \"Session Id\",       \"default\": \"\",       \"type\": \"string\"     }   },   \"required\": [     \"lift_time\",     \"lift_name\",     \"available_floors\",     \"current_floor\",     \"destination_floor\",     \"door_state\",     \"motion_state\",     \"available_modes\",     \"current_mode\",     \"session_id\"   ],   \"definitions\": {     \"Time\": {       \"title\": \"Time\",       \"type\": \"object\",       \"properties\": {         \"sec\": {           \"title\": \"Sec\",           \"default\": 0,           \"minimum\": -2147483648,           \"maximum\": 2147483647,           \"type\": \"integer\"         },         \"nanosec\": {           \"title\": \"Nanosec\",           \"default\": 0,           \"minimum\": 0,           \"maximum\": 4294967295,           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ]     }   } } ```   ### /lifts/{lift_name}/health   ``` {   \"title\": \"LiftHealth\",   \"type\": \"object\",   \"properties\": {     \"health_status\": {       \"title\": \"Health Status\",       \"maxLength\": 255,       \"nullable\": true,       \"type\": \"string\"     },     \"health_message\": {       \"title\": \"Health Message\",       \"nullable\": true,       \"type\": \"string\"     },     \"id_\": {       \"title\": \"Id \",       \"maxLength\": 255,       \"type\": \"string\"     }   },   \"required\": [     \"health_status\",     \"id_\"   ],   \"additionalProperties\": false } ```   ### /tasks/{task_id}/state   ``` {   \"title\": \"TaskState\",   \"type\": \"object\",   \"properties\": {     \"booking\": {       \"$ref\": \"#/definitions/Booking\"     },     \"category\": {       \"$ref\": \"#/definitions/Category\"     },     \"detail\": {       \"$ref\": \"#/definitions/Detail\"     },     \"unix_millis_start_time\": {       \"title\": \"Unix Millis Start Time\",       \"type\": \"integer\"     },     \"unix_millis_finish_time\": {       \"title\": \"Unix Millis Finish Time\",       \"type\": \"integer\"     },     \"original_estimate_millis\": {       \"$ref\": \"#/definitions/EstimateMillis\"     },     \"estimate_millis\": {       \"$ref\": \"#/definitions/EstimateMillis\"     },     \"assigned_to\": {       \"title\": \"Assigned To\",       \"description\": \"Which agent (robot) is the task assigned to\",       \"allOf\": [         {           \"$ref\": \"#/definitions/AssignedTo\"         }       ]     },     \"status\": {       \"$ref\": \"#/definitions/Status\"     },     \"dispatch\": {       \"$ref\": \"#/definitions/Dispatch\"     },     \"phases\": {       \"title\": \"Phases\",       \"description\": \"A dictionary of the states of the phases of the task. The keys (property names) are phase IDs, which are integers.\",       \"type\": \"object\",       \"additionalProperties\": {         \"$ref\": \"#/definitions/Phase\"       }     },     \"completed\": {       \"title\": \"Completed\",       \"description\": \"An array of the IDs of completed phases of this task\",       \"type\": \"array\",       \"items\": {         \"$ref\": \"#/definitions/Id\"       }     },     \"active\": {       \"title\": \"Active\",       \"description\": \"The ID of the active phase for this task\",       \"allOf\": [         {           \"$ref\": \"#/definitions/Id\"         }       ]     },     \"pending\": {       \"title\": \"Pending\",       \"description\": \"An array of the pending phases of this task\",       \"type\": \"array\",       \"items\": {         \"$ref\": \"#/definitions/Id\"       }     },     \"interruptions\": {       \"title\": \"Interruptions\",       \"description\": \"A dictionary of interruptions that have been applied to this task. The keys (property names) are the unique token of the interruption request.\",       \"type\": \"object\",       \"additionalProperties\": {         \"$ref\": \"#/definitions/Interruption\"       }     },     \"cancellation\": {       \"title\": \"Cancellation\",       \"description\": \"If the task was cancelled, this will describe information about the request.\",       \"allOf\": [         {           \"$ref\": \"#/definitions/Cancellation\"         }       ]     },     \"killed\": {       \"title\": \"Killed\",       \"description\": \"If the task was killed, this will describe information about the request.\",       \"allOf\": [         {           \"$ref\": \"#/definitions/Killed\"         }       ]     }   },   \"required\": [     \"booking\"   ],   \"definitions\": {     \"Booking\": {       \"title\": \"Booking\",       \"type\": \"object\",       \"properties\": {         \"id\": {           \"title\": \"Id\",           \"description\": \"The unique identifier for this task\",           \"type\": \"string\"         },         \"unix_millis_earliest_start_time\": {           \"title\": \"Unix Millis Earliest Start Time\",           \"type\": \"integer\"         },         \"unix_millis_request_time\": {           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"priority\": {           \"title\": \"Priority\",           \"description\": \"Priority information about this task\",           \"anyOf\": [             {               \"type\": \"object\"             },             {               \"type\": \"string\"             }           ]         },         \"labels\": {           \"title\": \"Labels\",           \"description\": \"Information about how and why this task was booked\",           \"type\": \"array\",           \"items\": {             \"type\": \"string\"           }         },         \"requester\": {           \"title\": \"Requester\",           \"description\": \"(Optional) An identifier for the entity that requested this task\",           \"type\": \"string\"         }       },       \"required\": [         \"id\"       ]     },     \"Category\": {       \"title\": \"Category\",       \"description\": \"The category of this task or phase\",       \"type\": \"string\"     },     \"Detail\": {       \"title\": \"Detail\",       \"description\": \"Detailed information about a task, phase, or event\",       \"anyOf\": [         {           \"type\": \"object\"         },         {           \"type\": \"array\",           \"items\": {}         },         {           \"type\": \"string\"         }       ]     },     \"EstimateMillis\": {       \"title\": \"EstimateMillis\",       \"description\": \"An estimate, in milliseconds, of how long the subject will take to complete\",       \"minimum\": 0,       \"type\": \"integer\"     },     \"AssignedTo\": {       \"title\": \"AssignedTo\",       \"type\": \"object\",       \"properties\": {         \"group\": {           \"title\": \"Group\",           \"type\": \"string\"         },         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         }       },       \"required\": [         \"group\",         \"name\"       ]     },     \"Status\": {       \"title\": \"Status\",       \"description\": \"An enumeration.\",       \"enum\": [         \"uninitialized\",         \"blocked\",         \"error\",         \"failed\",         \"queued\",         \"standby\",         \"underway\",         \"delayed\",         \"skipped\",         \"canceled\",         \"killed\",         \"completed\"       ]     },     \"Status1\": {       \"title\": \"Status1\",       \"description\": \"An enumeration.\",       \"enum\": [         \"queued\",         \"selected\",         \"dispatched\",         \"failed_to_assign\",         \"canceled_in_flight\"       ]     },     \"Assignment\": {       \"title\": \"Assignment\",       \"type\": \"object\",       \"properties\": {         \"fleet_name\": {           \"title\": \"Fleet Name\",           \"type\": \"string\"         },         \"expected_robot_name\": {           \"title\": \"Expected Robot Name\",           \"type\": \"string\"         }       }     },     \"Error\": {       \"title\": \"Error\",       \"type\": \"object\",       \"properties\": {         \"code\": {           \"title\": \"Code\",           \"description\": \"A standard code for the kind of error that has occurred\",           \"minimum\": 0,           \"type\": \"integer\"         },         \"category\": {           \"title\": \"Category\",           \"description\": \"The category of the error\",           \"type\": \"string\"         },         \"detail\": {           \"title\": \"Detail\",           \"description\": \"Details about the error\",           \"type\": \"string\"         }       }     },     \"Dispatch\": {       \"title\": \"Dispatch\",       \"type\": \"object\",       \"properties\": {         \"status\": {           \"$ref\": \"#/definitions/Status1\"         },         \"assignment\": {           \"$ref\": \"#/definitions/Assignment\"         },         \"errors\": {           \"title\": \"Errors\",           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/Error\"           }         }       },       \"required\": [         \"status\"       ]     },     \"Id\": {       \"title\": \"Id\",       \"minimum\": 0,       \"type\": \"integer\"     },     \"EventState\": {       \"title\": \"EventState\",       \"type\": \"object\",       \"properties\": {         \"id\": {           \"$ref\": \"#/definitions/Id\"         },         \"status\": {           \"$ref\": \"#/definitions/Status\"         },         \"name\": {           \"title\": \"Name\",           \"description\": \"The brief name of the event\",           \"type\": \"string\"         },         \"detail\": {           \"title\": \"Detail\",           \"description\": \"Detailed information about the event\",           \"allOf\": [             {               \"$ref\": \"#/definitions/Detail\"             }           ]         },         \"deps\": {           \"title\": \"Deps\",           \"description\": \"This event may depend on other events. This array contains the IDs of those other event dependencies.\",           \"type\": \"array\",           \"items\": {             \"type\": \"integer\",             \"minimum\": 0           }         }       },       \"required\": [         \"id\"       ]     },     \"Undo\": {       \"title\": \"Undo\",       \"type\": \"object\",       \"properties\": {         \"unix_millis_request_time\": {           \"title\": \"Unix Millis Request Time\",           \"description\": \"The time that the undo skip request arrived\",           \"type\": \"integer\"         },         \"labels\": {           \"title\": \"Labels\",           \"description\": \"Labels to describe the undo skip request\",           \"type\": \"array\",           \"items\": {             \"type\": \"string\"           }         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ]     },     \"SkipPhaseRequest\": {       \"title\": \"SkipPhaseRequest\",       \"type\": \"object\",       \"properties\": {         \"unix_millis_request_time\": {           \"title\": \"Unix Millis Request Time\",           \"description\": \"The time that the skip request arrived\",           \"type\": \"integer\"         },         \"labels\": {           \"title\": \"Labels\",           \"description\": \"Labels to describe the purpose of the skip request\",           \"type\": \"array\",           \"items\": {             \"type\": \"string\"           }         },         \"undo\": {           \"title\": \"Undo\",           \"description\": \"Information about an undo skip request that applied to this request\",           \"allOf\": [             {               \"$ref\": \"#/definitions/Undo\"             }           ]         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ]     },     \"Phase\": {       \"title\": \"Phase\",       \"type\": \"object\",       \"properties\": {         \"id\": {           \"$ref\": \"#/definitions/Id\"         },         \"category\": {           \"$ref\": \"#/definitions/Category\"         },         \"detail\": {           \"$ref\": \"#/definitions/Detail\"         },         \"unix_millis_start_time\": {           \"title\": \"Unix Millis Start Time\",           \"type\": \"integer\"         },         \"unix_millis_finish_time\": {           \"title\": \"Unix Millis Finish Time\",           \"type\": \"integer\"         },         \"original_estimate_millis\": {           \"$ref\": \"#/definitions/EstimateMillis\"         },         \"estimate_millis\": {           \"$ref\": \"#/definitions/EstimateMillis\"         },         \"final_event_id\": {           \"$ref\": \"#/definitions/Id\"         },         \"events\": {           \"title\": \"Events\",           \"description\": \"A dictionary of events for this phase. The keys (property names) are the event IDs, which are integers.\",           \"type\": \"object\",           \"additionalProperties\": {             \"$ref\": \"#/definitions/EventState\"           }         },         \"skip_requests\": {           \"title\": \"Skip Requests\",           \"description\": \"Information about any skip requests that have been received\",           \"type\": \"object\",           \"additionalProperties\": {             \"$ref\": \"#/definitions/SkipPhaseRequest\"           }         }       },       \"required\": [         \"id\"       ]     },     \"ResumedBy\": {       \"title\": \"ResumedBy\",       \"type\": \"object\",       \"properties\": {         \"unix_millis_request_time\": {           \"title\": \"Unix Millis Request Time\",           \"description\": \"The time that the resume request arrived\",           \"type\": \"integer\"         },         \"labels\": {           \"title\": \"Labels\",           \"description\": \"Labels to describe the resume request\",           \"type\": \"array\",           \"items\": {             \"type\": \"string\"           }         }       },       \"required\": [         \"labels\"       ]     },     \"Interruption\": {       \"title\": \"Interruption\",       \"type\": \"object\",       \"properties\": {         \"unix_millis_request_time\": {           \"title\": \"Unix Millis Request Time\",           \"description\": \"The time that the interruption request arrived\",           \"type\": \"integer\"         },         \"labels\": {           \"title\": \"Labels\",           \"description\": \"Labels to describe the purpose of the interruption\",           \"type\": \"array\",           \"items\": {             \"type\": \"string\"           }         },         \"resumed_by\": {           \"title\": \"Resumed By\",           \"description\": \"Information about the resume request that ended this interruption. This field will be missing if the interruption is still active.\",           \"allOf\": [             {               \"$ref\": \"#/definitions/ResumedBy\"             }           ]         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ]     },     \"Cancellation\": {       \"title\": \"Cancellation\",       \"type\": \"object\",       \"properties\": {         \"unix_millis_request_time\": {           \"title\": \"Unix Millis Request Time\",           \"description\": \"The time that the cancellation request arrived\",           \"type\": \"integer\"         },         \"labels\": {           \"title\": \"Labels\",           \"description\": \"Labels to describe the cancel request\",           \"type\": \"array\",           \"items\": {             \"type\": \"string\"           }         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ]     },     \"Killed\": {       \"title\": \"Killed\",       \"type\": \"object\",       \"properties\": {         \"unix_millis_request_time\": {           \"title\": \"Unix Millis Request Time\",           \"description\": \"The time that the cancellation request arrived\",           \"type\": \"integer\"         },         \"labels\": {           \"title\": \"Labels\",           \"description\": \"Labels to describe the kill request\",           \"type\": \"array\",           \"items\": {             \"type\": \"string\"           }         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ]     }   } } ```   ### /tasks/{task_id}/log   ``` {   \"title\": \"TaskEventLog\",   \"type\": \"object\",   \"properties\": {     \"task_id\": {       \"title\": \"Task Id\",       \"type\": \"string\"     },     \"log\": {       \"title\": \"Log\",       \"description\": \"Log entries related to the overall task\",       \"type\": \"array\",       \"items\": {         \"$ref\": \"#/definitions/LogEntry\"       }     },     \"phases\": {       \"title\": \"Phases\",       \"description\": \"A dictionary whose keys (property names) are the indices of a phase\",       \"type\": \"object\",       \"additionalProperties\": {         \"$ref\": \"#/definitions/Phases\"       }     }   },   \"required\": [     \"task_id\"   ],   \"additionalProperties\": false,   \"definitions\": {     \"Tier\": {       \"title\": \"Tier\",       \"description\": \"An enumeration.\",       \"enum\": [         \"uninitialized\",         \"info\",         \"warning\",         \"error\"       ]     },     \"LogEntry\": {       \"title\": \"LogEntry\",       \"type\": \"object\",       \"properties\": {         \"seq\": {           \"title\": \"Seq\",           \"description\": \"Sequence number for this entry. Each entry has a unique sequence number which monotonically increase, until integer overflow causes a wrap around.\",           \"exclusiveMaximum\": 4294967296,           \"minimum\": 0,           \"type\": \"integer\"         },         \"tier\": {           \"description\": \"The importance level of the log entry\",           \"allOf\": [             {               \"$ref\": \"#/definitions/Tier\"             }           ]         },         \"unix_millis_time\": {           \"title\": \"Unix Millis Time\",           \"type\": \"integer\"         },         \"text\": {           \"title\": \"Text\",           \"description\": \"The text of the log entry\",           \"type\": \"string\"         }       },       \"required\": [         \"seq\",         \"tier\",         \"unix_millis_time\",         \"text\"       ]     },     \"Phases\": {       \"title\": \"Phases\",       \"type\": \"object\",       \"properties\": {         \"log\": {           \"title\": \"Log\",           \"description\": \"Log entries related to the overall phase\",           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/LogEntry\"           }         },         \"events\": {           \"title\": \"Events\",           \"description\": \"A dictionary whose keys (property names) are the indices of an event in the phase\",           \"type\": \"object\",           \"additionalProperties\": {             \"type\": \"array\",             \"items\": {               \"$ref\": \"#/definitions/LogEntry\"             }           }         }       },       \"additionalProperties\": false     }   } } ```   ### /dispensers/{guid}/state   ``` {   \"title\": \"DispenserState\",   \"type\": \"object\",   \"properties\": {     \"time\": {       \"title\": \"Time\",       \"default\": {         \"sec\": 0,         \"nanosec\": 0       },       \"allOf\": [         {           \"$ref\": \"#/definitions/Time\"         }       ]     },     \"guid\": {       \"title\": \"Guid\",       \"default\": \"\",       \"type\": \"string\"     },     \"mode\": {       \"title\": \"Mode\",       \"default\": 0,       \"minimum\": -2147483648,       \"maximum\": 2147483647,       \"type\": \"integer\"     },     \"request_guid_queue\": {       \"title\": \"Request Guid Queue\",       \"default\": [],       \"type\": \"array\",       \"items\": {         \"type\": \"string\"       }     },     \"seconds_remaining\": {       \"title\": \"Seconds Remaining\",       \"default\": 0,       \"type\": \"number\"     }   },   \"required\": [     \"time\",     \"guid\",     \"mode\",     \"request_guid_queue\",     \"seconds_remaining\"   ],   \"definitions\": {     \"Time\": {       \"title\": \"Time\",       \"type\": \"object\",       \"properties\": {         \"sec\": {           \"title\": \"Sec\",           \"default\": 0,           \"minimum\": -2147483648,           \"maximum\": 2147483647,           \"type\": \"integer\"         },         \"nanosec\": {           \"title\": \"Nanosec\",           \"default\": 0,           \"minimum\": 0,           \"maximum\": 4294967295,           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ]     }   } } ```   ### /dispensers/{guid}/health   ``` {   \"title\": \"DispenserHealth\",   \"type\": \"object\",   \"properties\": {     \"health_status\": {       \"title\": \"Health Status\",       \"maxLength\": 255,       \"nullable\": true,       \"type\": \"string\"     },     \"health_message\": {       \"title\": \"Health Message\",       \"nullable\": true,       \"type\": \"string\"     },     \"id_\": {       \"title\": \"Id \",       \"maxLength\": 255,       \"type\": \"string\"     }   },   \"required\": [     \"health_status\",     \"id_\"   ],   \"additionalProperties\": false } ```   ### /ingestors/{guid}/state   ``` {   \"title\": \"IngestorState\",   \"type\": \"object\",   \"properties\": {     \"time\": {       \"title\": \"Time\",       \"default\": {         \"sec\": 0,         \"nanosec\": 0       },       \"allOf\": [         {           \"$ref\": \"#/definitions/Time\"         }       ]     },     \"guid\": {       \"title\": \"Guid\",       \"default\": \"\",       \"type\": \"string\"     },     \"mode\": {       \"title\": \"Mode\",       \"default\": 0,       \"minimum\": -2147483648,       \"maximum\": 2147483647,       \"type\": \"integer\"     },     \"request_guid_queue\": {       \"title\": \"Request Guid Queue\",       \"default\": [],       \"type\": \"array\",       \"items\": {         \"type\": \"string\"       }     },     \"seconds_remaining\": {       \"title\": \"Seconds Remaining\",       \"default\": 0,       \"type\": \"number\"     }   },   \"required\": [     \"time\",     \"guid\",     \"mode\",     \"request_guid_queue\",     \"seconds_remaining\"   ],   \"definitions\": {     \"Time\": {       \"title\": \"Time\",       \"type\": \"object\",       \"properties\": {         \"sec\": {           \"title\": \"Sec\",           \"default\": 0,           \"minimum\": -2147483648,           \"maximum\": 2147483647,           \"type\": \"integer\"         },         \"nanosec\": {           \"title\": \"Nanosec\",           \"default\": 0,           \"minimum\": 0,           \"maximum\": 4294967295,           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ]     }   } } ```   ### /ingestors/{guid}/health   ``` {   \"title\": \"IngestorHealth\",   \"type\": \"object\",   \"properties\": {     \"health_status\": {       \"title\": \"Health Status\",       \"maxLength\": 255,       \"nullable\": true,       \"type\": \"string\"     },     \"health_message\": {       \"title\": \"Health Message\",       \"nullable\": true,       \"type\": \"string\"     },     \"id_\": {       \"title\": \"Id \",       \"maxLength\": 255,       \"type\": \"string\"     }   },   \"required\": [     \"health_status\",     \"id_\"   ],   \"additionalProperties\": false } ```   ### /fleets/{name}/state   ``` {   \"title\": \"FleetState\",   \"type\": \"object\",   \"properties\": {     \"name\": {       \"title\": \"Name\",       \"type\": \"string\"     },     \"robots\": {       \"title\": \"Robots\",       \"description\": \"A dictionary of the states of the robots that belong to this fleet\",       \"type\": \"object\",       \"additionalProperties\": {         \"$ref\": \"#/definitions/RobotState\"       }     }   },   \"definitions\": {     \"Status2\": {       \"title\": \"Status2\",       \"description\": \"An enumeration.\",       \"enum\": [         \"uninitialized\",         \"offline\",         \"shutdown\",         \"idle\",         \"charging\",         \"working\",         \"error\"       ]     },     \"Location2D\": {       \"title\": \"Location2D\",       \"type\": \"object\",       \"properties\": {         \"map\": {           \"title\": \"Map\",           \"type\": \"string\"         },         \"x\": {           \"title\": \"X\",           \"type\": \"number\"         },         \"y\": {           \"title\": \"Y\",           \"type\": \"number\"         },         \"yaw\": {           \"title\": \"Yaw\",           \"type\": \"number\"         }       },       \"required\": [         \"map\",         \"x\",         \"y\",         \"yaw\"       ]     },     \"Issue\": {       \"title\": \"Issue\",       \"type\": \"object\",       \"properties\": {         \"category\": {           \"title\": \"Category\",           \"description\": \"Category of the robot\'s issue\",           \"type\": \"string\"         },         \"detail\": {           \"title\": \"Detail\",           \"description\": \"Detailed information about the issue\",           \"anyOf\": [             {               \"type\": \"object\"             },             {               \"type\": \"array\",               \"items\": {}             },             {               \"type\": \"string\"             }           ]         }       }     },     \"RobotState\": {       \"title\": \"RobotState\",       \"type\": \"object\",       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"status\": {           \"description\": \"A simple token representing the status of the robot\",           \"allOf\": [             {               \"$ref\": \"#/definitions/Status2\"             }           ]         },         \"task_id\": {           \"title\": \"Task Id\",           \"description\": \"The ID of the task this robot is currently working on. Empty string if the robot is not working on a task.\",           \"type\": \"string\"         },         \"unix_millis_time\": {           \"title\": \"Unix Millis Time\",           \"type\": \"integer\"         },         \"location\": {           \"$ref\": \"#/definitions/Location2D\"         },         \"battery\": {           \"title\": \"Battery\",           \"description\": \"State of charge of the battery. Values range from 0.0 (depleted) to 1.0 (fully charged)\",           \"minimum\": 0.0,           \"maximum\": 1.0,           \"type\": \"number\"         },         \"issues\": {           \"title\": \"Issues\",           \"description\": \"A list of issues with the robot that operators need to address\",           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/Issue\"           }         }       }     }   } } ```   ### /fleets/{name}/log   ``` {   \"title\": \"FleetState\",   \"type\": \"object\",   \"properties\": {     \"name\": {       \"title\": \"Name\",       \"type\": \"string\"     },     \"log\": {       \"title\": \"Log\",       \"description\": \"Log for the overall fleet\",       \"type\": \"array\",       \"items\": {         \"$ref\": \"#/definitions/LogEntry\"       }     },     \"robots\": {       \"title\": \"Robots\",       \"description\": \"Dictionary of logs for the individual robots. The keys (property names) are the robot names.\",       \"type\": \"object\",       \"additionalProperties\": {         \"type\": \"array\",         \"items\": {           \"$ref\": \"#/definitions/LogEntry\"         }       }     }   },   \"definitions\": {     \"Tier\": {       \"title\": \"Tier\",       \"description\": \"An enumeration.\",       \"enum\": [         \"uninitialized\",         \"info\",         \"warning\",         \"error\"       ]     },     \"LogEntry\": {       \"title\": \"LogEntry\",       \"type\": \"object\",       \"properties\": {         \"seq\": {           \"title\": \"Seq\",           \"description\": \"Sequence number for this entry. Each entry has a unique sequence number which monotonically increase, until integer overflow causes a wrap around.\",           \"exclusiveMaximum\": 4294967296,           \"minimum\": 0,           \"type\": \"integer\"         },         \"tier\": {           \"description\": \"The importance level of the log entry\",           \"allOf\": [             {               \"$ref\": \"#/definitions/Tier\"             }           ]         },         \"unix_millis_time\": {           \"title\": \"Unix Millis Time\",           \"type\": \"integer\"         },         \"text\": {           \"title\": \"Text\",           \"description\": \"The text of the log entry\",           \"type\": \"string\"         }       },       \"required\": [         \"seq\",         \"tier\",         \"unix_millis_time\",         \"text\"       ]     }   } } ```
     * @summary Socket.io endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async lambdaSocketIoGet(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.lambdaSocketIoGet(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DefaultApiFp(configuration);
  return {
    /**
     * Get the effective permissions of the current user
     * @summary Get Effective Permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEffectivePermissionsPermissionsGet(options?: any): AxiosPromise<Array<Permission>> {
      return localVarFp
        .getEffectivePermissionsPermissionsGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get the current rmf time in unix milliseconds
     * @summary Get Time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTimeTimeGet(options?: any): AxiosPromise<number> {
      return localVarFp.getTimeTimeGet(options).then((request) => request(axios, basePath));
    },
    /**
     * Get the currently logged in user
     * @summary Get User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserUserGet(options?: any): AxiosPromise<User> {
      return localVarFp.getUserUserGet(options).then((request) => request(axios, basePath));
    },
    /**
     *  # NOTE: This endpoint is here for documentation purposes only, this is _not_ a REST endpoint.  ## About This exposes a minimal pubsub system built on top of socket.io. It works similar to a normal socket.io endpoint, except that are 2 special rooms which control subscriptions.  ## Rooms ### subscribe Clients must send a message to this room to start receiving messages on other rooms. The message must be of the form:  ``` {     \"room\": \"<room_name>\" } ```  ### unsubscribe Clients can send a message to this room to stop receiving messages on other rooms. The message must be of the form:  ``` {     \"room\": \"<room_name>\" } ```              ### /alerts   ``` {   \"title\": \"Alert\",   \"description\": \"General alert that can be triggered by events.\",   \"type\": \"object\",   \"properties\": {     \"id\": {       \"title\": \"Id\",       \"maxLength\": 255,       \"type\": \"string\"     },     \"original_id\": {       \"title\": \"Original Id\",       \"maxLength\": 255,       \"type\": \"string\"     },     \"category\": {       \"title\": \"Category\",       \"description\": \"Default: default<br/>Task: task<br/>Fleet: fleet<br/>Robot: robot\",       \"maxLength\": 7,       \"type\": \"string\"     },     \"unix_millis_created_time\": {       \"title\": \"Unix Millis Created Time\",       \"minimum\": -9223372036854775808,       \"maximum\": 9223372036854775807,       \"type\": \"integer\"     },     \"acknowledged_by\": {       \"title\": \"Acknowledged By\",       \"maxLength\": 255,       \"nullable\": true,       \"type\": \"string\"     },     \"unix_millis_acknowledged_time\": {       \"title\": \"Unix Millis Acknowledged Time\",       \"minimum\": -9223372036854775808,       \"maximum\": 9223372036854775807,       \"nullable\": true,       \"type\": \"integer\"     }   },   \"required\": [     \"id\",     \"original_id\",     \"category\",     \"unix_millis_created_time\"   ],   \"additionalProperties\": false } ```   ### /beacons   ``` {   \"title\": \"BeaconState\",   \"type\": \"object\",   \"properties\": {     \"id\": {       \"title\": \"Id\",       \"maxLength\": 255,       \"type\": \"string\"     },     \"online\": {       \"title\": \"Online\",       \"type\": \"boolean\"     },     \"category\": {       \"title\": \"Category\",       \"maxLength\": 255,       \"nullable\": true,       \"type\": \"string\"     },     \"activated\": {       \"title\": \"Activated\",       \"type\": \"boolean\"     },     \"level\": {       \"title\": \"Level\",       \"maxLength\": 255,       \"nullable\": true,       \"type\": \"string\"     }   },   \"required\": [     \"id\",     \"online\",     \"activated\"   ],   \"additionalProperties\": false } ```   ### /building_map   ``` {   \"title\": \"BuildingMap\",   \"type\": \"object\",   \"properties\": {     \"name\": {       \"title\": \"Name\",       \"default\": \"\",       \"type\": \"string\"     },     \"levels\": {       \"title\": \"Levels\",       \"type\": \"array\",       \"items\": {         \"$ref\": \"#/definitions/Level\"       }     },     \"lifts\": {       \"title\": \"Lifts\",       \"default\": [],       \"type\": \"array\",       \"items\": {         \"$ref\": \"#/definitions/Lift\"       }     }   },   \"required\": [     \"name\",     \"levels\",     \"lifts\"   ],   \"definitions\": {     \"AffineImage\": {       \"title\": \"AffineImage\",       \"type\": \"object\",       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"default\": \"\",           \"type\": \"string\"         },         \"x_offset\": {           \"title\": \"X Offset\",           \"default\": 0,           \"type\": \"number\"         },         \"y_offset\": {           \"title\": \"Y Offset\",           \"default\": 0,           \"type\": \"number\"         },         \"yaw\": {           \"title\": \"Yaw\",           \"default\": 0,           \"type\": \"number\"         },         \"scale\": {           \"title\": \"Scale\",           \"default\": 0,           \"type\": \"number\"         },         \"encoding\": {           \"title\": \"Encoding\",           \"default\": \"\",           \"type\": \"string\"         },         \"data\": {           \"title\": \"Data\",           \"type\": \"string\"         }       },       \"required\": [         \"name\",         \"x_offset\",         \"y_offset\",         \"yaw\",         \"scale\",         \"encoding\",         \"data\"       ]     },     \"Place\": {       \"title\": \"Place\",       \"type\": \"object\",       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"default\": \"\",           \"type\": \"string\"         },         \"x\": {           \"title\": \"X\",           \"default\": 0,           \"type\": \"number\"         },         \"y\": {           \"title\": \"Y\",           \"default\": 0,           \"type\": \"number\"         },         \"yaw\": {           \"title\": \"Yaw\",           \"default\": 0,           \"type\": \"number\"         },         \"position_tolerance\": {           \"title\": \"Position Tolerance\",           \"default\": 0,           \"type\": \"number\"         },         \"yaw_tolerance\": {           \"title\": \"Yaw Tolerance\",           \"default\": 0,           \"type\": \"number\"         }       },       \"required\": [         \"name\",         \"x\",         \"y\",         \"yaw\",         \"position_tolerance\",         \"yaw_tolerance\"       ]     },     \"Door\": {       \"title\": \"Door\",       \"type\": \"object\",       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"default\": \"\",           \"type\": \"string\"         },         \"v1_x\": {           \"title\": \"V1 X\",           \"default\": 0,           \"type\": \"number\"         },         \"v1_y\": {           \"title\": \"V1 Y\",           \"default\": 0,           \"type\": \"number\"         },         \"v2_x\": {           \"title\": \"V2 X\",           \"default\": 0,           \"type\": \"number\"         },         \"v2_y\": {           \"title\": \"V2 Y\",           \"default\": 0,           \"type\": \"number\"         },         \"door_type\": {           \"title\": \"Door Type\",           \"default\": 0,           \"minimum\": 0,           \"maximum\": 255,           \"type\": \"integer\"         },         \"motion_range\": {           \"title\": \"Motion Range\",           \"default\": 0,           \"type\": \"number\"         },         \"motion_direction\": {           \"title\": \"Motion Direction\",           \"default\": 0,           \"minimum\": -2147483648,           \"maximum\": 2147483647,           \"type\": \"integer\"         }       },       \"required\": [         \"name\",         \"v1_x\",         \"v1_y\",         \"v2_x\",         \"v2_y\",         \"door_type\",         \"motion_range\",         \"motion_direction\"       ]     },     \"Param\": {       \"title\": \"Param\",       \"type\": \"object\",       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"default\": \"\",           \"type\": \"string\"         },         \"type\": {           \"title\": \"Type\",           \"default\": 0,           \"minimum\": 0,           \"maximum\": 4294967295,           \"type\": \"integer\"         },         \"value_int\": {           \"title\": \"Value Int\",           \"default\": 0,           \"minimum\": -2147483648,           \"maximum\": 2147483647,           \"type\": \"integer\"         },         \"value_float\": {           \"title\": \"Value Float\",           \"default\": 0,           \"type\": \"number\"         },         \"value_string\": {           \"title\": \"Value String\",           \"default\": \"\",           \"type\": \"string\"         },         \"value_bool\": {           \"title\": \"Value Bool\",           \"default\": false,           \"type\": \"boolean\"         }       },       \"required\": [         \"name\",         \"type\",         \"value_int\",         \"value_float\",         \"value_string\",         \"value_bool\"       ]     },     \"GraphNode\": {       \"title\": \"GraphNode\",       \"type\": \"object\",       \"properties\": {         \"x\": {           \"title\": \"X\",           \"default\": 0,           \"type\": \"number\"         },         \"y\": {           \"title\": \"Y\",           \"default\": 0,           \"type\": \"number\"         },         \"name\": {           \"title\": \"Name\",           \"default\": \"\",           \"type\": \"string\"         },         \"params\": {           \"title\": \"Params\",           \"default\": [],           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/Param\"           }         }       },       \"required\": [         \"x\",         \"y\",         \"name\",         \"params\"       ]     },     \"GraphEdge\": {       \"title\": \"GraphEdge\",       \"type\": \"object\",       \"properties\": {         \"v1_idx\": {           \"title\": \"V1 Idx\",           \"default\": 0,           \"minimum\": 0,           \"maximum\": 4294967295,           \"type\": \"integer\"         },         \"v2_idx\": {           \"title\": \"V2 Idx\",           \"default\": 0,           \"minimum\": 0,           \"maximum\": 4294967295,           \"type\": \"integer\"         },         \"params\": {           \"title\": \"Params\",           \"default\": [],           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/Param\"           }         },         \"edge_type\": {           \"title\": \"Edge Type\",           \"default\": 0,           \"minimum\": 0,           \"maximum\": 255,           \"type\": \"integer\"         }       },       \"required\": [         \"v1_idx\",         \"v2_idx\",         \"params\",         \"edge_type\"       ]     },     \"Graph\": {       \"title\": \"Graph\",       \"type\": \"object\",       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"default\": \"\",           \"type\": \"string\"         },         \"vertices\": {           \"title\": \"Vertices\",           \"default\": [],           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/GraphNode\"           }         },         \"edges\": {           \"title\": \"Edges\",           \"default\": [],           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/GraphEdge\"           }         },         \"params\": {           \"title\": \"Params\",           \"default\": [],           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/Param\"           }         }       },       \"required\": [         \"name\",         \"vertices\",         \"edges\",         \"params\"       ]     },     \"Level\": {       \"title\": \"Level\",       \"type\": \"object\",       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"default\": \"\",           \"type\": \"string\"         },         \"elevation\": {           \"title\": \"Elevation\",           \"default\": 0,           \"type\": \"number\"         },         \"images\": {           \"title\": \"Images\",           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/AffineImage\"           }         },         \"places\": {           \"title\": \"Places\",           \"default\": [],           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/Place\"           }         },         \"doors\": {           \"title\": \"Doors\",           \"default\": [],           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/Door\"           }         },         \"nav_graphs\": {           \"title\": \"Nav Graphs\",           \"default\": [],           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/Graph\"           }         },         \"wall_graph\": {           \"title\": \"Wall Graph\",           \"default\": {             \"name\": \"\",             \"vertices\": [],             \"edges\": [],             \"params\": []           },           \"allOf\": [             {               \"$ref\": \"#/definitions/Graph\"             }           ]         }       },       \"required\": [         \"name\",         \"elevation\",         \"images\",         \"places\",         \"doors\",         \"nav_graphs\",         \"wall_graph\"       ]     },     \"Lift\": {       \"title\": \"Lift\",       \"type\": \"object\",       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"default\": \"\",           \"type\": \"string\"         },         \"levels\": {           \"title\": \"Levels\",           \"default\": [],           \"type\": \"array\",           \"items\": {             \"type\": \"string\"           }         },         \"doors\": {           \"title\": \"Doors\",           \"default\": [],           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/Door\"           }         },         \"wall_graph\": {           \"title\": \"Wall Graph\",           \"default\": {             \"name\": \"\",             \"vertices\": [],             \"edges\": [],             \"params\": []           },           \"allOf\": [             {               \"$ref\": \"#/definitions/Graph\"             }           ]         },         \"ref_x\": {           \"title\": \"Ref X\",           \"default\": 0,           \"type\": \"number\"         },         \"ref_y\": {           \"title\": \"Ref Y\",           \"default\": 0,           \"type\": \"number\"         },         \"ref_yaw\": {           \"title\": \"Ref Yaw\",           \"default\": 0,           \"type\": \"number\"         },         \"width\": {           \"title\": \"Width\",           \"default\": 0,           \"type\": \"number\"         },         \"depth\": {           \"title\": \"Depth\",           \"default\": 0,           \"type\": \"number\"         }       },       \"required\": [         \"name\",         \"levels\",         \"doors\",         \"wall_graph\",         \"ref_x\",         \"ref_y\",         \"ref_yaw\",         \"width\",         \"depth\"       ]     }   } } ```   ### /doors/{door_name}/state   ``` {   \"title\": \"DoorState\",   \"type\": \"object\",   \"properties\": {     \"door_time\": {       \"title\": \"Door Time\",       \"default\": {         \"sec\": 0,         \"nanosec\": 0       },       \"allOf\": [         {           \"$ref\": \"#/definitions/Time\"         }       ]     },     \"door_name\": {       \"title\": \"Door Name\",       \"default\": \"\",       \"type\": \"string\"     },     \"current_mode\": {       \"title\": \"Current Mode\",       \"default\": {         \"value\": 0       },       \"allOf\": [         {           \"$ref\": \"#/definitions/DoorMode\"         }       ]     }   },   \"required\": [     \"door_time\",     \"door_name\",     \"current_mode\"   ],   \"definitions\": {     \"Time\": {       \"title\": \"Time\",       \"type\": \"object\",       \"properties\": {         \"sec\": {           \"title\": \"Sec\",           \"default\": 0,           \"minimum\": -2147483648,           \"maximum\": 2147483647,           \"type\": \"integer\"         },         \"nanosec\": {           \"title\": \"Nanosec\",           \"default\": 0,           \"minimum\": 0,           \"maximum\": 4294967295,           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ]     },     \"DoorMode\": {       \"title\": \"DoorMode\",       \"type\": \"object\",       \"properties\": {         \"value\": {           \"title\": \"Value\",           \"default\": 0,           \"minimum\": 0,           \"maximum\": 4294967295,           \"type\": \"integer\"         }       },       \"required\": [         \"value\"       ]     }   } } ```   ### /doors/{door_name}/health   ``` {   \"title\": \"DoorHealth\",   \"type\": \"object\",   \"properties\": {     \"health_status\": {       \"title\": \"Health Status\",       \"maxLength\": 255,       \"nullable\": true,       \"type\": \"string\"     },     \"health_message\": {       \"title\": \"Health Message\",       \"nullable\": true,       \"type\": \"string\"     },     \"id_\": {       \"title\": \"Id \",       \"maxLength\": 255,       \"type\": \"string\"     }   },   \"required\": [     \"health_status\",     \"id_\"   ],   \"additionalProperties\": false } ```   ### /lifts/{lift_name}/state   ``` {   \"title\": \"LiftState\",   \"type\": \"object\",   \"properties\": {     \"lift_time\": {       \"title\": \"Lift Time\",       \"default\": {         \"sec\": 0,         \"nanosec\": 0       },       \"allOf\": [         {           \"$ref\": \"#/definitions/Time\"         }       ]     },     \"lift_name\": {       \"title\": \"Lift Name\",       \"default\": \"\",       \"type\": \"string\"     },     \"available_floors\": {       \"title\": \"Available Floors\",       \"default\": [],       \"type\": \"array\",       \"items\": {         \"type\": \"string\"       }     },     \"current_floor\": {       \"title\": \"Current Floor\",       \"default\": \"\",       \"type\": \"string\"     },     \"destination_floor\": {       \"title\": \"Destination Floor\",       \"default\": \"\",       \"type\": \"string\"     },     \"door_state\": {       \"title\": \"Door State\",       \"default\": 0,       \"minimum\": 0,       \"maximum\": 255,       \"type\": \"integer\"     },     \"motion_state\": {       \"title\": \"Motion State\",       \"default\": 0,       \"minimum\": 0,       \"maximum\": 255,       \"type\": \"integer\"     },     \"available_modes\": {       \"title\": \"Available Modes\",       \"type\": \"array\",       \"items\": {         \"type\": \"integer\"       }     },     \"current_mode\": {       \"title\": \"Current Mode\",       \"default\": 0,       \"minimum\": 0,       \"maximum\": 255,       \"type\": \"integer\"     },     \"session_id\": {       \"title\": \"Session Id\",       \"default\": \"\",       \"type\": \"string\"     }   },   \"required\": [     \"lift_time\",     \"lift_name\",     \"available_floors\",     \"current_floor\",     \"destination_floor\",     \"door_state\",     \"motion_state\",     \"available_modes\",     \"current_mode\",     \"session_id\"   ],   \"definitions\": {     \"Time\": {       \"title\": \"Time\",       \"type\": \"object\",       \"properties\": {         \"sec\": {           \"title\": \"Sec\",           \"default\": 0,           \"minimum\": -2147483648,           \"maximum\": 2147483647,           \"type\": \"integer\"         },         \"nanosec\": {           \"title\": \"Nanosec\",           \"default\": 0,           \"minimum\": 0,           \"maximum\": 4294967295,           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ]     }   } } ```   ### /lifts/{lift_name}/health   ``` {   \"title\": \"LiftHealth\",   \"type\": \"object\",   \"properties\": {     \"health_status\": {       \"title\": \"Health Status\",       \"maxLength\": 255,       \"nullable\": true,       \"type\": \"string\"     },     \"health_message\": {       \"title\": \"Health Message\",       \"nullable\": true,       \"type\": \"string\"     },     \"id_\": {       \"title\": \"Id \",       \"maxLength\": 255,       \"type\": \"string\"     }   },   \"required\": [     \"health_status\",     \"id_\"   ],   \"additionalProperties\": false } ```   ### /tasks/{task_id}/state   ``` {   \"title\": \"TaskState\",   \"type\": \"object\",   \"properties\": {     \"booking\": {       \"$ref\": \"#/definitions/Booking\"     },     \"category\": {       \"$ref\": \"#/definitions/Category\"     },     \"detail\": {       \"$ref\": \"#/definitions/Detail\"     },     \"unix_millis_start_time\": {       \"title\": \"Unix Millis Start Time\",       \"type\": \"integer\"     },     \"unix_millis_finish_time\": {       \"title\": \"Unix Millis Finish Time\",       \"type\": \"integer\"     },     \"original_estimate_millis\": {       \"$ref\": \"#/definitions/EstimateMillis\"     },     \"estimate_millis\": {       \"$ref\": \"#/definitions/EstimateMillis\"     },     \"assigned_to\": {       \"title\": \"Assigned To\",       \"description\": \"Which agent (robot) is the task assigned to\",       \"allOf\": [         {           \"$ref\": \"#/definitions/AssignedTo\"         }       ]     },     \"status\": {       \"$ref\": \"#/definitions/Status\"     },     \"dispatch\": {       \"$ref\": \"#/definitions/Dispatch\"     },     \"phases\": {       \"title\": \"Phases\",       \"description\": \"A dictionary of the states of the phases of the task. The keys (property names) are phase IDs, which are integers.\",       \"type\": \"object\",       \"additionalProperties\": {         \"$ref\": \"#/definitions/Phase\"       }     },     \"completed\": {       \"title\": \"Completed\",       \"description\": \"An array of the IDs of completed phases of this task\",       \"type\": \"array\",       \"items\": {         \"$ref\": \"#/definitions/Id\"       }     },     \"active\": {       \"title\": \"Active\",       \"description\": \"The ID of the active phase for this task\",       \"allOf\": [         {           \"$ref\": \"#/definitions/Id\"         }       ]     },     \"pending\": {       \"title\": \"Pending\",       \"description\": \"An array of the pending phases of this task\",       \"type\": \"array\",       \"items\": {         \"$ref\": \"#/definitions/Id\"       }     },     \"interruptions\": {       \"title\": \"Interruptions\",       \"description\": \"A dictionary of interruptions that have been applied to this task. The keys (property names) are the unique token of the interruption request.\",       \"type\": \"object\",       \"additionalProperties\": {         \"$ref\": \"#/definitions/Interruption\"       }     },     \"cancellation\": {       \"title\": \"Cancellation\",       \"description\": \"If the task was cancelled, this will describe information about the request.\",       \"allOf\": [         {           \"$ref\": \"#/definitions/Cancellation\"         }       ]     },     \"killed\": {       \"title\": \"Killed\",       \"description\": \"If the task was killed, this will describe information about the request.\",       \"allOf\": [         {           \"$ref\": \"#/definitions/Killed\"         }       ]     }   },   \"required\": [     \"booking\"   ],   \"definitions\": {     \"Booking\": {       \"title\": \"Booking\",       \"type\": \"object\",       \"properties\": {         \"id\": {           \"title\": \"Id\",           \"description\": \"The unique identifier for this task\",           \"type\": \"string\"         },         \"unix_millis_earliest_start_time\": {           \"title\": \"Unix Millis Earliest Start Time\",           \"type\": \"integer\"         },         \"unix_millis_request_time\": {           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"priority\": {           \"title\": \"Priority\",           \"description\": \"Priority information about this task\",           \"anyOf\": [             {               \"type\": \"object\"             },             {               \"type\": \"string\"             }           ]         },         \"labels\": {           \"title\": \"Labels\",           \"description\": \"Information about how and why this task was booked\",           \"type\": \"array\",           \"items\": {             \"type\": \"string\"           }         },         \"requester\": {           \"title\": \"Requester\",           \"description\": \"(Optional) An identifier for the entity that requested this task\",           \"type\": \"string\"         }       },       \"required\": [         \"id\"       ]     },     \"Category\": {       \"title\": \"Category\",       \"description\": \"The category of this task or phase\",       \"type\": \"string\"     },     \"Detail\": {       \"title\": \"Detail\",       \"description\": \"Detailed information about a task, phase, or event\",       \"anyOf\": [         {           \"type\": \"object\"         },         {           \"type\": \"array\",           \"items\": {}         },         {           \"type\": \"string\"         }       ]     },     \"EstimateMillis\": {       \"title\": \"EstimateMillis\",       \"description\": \"An estimate, in milliseconds, of how long the subject will take to complete\",       \"minimum\": 0,       \"type\": \"integer\"     },     \"AssignedTo\": {       \"title\": \"AssignedTo\",       \"type\": \"object\",       \"properties\": {         \"group\": {           \"title\": \"Group\",           \"type\": \"string\"         },         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         }       },       \"required\": [         \"group\",         \"name\"       ]     },     \"Status\": {       \"title\": \"Status\",       \"description\": \"An enumeration.\",       \"enum\": [         \"uninitialized\",         \"blocked\",         \"error\",         \"failed\",         \"queued\",         \"standby\",         \"underway\",         \"delayed\",         \"skipped\",         \"canceled\",         \"killed\",         \"completed\"       ]     },     \"Status1\": {       \"title\": \"Status1\",       \"description\": \"An enumeration.\",       \"enum\": [         \"queued\",         \"selected\",         \"dispatched\",         \"failed_to_assign\",         \"canceled_in_flight\"       ]     },     \"Assignment\": {       \"title\": \"Assignment\",       \"type\": \"object\",       \"properties\": {         \"fleet_name\": {           \"title\": \"Fleet Name\",           \"type\": \"string\"         },         \"expected_robot_name\": {           \"title\": \"Expected Robot Name\",           \"type\": \"string\"         }       }     },     \"Error\": {       \"title\": \"Error\",       \"type\": \"object\",       \"properties\": {         \"code\": {           \"title\": \"Code\",           \"description\": \"A standard code for the kind of error that has occurred\",           \"minimum\": 0,           \"type\": \"integer\"         },         \"category\": {           \"title\": \"Category\",           \"description\": \"The category of the error\",           \"type\": \"string\"         },         \"detail\": {           \"title\": \"Detail\",           \"description\": \"Details about the error\",           \"type\": \"string\"         }       }     },     \"Dispatch\": {       \"title\": \"Dispatch\",       \"type\": \"object\",       \"properties\": {         \"status\": {           \"$ref\": \"#/definitions/Status1\"         },         \"assignment\": {           \"$ref\": \"#/definitions/Assignment\"         },         \"errors\": {           \"title\": \"Errors\",           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/Error\"           }         }       },       \"required\": [         \"status\"       ]     },     \"Id\": {       \"title\": \"Id\",       \"minimum\": 0,       \"type\": \"integer\"     },     \"EventState\": {       \"title\": \"EventState\",       \"type\": \"object\",       \"properties\": {         \"id\": {           \"$ref\": \"#/definitions/Id\"         },         \"status\": {           \"$ref\": \"#/definitions/Status\"         },         \"name\": {           \"title\": \"Name\",           \"description\": \"The brief name of the event\",           \"type\": \"string\"         },         \"detail\": {           \"title\": \"Detail\",           \"description\": \"Detailed information about the event\",           \"allOf\": [             {               \"$ref\": \"#/definitions/Detail\"             }           ]         },         \"deps\": {           \"title\": \"Deps\",           \"description\": \"This event may depend on other events. This array contains the IDs of those other event dependencies.\",           \"type\": \"array\",           \"items\": {             \"type\": \"integer\",             \"minimum\": 0           }         }       },       \"required\": [         \"id\"       ]     },     \"Undo\": {       \"title\": \"Undo\",       \"type\": \"object\",       \"properties\": {         \"unix_millis_request_time\": {           \"title\": \"Unix Millis Request Time\",           \"description\": \"The time that the undo skip request arrived\",           \"type\": \"integer\"         },         \"labels\": {           \"title\": \"Labels\",           \"description\": \"Labels to describe the undo skip request\",           \"type\": \"array\",           \"items\": {             \"type\": \"string\"           }         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ]     },     \"SkipPhaseRequest\": {       \"title\": \"SkipPhaseRequest\",       \"type\": \"object\",       \"properties\": {         \"unix_millis_request_time\": {           \"title\": \"Unix Millis Request Time\",           \"description\": \"The time that the skip request arrived\",           \"type\": \"integer\"         },         \"labels\": {           \"title\": \"Labels\",           \"description\": \"Labels to describe the purpose of the skip request\",           \"type\": \"array\",           \"items\": {             \"type\": \"string\"           }         },         \"undo\": {           \"title\": \"Undo\",           \"description\": \"Information about an undo skip request that applied to this request\",           \"allOf\": [             {               \"$ref\": \"#/definitions/Undo\"             }           ]         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ]     },     \"Phase\": {       \"title\": \"Phase\",       \"type\": \"object\",       \"properties\": {         \"id\": {           \"$ref\": \"#/definitions/Id\"         },         \"category\": {           \"$ref\": \"#/definitions/Category\"         },         \"detail\": {           \"$ref\": \"#/definitions/Detail\"         },         \"unix_millis_start_time\": {           \"title\": \"Unix Millis Start Time\",           \"type\": \"integer\"         },         \"unix_millis_finish_time\": {           \"title\": \"Unix Millis Finish Time\",           \"type\": \"integer\"         },         \"original_estimate_millis\": {           \"$ref\": \"#/definitions/EstimateMillis\"         },         \"estimate_millis\": {           \"$ref\": \"#/definitions/EstimateMillis\"         },         \"final_event_id\": {           \"$ref\": \"#/definitions/Id\"         },         \"events\": {           \"title\": \"Events\",           \"description\": \"A dictionary of events for this phase. The keys (property names) are the event IDs, which are integers.\",           \"type\": \"object\",           \"additionalProperties\": {             \"$ref\": \"#/definitions/EventState\"           }         },         \"skip_requests\": {           \"title\": \"Skip Requests\",           \"description\": \"Information about any skip requests that have been received\",           \"type\": \"object\",           \"additionalProperties\": {             \"$ref\": \"#/definitions/SkipPhaseRequest\"           }         }       },       \"required\": [         \"id\"       ]     },     \"ResumedBy\": {       \"title\": \"ResumedBy\",       \"type\": \"object\",       \"properties\": {         \"unix_millis_request_time\": {           \"title\": \"Unix Millis Request Time\",           \"description\": \"The time that the resume request arrived\",           \"type\": \"integer\"         },         \"labels\": {           \"title\": \"Labels\",           \"description\": \"Labels to describe the resume request\",           \"type\": \"array\",           \"items\": {             \"type\": \"string\"           }         }       },       \"required\": [         \"labels\"       ]     },     \"Interruption\": {       \"title\": \"Interruption\",       \"type\": \"object\",       \"properties\": {         \"unix_millis_request_time\": {           \"title\": \"Unix Millis Request Time\",           \"description\": \"The time that the interruption request arrived\",           \"type\": \"integer\"         },         \"labels\": {           \"title\": \"Labels\",           \"description\": \"Labels to describe the purpose of the interruption\",           \"type\": \"array\",           \"items\": {             \"type\": \"string\"           }         },         \"resumed_by\": {           \"title\": \"Resumed By\",           \"description\": \"Information about the resume request that ended this interruption. This field will be missing if the interruption is still active.\",           \"allOf\": [             {               \"$ref\": \"#/definitions/ResumedBy\"             }           ]         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ]     },     \"Cancellation\": {       \"title\": \"Cancellation\",       \"type\": \"object\",       \"properties\": {         \"unix_millis_request_time\": {           \"title\": \"Unix Millis Request Time\",           \"description\": \"The time that the cancellation request arrived\",           \"type\": \"integer\"         },         \"labels\": {           \"title\": \"Labels\",           \"description\": \"Labels to describe the cancel request\",           \"type\": \"array\",           \"items\": {             \"type\": \"string\"           }         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ]     },     \"Killed\": {       \"title\": \"Killed\",       \"type\": \"object\",       \"properties\": {         \"unix_millis_request_time\": {           \"title\": \"Unix Millis Request Time\",           \"description\": \"The time that the cancellation request arrived\",           \"type\": \"integer\"         },         \"labels\": {           \"title\": \"Labels\",           \"description\": \"Labels to describe the kill request\",           \"type\": \"array\",           \"items\": {             \"type\": \"string\"           }         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ]     }   } } ```   ### /tasks/{task_id}/log   ``` {   \"title\": \"TaskEventLog\",   \"type\": \"object\",   \"properties\": {     \"task_id\": {       \"title\": \"Task Id\",       \"type\": \"string\"     },     \"log\": {       \"title\": \"Log\",       \"description\": \"Log entries related to the overall task\",       \"type\": \"array\",       \"items\": {         \"$ref\": \"#/definitions/LogEntry\"       }     },     \"phases\": {       \"title\": \"Phases\",       \"description\": \"A dictionary whose keys (property names) are the indices of a phase\",       \"type\": \"object\",       \"additionalProperties\": {         \"$ref\": \"#/definitions/Phases\"       }     }   },   \"required\": [     \"task_id\"   ],   \"additionalProperties\": false,   \"definitions\": {     \"Tier\": {       \"title\": \"Tier\",       \"description\": \"An enumeration.\",       \"enum\": [         \"uninitialized\",         \"info\",         \"warning\",         \"error\"       ]     },     \"LogEntry\": {       \"title\": \"LogEntry\",       \"type\": \"object\",       \"properties\": {         \"seq\": {           \"title\": \"Seq\",           \"description\": \"Sequence number for this entry. Each entry has a unique sequence number which monotonically increase, until integer overflow causes a wrap around.\",           \"exclusiveMaximum\": 4294967296,           \"minimum\": 0,           \"type\": \"integer\"         },         \"tier\": {           \"description\": \"The importance level of the log entry\",           \"allOf\": [             {               \"$ref\": \"#/definitions/Tier\"             }           ]         },         \"unix_millis_time\": {           \"title\": \"Unix Millis Time\",           \"type\": \"integer\"         },         \"text\": {           \"title\": \"Text\",           \"description\": \"The text of the log entry\",           \"type\": \"string\"         }       },       \"required\": [         \"seq\",         \"tier\",         \"unix_millis_time\",         \"text\"       ]     },     \"Phases\": {       \"title\": \"Phases\",       \"type\": \"object\",       \"properties\": {         \"log\": {           \"title\": \"Log\",           \"description\": \"Log entries related to the overall phase\",           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/LogEntry\"           }         },         \"events\": {           \"title\": \"Events\",           \"description\": \"A dictionary whose keys (property names) are the indices of an event in the phase\",           \"type\": \"object\",           \"additionalProperties\": {             \"type\": \"array\",             \"items\": {               \"$ref\": \"#/definitions/LogEntry\"             }           }         }       },       \"additionalProperties\": false     }   } } ```   ### /dispensers/{guid}/state   ``` {   \"title\": \"DispenserState\",   \"type\": \"object\",   \"properties\": {     \"time\": {       \"title\": \"Time\",       \"default\": {         \"sec\": 0,         \"nanosec\": 0       },       \"allOf\": [         {           \"$ref\": \"#/definitions/Time\"         }       ]     },     \"guid\": {       \"title\": \"Guid\",       \"default\": \"\",       \"type\": \"string\"     },     \"mode\": {       \"title\": \"Mode\",       \"default\": 0,       \"minimum\": -2147483648,       \"maximum\": 2147483647,       \"type\": \"integer\"     },     \"request_guid_queue\": {       \"title\": \"Request Guid Queue\",       \"default\": [],       \"type\": \"array\",       \"items\": {         \"type\": \"string\"       }     },     \"seconds_remaining\": {       \"title\": \"Seconds Remaining\",       \"default\": 0,       \"type\": \"number\"     }   },   \"required\": [     \"time\",     \"guid\",     \"mode\",     \"request_guid_queue\",     \"seconds_remaining\"   ],   \"definitions\": {     \"Time\": {       \"title\": \"Time\",       \"type\": \"object\",       \"properties\": {         \"sec\": {           \"title\": \"Sec\",           \"default\": 0,           \"minimum\": -2147483648,           \"maximum\": 2147483647,           \"type\": \"integer\"         },         \"nanosec\": {           \"title\": \"Nanosec\",           \"default\": 0,           \"minimum\": 0,           \"maximum\": 4294967295,           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ]     }   } } ```   ### /dispensers/{guid}/health   ``` {   \"title\": \"DispenserHealth\",   \"type\": \"object\",   \"properties\": {     \"health_status\": {       \"title\": \"Health Status\",       \"maxLength\": 255,       \"nullable\": true,       \"type\": \"string\"     },     \"health_message\": {       \"title\": \"Health Message\",       \"nullable\": true,       \"type\": \"string\"     },     \"id_\": {       \"title\": \"Id \",       \"maxLength\": 255,       \"type\": \"string\"     }   },   \"required\": [     \"health_status\",     \"id_\"   ],   \"additionalProperties\": false } ```   ### /ingestors/{guid}/state   ``` {   \"title\": \"IngestorState\",   \"type\": \"object\",   \"properties\": {     \"time\": {       \"title\": \"Time\",       \"default\": {         \"sec\": 0,         \"nanosec\": 0       },       \"allOf\": [         {           \"$ref\": \"#/definitions/Time\"         }       ]     },     \"guid\": {       \"title\": \"Guid\",       \"default\": \"\",       \"type\": \"string\"     },     \"mode\": {       \"title\": \"Mode\",       \"default\": 0,       \"minimum\": -2147483648,       \"maximum\": 2147483647,       \"type\": \"integer\"     },     \"request_guid_queue\": {       \"title\": \"Request Guid Queue\",       \"default\": [],       \"type\": \"array\",       \"items\": {         \"type\": \"string\"       }     },     \"seconds_remaining\": {       \"title\": \"Seconds Remaining\",       \"default\": 0,       \"type\": \"number\"     }   },   \"required\": [     \"time\",     \"guid\",     \"mode\",     \"request_guid_queue\",     \"seconds_remaining\"   ],   \"definitions\": {     \"Time\": {       \"title\": \"Time\",       \"type\": \"object\",       \"properties\": {         \"sec\": {           \"title\": \"Sec\",           \"default\": 0,           \"minimum\": -2147483648,           \"maximum\": 2147483647,           \"type\": \"integer\"         },         \"nanosec\": {           \"title\": \"Nanosec\",           \"default\": 0,           \"minimum\": 0,           \"maximum\": 4294967295,           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ]     }   } } ```   ### /ingestors/{guid}/health   ``` {   \"title\": \"IngestorHealth\",   \"type\": \"object\",   \"properties\": {     \"health_status\": {       \"title\": \"Health Status\",       \"maxLength\": 255,       \"nullable\": true,       \"type\": \"string\"     },     \"health_message\": {       \"title\": \"Health Message\",       \"nullable\": true,       \"type\": \"string\"     },     \"id_\": {       \"title\": \"Id \",       \"maxLength\": 255,       \"type\": \"string\"     }   },   \"required\": [     \"health_status\",     \"id_\"   ],   \"additionalProperties\": false } ```   ### /fleets/{name}/state   ``` {   \"title\": \"FleetState\",   \"type\": \"object\",   \"properties\": {     \"name\": {       \"title\": \"Name\",       \"type\": \"string\"     },     \"robots\": {       \"title\": \"Robots\",       \"description\": \"A dictionary of the states of the robots that belong to this fleet\",       \"type\": \"object\",       \"additionalProperties\": {         \"$ref\": \"#/definitions/RobotState\"       }     }   },   \"definitions\": {     \"Status2\": {       \"title\": \"Status2\",       \"description\": \"An enumeration.\",       \"enum\": [         \"uninitialized\",         \"offline\",         \"shutdown\",         \"idle\",         \"charging\",         \"working\",         \"error\"       ]     },     \"Location2D\": {       \"title\": \"Location2D\",       \"type\": \"object\",       \"properties\": {         \"map\": {           \"title\": \"Map\",           \"type\": \"string\"         },         \"x\": {           \"title\": \"X\",           \"type\": \"number\"         },         \"y\": {           \"title\": \"Y\",           \"type\": \"number\"         },         \"yaw\": {           \"title\": \"Yaw\",           \"type\": \"number\"         }       },       \"required\": [         \"map\",         \"x\",         \"y\",         \"yaw\"       ]     },     \"Issue\": {       \"title\": \"Issue\",       \"type\": \"object\",       \"properties\": {         \"category\": {           \"title\": \"Category\",           \"description\": \"Category of the robot\'s issue\",           \"type\": \"string\"         },         \"detail\": {           \"title\": \"Detail\",           \"description\": \"Detailed information about the issue\",           \"anyOf\": [             {               \"type\": \"object\"             },             {               \"type\": \"array\",               \"items\": {}             },             {               \"type\": \"string\"             }           ]         }       }     },     \"RobotState\": {       \"title\": \"RobotState\",       \"type\": \"object\",       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"status\": {           \"description\": \"A simple token representing the status of the robot\",           \"allOf\": [             {               \"$ref\": \"#/definitions/Status2\"             }           ]         },         \"task_id\": {           \"title\": \"Task Id\",           \"description\": \"The ID of the task this robot is currently working on. Empty string if the robot is not working on a task.\",           \"type\": \"string\"         },         \"unix_millis_time\": {           \"title\": \"Unix Millis Time\",           \"type\": \"integer\"         },         \"location\": {           \"$ref\": \"#/definitions/Location2D\"         },         \"battery\": {           \"title\": \"Battery\",           \"description\": \"State of charge of the battery. Values range from 0.0 (depleted) to 1.0 (fully charged)\",           \"minimum\": 0.0,           \"maximum\": 1.0,           \"type\": \"number\"         },         \"issues\": {           \"title\": \"Issues\",           \"description\": \"A list of issues with the robot that operators need to address\",           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/Issue\"           }         }       }     }   } } ```   ### /fleets/{name}/log   ``` {   \"title\": \"FleetState\",   \"type\": \"object\",   \"properties\": {     \"name\": {       \"title\": \"Name\",       \"type\": \"string\"     },     \"log\": {       \"title\": \"Log\",       \"description\": \"Log for the overall fleet\",       \"type\": \"array\",       \"items\": {         \"$ref\": \"#/definitions/LogEntry\"       }     },     \"robots\": {       \"title\": \"Robots\",       \"description\": \"Dictionary of logs for the individual robots. The keys (property names) are the robot names.\",       \"type\": \"object\",       \"additionalProperties\": {         \"type\": \"array\",         \"items\": {           \"$ref\": \"#/definitions/LogEntry\"         }       }     }   },   \"definitions\": {     \"Tier\": {       \"title\": \"Tier\",       \"description\": \"An enumeration.\",       \"enum\": [         \"uninitialized\",         \"info\",         \"warning\",         \"error\"       ]     },     \"LogEntry\": {       \"title\": \"LogEntry\",       \"type\": \"object\",       \"properties\": {         \"seq\": {           \"title\": \"Seq\",           \"description\": \"Sequence number for this entry. Each entry has a unique sequence number which monotonically increase, until integer overflow causes a wrap around.\",           \"exclusiveMaximum\": 4294967296,           \"minimum\": 0,           \"type\": \"integer\"         },         \"tier\": {           \"description\": \"The importance level of the log entry\",           \"allOf\": [             {               \"$ref\": \"#/definitions/Tier\"             }           ]         },         \"unix_millis_time\": {           \"title\": \"Unix Millis Time\",           \"type\": \"integer\"         },         \"text\": {           \"title\": \"Text\",           \"description\": \"The text of the log entry\",           \"type\": \"string\"         }       },       \"required\": [         \"seq\",         \"tier\",         \"unix_millis_time\",         \"text\"       ]     }   } } ```
     * @summary Socket.io endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lambdaSocketIoGet(options?: any): AxiosPromise<any> {
      return localVarFp.lambdaSocketIoGet(options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   * Get the effective permissions of the current user
   * @summary Get Effective Permissions
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getEffectivePermissionsPermissionsGet(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getEffectivePermissionsPermissionsGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get the current rmf time in unix milliseconds
   * @summary Get Time
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getTimeTimeGet(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getTimeTimeGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get the currently logged in user
   * @summary Get User
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getUserUserGet(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getUserUserGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  # NOTE: This endpoint is here for documentation purposes only, this is _not_ a REST endpoint.  ## About This exposes a minimal pubsub system built on top of socket.io. It works similar to a normal socket.io endpoint, except that are 2 special rooms which control subscriptions.  ## Rooms ### subscribe Clients must send a message to this room to start receiving messages on other rooms. The message must be of the form:  ``` {     \"room\": \"<room_name>\" } ```  ### unsubscribe Clients can send a message to this room to stop receiving messages on other rooms. The message must be of the form:  ``` {     \"room\": \"<room_name>\" } ```              ### /alerts   ``` {   \"title\": \"Alert\",   \"description\": \"General alert that can be triggered by events.\",   \"type\": \"object\",   \"properties\": {     \"id\": {       \"title\": \"Id\",       \"maxLength\": 255,       \"type\": \"string\"     },     \"original_id\": {       \"title\": \"Original Id\",       \"maxLength\": 255,       \"type\": \"string\"     },     \"category\": {       \"title\": \"Category\",       \"description\": \"Default: default<br/>Task: task<br/>Fleet: fleet<br/>Robot: robot\",       \"maxLength\": 7,       \"type\": \"string\"     },     \"unix_millis_created_time\": {       \"title\": \"Unix Millis Created Time\",       \"minimum\": -9223372036854775808,       \"maximum\": 9223372036854775807,       \"type\": \"integer\"     },     \"acknowledged_by\": {       \"title\": \"Acknowledged By\",       \"maxLength\": 255,       \"nullable\": true,       \"type\": \"string\"     },     \"unix_millis_acknowledged_time\": {       \"title\": \"Unix Millis Acknowledged Time\",       \"minimum\": -9223372036854775808,       \"maximum\": 9223372036854775807,       \"nullable\": true,       \"type\": \"integer\"     }   },   \"required\": [     \"id\",     \"original_id\",     \"category\",     \"unix_millis_created_time\"   ],   \"additionalProperties\": false } ```   ### /beacons   ``` {   \"title\": \"BeaconState\",   \"type\": \"object\",   \"properties\": {     \"id\": {       \"title\": \"Id\",       \"maxLength\": 255,       \"type\": \"string\"     },     \"online\": {       \"title\": \"Online\",       \"type\": \"boolean\"     },     \"category\": {       \"title\": \"Category\",       \"maxLength\": 255,       \"nullable\": true,       \"type\": \"string\"     },     \"activated\": {       \"title\": \"Activated\",       \"type\": \"boolean\"     },     \"level\": {       \"title\": \"Level\",       \"maxLength\": 255,       \"nullable\": true,       \"type\": \"string\"     }   },   \"required\": [     \"id\",     \"online\",     \"activated\"   ],   \"additionalProperties\": false } ```   ### /building_map   ``` {   \"title\": \"BuildingMap\",   \"type\": \"object\",   \"properties\": {     \"name\": {       \"title\": \"Name\",       \"default\": \"\",       \"type\": \"string\"     },     \"levels\": {       \"title\": \"Levels\",       \"type\": \"array\",       \"items\": {         \"$ref\": \"#/definitions/Level\"       }     },     \"lifts\": {       \"title\": \"Lifts\",       \"default\": [],       \"type\": \"array\",       \"items\": {         \"$ref\": \"#/definitions/Lift\"       }     }   },   \"required\": [     \"name\",     \"levels\",     \"lifts\"   ],   \"definitions\": {     \"AffineImage\": {       \"title\": \"AffineImage\",       \"type\": \"object\",       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"default\": \"\",           \"type\": \"string\"         },         \"x_offset\": {           \"title\": \"X Offset\",           \"default\": 0,           \"type\": \"number\"         },         \"y_offset\": {           \"title\": \"Y Offset\",           \"default\": 0,           \"type\": \"number\"         },         \"yaw\": {           \"title\": \"Yaw\",           \"default\": 0,           \"type\": \"number\"         },         \"scale\": {           \"title\": \"Scale\",           \"default\": 0,           \"type\": \"number\"         },         \"encoding\": {           \"title\": \"Encoding\",           \"default\": \"\",           \"type\": \"string\"         },         \"data\": {           \"title\": \"Data\",           \"type\": \"string\"         }       },       \"required\": [         \"name\",         \"x_offset\",         \"y_offset\",         \"yaw\",         \"scale\",         \"encoding\",         \"data\"       ]     },     \"Place\": {       \"title\": \"Place\",       \"type\": \"object\",       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"default\": \"\",           \"type\": \"string\"         },         \"x\": {           \"title\": \"X\",           \"default\": 0,           \"type\": \"number\"         },         \"y\": {           \"title\": \"Y\",           \"default\": 0,           \"type\": \"number\"         },         \"yaw\": {           \"title\": \"Yaw\",           \"default\": 0,           \"type\": \"number\"         },         \"position_tolerance\": {           \"title\": \"Position Tolerance\",           \"default\": 0,           \"type\": \"number\"         },         \"yaw_tolerance\": {           \"title\": \"Yaw Tolerance\",           \"default\": 0,           \"type\": \"number\"         }       },       \"required\": [         \"name\",         \"x\",         \"y\",         \"yaw\",         \"position_tolerance\",         \"yaw_tolerance\"       ]     },     \"Door\": {       \"title\": \"Door\",       \"type\": \"object\",       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"default\": \"\",           \"type\": \"string\"         },         \"v1_x\": {           \"title\": \"V1 X\",           \"default\": 0,           \"type\": \"number\"         },         \"v1_y\": {           \"title\": \"V1 Y\",           \"default\": 0,           \"type\": \"number\"         },         \"v2_x\": {           \"title\": \"V2 X\",           \"default\": 0,           \"type\": \"number\"         },         \"v2_y\": {           \"title\": \"V2 Y\",           \"default\": 0,           \"type\": \"number\"         },         \"door_type\": {           \"title\": \"Door Type\",           \"default\": 0,           \"minimum\": 0,           \"maximum\": 255,           \"type\": \"integer\"         },         \"motion_range\": {           \"title\": \"Motion Range\",           \"default\": 0,           \"type\": \"number\"         },         \"motion_direction\": {           \"title\": \"Motion Direction\",           \"default\": 0,           \"minimum\": -2147483648,           \"maximum\": 2147483647,           \"type\": \"integer\"         }       },       \"required\": [         \"name\",         \"v1_x\",         \"v1_y\",         \"v2_x\",         \"v2_y\",         \"door_type\",         \"motion_range\",         \"motion_direction\"       ]     },     \"Param\": {       \"title\": \"Param\",       \"type\": \"object\",       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"default\": \"\",           \"type\": \"string\"         },         \"type\": {           \"title\": \"Type\",           \"default\": 0,           \"minimum\": 0,           \"maximum\": 4294967295,           \"type\": \"integer\"         },         \"value_int\": {           \"title\": \"Value Int\",           \"default\": 0,           \"minimum\": -2147483648,           \"maximum\": 2147483647,           \"type\": \"integer\"         },         \"value_float\": {           \"title\": \"Value Float\",           \"default\": 0,           \"type\": \"number\"         },         \"value_string\": {           \"title\": \"Value String\",           \"default\": \"\",           \"type\": \"string\"         },         \"value_bool\": {           \"title\": \"Value Bool\",           \"default\": false,           \"type\": \"boolean\"         }       },       \"required\": [         \"name\",         \"type\",         \"value_int\",         \"value_float\",         \"value_string\",         \"value_bool\"       ]     },     \"GraphNode\": {       \"title\": \"GraphNode\",       \"type\": \"object\",       \"properties\": {         \"x\": {           \"title\": \"X\",           \"default\": 0,           \"type\": \"number\"         },         \"y\": {           \"title\": \"Y\",           \"default\": 0,           \"type\": \"number\"         },         \"name\": {           \"title\": \"Name\",           \"default\": \"\",           \"type\": \"string\"         },         \"params\": {           \"title\": \"Params\",           \"default\": [],           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/Param\"           }         }       },       \"required\": [         \"x\",         \"y\",         \"name\",         \"params\"       ]     },     \"GraphEdge\": {       \"title\": \"GraphEdge\",       \"type\": \"object\",       \"properties\": {         \"v1_idx\": {           \"title\": \"V1 Idx\",           \"default\": 0,           \"minimum\": 0,           \"maximum\": 4294967295,           \"type\": \"integer\"         },         \"v2_idx\": {           \"title\": \"V2 Idx\",           \"default\": 0,           \"minimum\": 0,           \"maximum\": 4294967295,           \"type\": \"integer\"         },         \"params\": {           \"title\": \"Params\",           \"default\": [],           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/Param\"           }         },         \"edge_type\": {           \"title\": \"Edge Type\",           \"default\": 0,           \"minimum\": 0,           \"maximum\": 255,           \"type\": \"integer\"         }       },       \"required\": [         \"v1_idx\",         \"v2_idx\",         \"params\",         \"edge_type\"       ]     },     \"Graph\": {       \"title\": \"Graph\",       \"type\": \"object\",       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"default\": \"\",           \"type\": \"string\"         },         \"vertices\": {           \"title\": \"Vertices\",           \"default\": [],           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/GraphNode\"           }         },         \"edges\": {           \"title\": \"Edges\",           \"default\": [],           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/GraphEdge\"           }         },         \"params\": {           \"title\": \"Params\",           \"default\": [],           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/Param\"           }         }       },       \"required\": [         \"name\",         \"vertices\",         \"edges\",         \"params\"       ]     },     \"Level\": {       \"title\": \"Level\",       \"type\": \"object\",       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"default\": \"\",           \"type\": \"string\"         },         \"elevation\": {           \"title\": \"Elevation\",           \"default\": 0,           \"type\": \"number\"         },         \"images\": {           \"title\": \"Images\",           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/AffineImage\"           }         },         \"places\": {           \"title\": \"Places\",           \"default\": [],           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/Place\"           }         },         \"doors\": {           \"title\": \"Doors\",           \"default\": [],           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/Door\"           }         },         \"nav_graphs\": {           \"title\": \"Nav Graphs\",           \"default\": [],           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/Graph\"           }         },         \"wall_graph\": {           \"title\": \"Wall Graph\",           \"default\": {             \"name\": \"\",             \"vertices\": [],             \"edges\": [],             \"params\": []           },           \"allOf\": [             {               \"$ref\": \"#/definitions/Graph\"             }           ]         }       },       \"required\": [         \"name\",         \"elevation\",         \"images\",         \"places\",         \"doors\",         \"nav_graphs\",         \"wall_graph\"       ]     },     \"Lift\": {       \"title\": \"Lift\",       \"type\": \"object\",       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"default\": \"\",           \"type\": \"string\"         },         \"levels\": {           \"title\": \"Levels\",           \"default\": [],           \"type\": \"array\",           \"items\": {             \"type\": \"string\"           }         },         \"doors\": {           \"title\": \"Doors\",           \"default\": [],           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/Door\"           }         },         \"wall_graph\": {           \"title\": \"Wall Graph\",           \"default\": {             \"name\": \"\",             \"vertices\": [],             \"edges\": [],             \"params\": []           },           \"allOf\": [             {               \"$ref\": \"#/definitions/Graph\"             }           ]         },         \"ref_x\": {           \"title\": \"Ref X\",           \"default\": 0,           \"type\": \"number\"         },         \"ref_y\": {           \"title\": \"Ref Y\",           \"default\": 0,           \"type\": \"number\"         },         \"ref_yaw\": {           \"title\": \"Ref Yaw\",           \"default\": 0,           \"type\": \"number\"         },         \"width\": {           \"title\": \"Width\",           \"default\": 0,           \"type\": \"number\"         },         \"depth\": {           \"title\": \"Depth\",           \"default\": 0,           \"type\": \"number\"         }       },       \"required\": [         \"name\",         \"levels\",         \"doors\",         \"wall_graph\",         \"ref_x\",         \"ref_y\",         \"ref_yaw\",         \"width\",         \"depth\"       ]     }   } } ```   ### /doors/{door_name}/state   ``` {   \"title\": \"DoorState\",   \"type\": \"object\",   \"properties\": {     \"door_time\": {       \"title\": \"Door Time\",       \"default\": {         \"sec\": 0,         \"nanosec\": 0       },       \"allOf\": [         {           \"$ref\": \"#/definitions/Time\"         }       ]     },     \"door_name\": {       \"title\": \"Door Name\",       \"default\": \"\",       \"type\": \"string\"     },     \"current_mode\": {       \"title\": \"Current Mode\",       \"default\": {         \"value\": 0       },       \"allOf\": [         {           \"$ref\": \"#/definitions/DoorMode\"         }       ]     }   },   \"required\": [     \"door_time\",     \"door_name\",     \"current_mode\"   ],   \"definitions\": {     \"Time\": {       \"title\": \"Time\",       \"type\": \"object\",       \"properties\": {         \"sec\": {           \"title\": \"Sec\",           \"default\": 0,           \"minimum\": -2147483648,           \"maximum\": 2147483647,           \"type\": \"integer\"         },         \"nanosec\": {           \"title\": \"Nanosec\",           \"default\": 0,           \"minimum\": 0,           \"maximum\": 4294967295,           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ]     },     \"DoorMode\": {       \"title\": \"DoorMode\",       \"type\": \"object\",       \"properties\": {         \"value\": {           \"title\": \"Value\",           \"default\": 0,           \"minimum\": 0,           \"maximum\": 4294967295,           \"type\": \"integer\"         }       },       \"required\": [         \"value\"       ]     }   } } ```   ### /doors/{door_name}/health   ``` {   \"title\": \"DoorHealth\",   \"type\": \"object\",   \"properties\": {     \"health_status\": {       \"title\": \"Health Status\",       \"maxLength\": 255,       \"nullable\": true,       \"type\": \"string\"     },     \"health_message\": {       \"title\": \"Health Message\",       \"nullable\": true,       \"type\": \"string\"     },     \"id_\": {       \"title\": \"Id \",       \"maxLength\": 255,       \"type\": \"string\"     }   },   \"required\": [     \"health_status\",     \"id_\"   ],   \"additionalProperties\": false } ```   ### /lifts/{lift_name}/state   ``` {   \"title\": \"LiftState\",   \"type\": \"object\",   \"properties\": {     \"lift_time\": {       \"title\": \"Lift Time\",       \"default\": {         \"sec\": 0,         \"nanosec\": 0       },       \"allOf\": [         {           \"$ref\": \"#/definitions/Time\"         }       ]     },     \"lift_name\": {       \"title\": \"Lift Name\",       \"default\": \"\",       \"type\": \"string\"     },     \"available_floors\": {       \"title\": \"Available Floors\",       \"default\": [],       \"type\": \"array\",       \"items\": {         \"type\": \"string\"       }     },     \"current_floor\": {       \"title\": \"Current Floor\",       \"default\": \"\",       \"type\": \"string\"     },     \"destination_floor\": {       \"title\": \"Destination Floor\",       \"default\": \"\",       \"type\": \"string\"     },     \"door_state\": {       \"title\": \"Door State\",       \"default\": 0,       \"minimum\": 0,       \"maximum\": 255,       \"type\": \"integer\"     },     \"motion_state\": {       \"title\": \"Motion State\",       \"default\": 0,       \"minimum\": 0,       \"maximum\": 255,       \"type\": \"integer\"     },     \"available_modes\": {       \"title\": \"Available Modes\",       \"type\": \"array\",       \"items\": {         \"type\": \"integer\"       }     },     \"current_mode\": {       \"title\": \"Current Mode\",       \"default\": 0,       \"minimum\": 0,       \"maximum\": 255,       \"type\": \"integer\"     },     \"session_id\": {       \"title\": \"Session Id\",       \"default\": \"\",       \"type\": \"string\"     }   },   \"required\": [     \"lift_time\",     \"lift_name\",     \"available_floors\",     \"current_floor\",     \"destination_floor\",     \"door_state\",     \"motion_state\",     \"available_modes\",     \"current_mode\",     \"session_id\"   ],   \"definitions\": {     \"Time\": {       \"title\": \"Time\",       \"type\": \"object\",       \"properties\": {         \"sec\": {           \"title\": \"Sec\",           \"default\": 0,           \"minimum\": -2147483648,           \"maximum\": 2147483647,           \"type\": \"integer\"         },         \"nanosec\": {           \"title\": \"Nanosec\",           \"default\": 0,           \"minimum\": 0,           \"maximum\": 4294967295,           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ]     }   } } ```   ### /lifts/{lift_name}/health   ``` {   \"title\": \"LiftHealth\",   \"type\": \"object\",   \"properties\": {     \"health_status\": {       \"title\": \"Health Status\",       \"maxLength\": 255,       \"nullable\": true,       \"type\": \"string\"     },     \"health_message\": {       \"title\": \"Health Message\",       \"nullable\": true,       \"type\": \"string\"     },     \"id_\": {       \"title\": \"Id \",       \"maxLength\": 255,       \"type\": \"string\"     }   },   \"required\": [     \"health_status\",     \"id_\"   ],   \"additionalProperties\": false } ```   ### /tasks/{task_id}/state   ``` {   \"title\": \"TaskState\",   \"type\": \"object\",   \"properties\": {     \"booking\": {       \"$ref\": \"#/definitions/Booking\"     },     \"category\": {       \"$ref\": \"#/definitions/Category\"     },     \"detail\": {       \"$ref\": \"#/definitions/Detail\"     },     \"unix_millis_start_time\": {       \"title\": \"Unix Millis Start Time\",       \"type\": \"integer\"     },     \"unix_millis_finish_time\": {       \"title\": \"Unix Millis Finish Time\",       \"type\": \"integer\"     },     \"original_estimate_millis\": {       \"$ref\": \"#/definitions/EstimateMillis\"     },     \"estimate_millis\": {       \"$ref\": \"#/definitions/EstimateMillis\"     },     \"assigned_to\": {       \"title\": \"Assigned To\",       \"description\": \"Which agent (robot) is the task assigned to\",       \"allOf\": [         {           \"$ref\": \"#/definitions/AssignedTo\"         }       ]     },     \"status\": {       \"$ref\": \"#/definitions/Status\"     },     \"dispatch\": {       \"$ref\": \"#/definitions/Dispatch\"     },     \"phases\": {       \"title\": \"Phases\",       \"description\": \"A dictionary of the states of the phases of the task. The keys (property names) are phase IDs, which are integers.\",       \"type\": \"object\",       \"additionalProperties\": {         \"$ref\": \"#/definitions/Phase\"       }     },     \"completed\": {       \"title\": \"Completed\",       \"description\": \"An array of the IDs of completed phases of this task\",       \"type\": \"array\",       \"items\": {         \"$ref\": \"#/definitions/Id\"       }     },     \"active\": {       \"title\": \"Active\",       \"description\": \"The ID of the active phase for this task\",       \"allOf\": [         {           \"$ref\": \"#/definitions/Id\"         }       ]     },     \"pending\": {       \"title\": \"Pending\",       \"description\": \"An array of the pending phases of this task\",       \"type\": \"array\",       \"items\": {         \"$ref\": \"#/definitions/Id\"       }     },     \"interruptions\": {       \"title\": \"Interruptions\",       \"description\": \"A dictionary of interruptions that have been applied to this task. The keys (property names) are the unique token of the interruption request.\",       \"type\": \"object\",       \"additionalProperties\": {         \"$ref\": \"#/definitions/Interruption\"       }     },     \"cancellation\": {       \"title\": \"Cancellation\",       \"description\": \"If the task was cancelled, this will describe information about the request.\",       \"allOf\": [         {           \"$ref\": \"#/definitions/Cancellation\"         }       ]     },     \"killed\": {       \"title\": \"Killed\",       \"description\": \"If the task was killed, this will describe information about the request.\",       \"allOf\": [         {           \"$ref\": \"#/definitions/Killed\"         }       ]     }   },   \"required\": [     \"booking\"   ],   \"definitions\": {     \"Booking\": {       \"title\": \"Booking\",       \"type\": \"object\",       \"properties\": {         \"id\": {           \"title\": \"Id\",           \"description\": \"The unique identifier for this task\",           \"type\": \"string\"         },         \"unix_millis_earliest_start_time\": {           \"title\": \"Unix Millis Earliest Start Time\",           \"type\": \"integer\"         },         \"unix_millis_request_time\": {           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"priority\": {           \"title\": \"Priority\",           \"description\": \"Priority information about this task\",           \"anyOf\": [             {               \"type\": \"object\"             },             {               \"type\": \"string\"             }           ]         },         \"labels\": {           \"title\": \"Labels\",           \"description\": \"Information about how and why this task was booked\",           \"type\": \"array\",           \"items\": {             \"type\": \"string\"           }         },         \"requester\": {           \"title\": \"Requester\",           \"description\": \"(Optional) An identifier for the entity that requested this task\",           \"type\": \"string\"         }       },       \"required\": [         \"id\"       ]     },     \"Category\": {       \"title\": \"Category\",       \"description\": \"The category of this task or phase\",       \"type\": \"string\"     },     \"Detail\": {       \"title\": \"Detail\",       \"description\": \"Detailed information about a task, phase, or event\",       \"anyOf\": [         {           \"type\": \"object\"         },         {           \"type\": \"array\",           \"items\": {}         },         {           \"type\": \"string\"         }       ]     },     \"EstimateMillis\": {       \"title\": \"EstimateMillis\",       \"description\": \"An estimate, in milliseconds, of how long the subject will take to complete\",       \"minimum\": 0,       \"type\": \"integer\"     },     \"AssignedTo\": {       \"title\": \"AssignedTo\",       \"type\": \"object\",       \"properties\": {         \"group\": {           \"title\": \"Group\",           \"type\": \"string\"         },         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         }       },       \"required\": [         \"group\",         \"name\"       ]     },     \"Status\": {       \"title\": \"Status\",       \"description\": \"An enumeration.\",       \"enum\": [         \"uninitialized\",         \"blocked\",         \"error\",         \"failed\",         \"queued\",         \"standby\",         \"underway\",         \"delayed\",         \"skipped\",         \"canceled\",         \"killed\",         \"completed\"       ]     },     \"Status1\": {       \"title\": \"Status1\",       \"description\": \"An enumeration.\",       \"enum\": [         \"queued\",         \"selected\",         \"dispatched\",         \"failed_to_assign\",         \"canceled_in_flight\"       ]     },     \"Assignment\": {       \"title\": \"Assignment\",       \"type\": \"object\",       \"properties\": {         \"fleet_name\": {           \"title\": \"Fleet Name\",           \"type\": \"string\"         },         \"expected_robot_name\": {           \"title\": \"Expected Robot Name\",           \"type\": \"string\"         }       }     },     \"Error\": {       \"title\": \"Error\",       \"type\": \"object\",       \"properties\": {         \"code\": {           \"title\": \"Code\",           \"description\": \"A standard code for the kind of error that has occurred\",           \"minimum\": 0,           \"type\": \"integer\"         },         \"category\": {           \"title\": \"Category\",           \"description\": \"The category of the error\",           \"type\": \"string\"         },         \"detail\": {           \"title\": \"Detail\",           \"description\": \"Details about the error\",           \"type\": \"string\"         }       }     },     \"Dispatch\": {       \"title\": \"Dispatch\",       \"type\": \"object\",       \"properties\": {         \"status\": {           \"$ref\": \"#/definitions/Status1\"         },         \"assignment\": {           \"$ref\": \"#/definitions/Assignment\"         },         \"errors\": {           \"title\": \"Errors\",           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/Error\"           }         }       },       \"required\": [         \"status\"       ]     },     \"Id\": {       \"title\": \"Id\",       \"minimum\": 0,       \"type\": \"integer\"     },     \"EventState\": {       \"title\": \"EventState\",       \"type\": \"object\",       \"properties\": {         \"id\": {           \"$ref\": \"#/definitions/Id\"         },         \"status\": {           \"$ref\": \"#/definitions/Status\"         },         \"name\": {           \"title\": \"Name\",           \"description\": \"The brief name of the event\",           \"type\": \"string\"         },         \"detail\": {           \"title\": \"Detail\",           \"description\": \"Detailed information about the event\",           \"allOf\": [             {               \"$ref\": \"#/definitions/Detail\"             }           ]         },         \"deps\": {           \"title\": \"Deps\",           \"description\": \"This event may depend on other events. This array contains the IDs of those other event dependencies.\",           \"type\": \"array\",           \"items\": {             \"type\": \"integer\",             \"minimum\": 0           }         }       },       \"required\": [         \"id\"       ]     },     \"Undo\": {       \"title\": \"Undo\",       \"type\": \"object\",       \"properties\": {         \"unix_millis_request_time\": {           \"title\": \"Unix Millis Request Time\",           \"description\": \"The time that the undo skip request arrived\",           \"type\": \"integer\"         },         \"labels\": {           \"title\": \"Labels\",           \"description\": \"Labels to describe the undo skip request\",           \"type\": \"array\",           \"items\": {             \"type\": \"string\"           }         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ]     },     \"SkipPhaseRequest\": {       \"title\": \"SkipPhaseRequest\",       \"type\": \"object\",       \"properties\": {         \"unix_millis_request_time\": {           \"title\": \"Unix Millis Request Time\",           \"description\": \"The time that the skip request arrived\",           \"type\": \"integer\"         },         \"labels\": {           \"title\": \"Labels\",           \"description\": \"Labels to describe the purpose of the skip request\",           \"type\": \"array\",           \"items\": {             \"type\": \"string\"           }         },         \"undo\": {           \"title\": \"Undo\",           \"description\": \"Information about an undo skip request that applied to this request\",           \"allOf\": [             {               \"$ref\": \"#/definitions/Undo\"             }           ]         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ]     },     \"Phase\": {       \"title\": \"Phase\",       \"type\": \"object\",       \"properties\": {         \"id\": {           \"$ref\": \"#/definitions/Id\"         },         \"category\": {           \"$ref\": \"#/definitions/Category\"         },         \"detail\": {           \"$ref\": \"#/definitions/Detail\"         },         \"unix_millis_start_time\": {           \"title\": \"Unix Millis Start Time\",           \"type\": \"integer\"         },         \"unix_millis_finish_time\": {           \"title\": \"Unix Millis Finish Time\",           \"type\": \"integer\"         },         \"original_estimate_millis\": {           \"$ref\": \"#/definitions/EstimateMillis\"         },         \"estimate_millis\": {           \"$ref\": \"#/definitions/EstimateMillis\"         },         \"final_event_id\": {           \"$ref\": \"#/definitions/Id\"         },         \"events\": {           \"title\": \"Events\",           \"description\": \"A dictionary of events for this phase. The keys (property names) are the event IDs, which are integers.\",           \"type\": \"object\",           \"additionalProperties\": {             \"$ref\": \"#/definitions/EventState\"           }         },         \"skip_requests\": {           \"title\": \"Skip Requests\",           \"description\": \"Information about any skip requests that have been received\",           \"type\": \"object\",           \"additionalProperties\": {             \"$ref\": \"#/definitions/SkipPhaseRequest\"           }         }       },       \"required\": [         \"id\"       ]     },     \"ResumedBy\": {       \"title\": \"ResumedBy\",       \"type\": \"object\",       \"properties\": {         \"unix_millis_request_time\": {           \"title\": \"Unix Millis Request Time\",           \"description\": \"The time that the resume request arrived\",           \"type\": \"integer\"         },         \"labels\": {           \"title\": \"Labels\",           \"description\": \"Labels to describe the resume request\",           \"type\": \"array\",           \"items\": {             \"type\": \"string\"           }         }       },       \"required\": [         \"labels\"       ]     },     \"Interruption\": {       \"title\": \"Interruption\",       \"type\": \"object\",       \"properties\": {         \"unix_millis_request_time\": {           \"title\": \"Unix Millis Request Time\",           \"description\": \"The time that the interruption request arrived\",           \"type\": \"integer\"         },         \"labels\": {           \"title\": \"Labels\",           \"description\": \"Labels to describe the purpose of the interruption\",           \"type\": \"array\",           \"items\": {             \"type\": \"string\"           }         },         \"resumed_by\": {           \"title\": \"Resumed By\",           \"description\": \"Information about the resume request that ended this interruption. This field will be missing if the interruption is still active.\",           \"allOf\": [             {               \"$ref\": \"#/definitions/ResumedBy\"             }           ]         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ]     },     \"Cancellation\": {       \"title\": \"Cancellation\",       \"type\": \"object\",       \"properties\": {         \"unix_millis_request_time\": {           \"title\": \"Unix Millis Request Time\",           \"description\": \"The time that the cancellation request arrived\",           \"type\": \"integer\"         },         \"labels\": {           \"title\": \"Labels\",           \"description\": \"Labels to describe the cancel request\",           \"type\": \"array\",           \"items\": {             \"type\": \"string\"           }         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ]     },     \"Killed\": {       \"title\": \"Killed\",       \"type\": \"object\",       \"properties\": {         \"unix_millis_request_time\": {           \"title\": \"Unix Millis Request Time\",           \"description\": \"The time that the cancellation request arrived\",           \"type\": \"integer\"         },         \"labels\": {           \"title\": \"Labels\",           \"description\": \"Labels to describe the kill request\",           \"type\": \"array\",           \"items\": {             \"type\": \"string\"           }         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ]     }   } } ```   ### /tasks/{task_id}/log   ``` {   \"title\": \"TaskEventLog\",   \"type\": \"object\",   \"properties\": {     \"task_id\": {       \"title\": \"Task Id\",       \"type\": \"string\"     },     \"log\": {       \"title\": \"Log\",       \"description\": \"Log entries related to the overall task\",       \"type\": \"array\",       \"items\": {         \"$ref\": \"#/definitions/LogEntry\"       }     },     \"phases\": {       \"title\": \"Phases\",       \"description\": \"A dictionary whose keys (property names) are the indices of a phase\",       \"type\": \"object\",       \"additionalProperties\": {         \"$ref\": \"#/definitions/Phases\"       }     }   },   \"required\": [     \"task_id\"   ],   \"additionalProperties\": false,   \"definitions\": {     \"Tier\": {       \"title\": \"Tier\",       \"description\": \"An enumeration.\",       \"enum\": [         \"uninitialized\",         \"info\",         \"warning\",         \"error\"       ]     },     \"LogEntry\": {       \"title\": \"LogEntry\",       \"type\": \"object\",       \"properties\": {         \"seq\": {           \"title\": \"Seq\",           \"description\": \"Sequence number for this entry. Each entry has a unique sequence number which monotonically increase, until integer overflow causes a wrap around.\",           \"exclusiveMaximum\": 4294967296,           \"minimum\": 0,           \"type\": \"integer\"         },         \"tier\": {           \"description\": \"The importance level of the log entry\",           \"allOf\": [             {               \"$ref\": \"#/definitions/Tier\"             }           ]         },         \"unix_millis_time\": {           \"title\": \"Unix Millis Time\",           \"type\": \"integer\"         },         \"text\": {           \"title\": \"Text\",           \"description\": \"The text of the log entry\",           \"type\": \"string\"         }       },       \"required\": [         \"seq\",         \"tier\",         \"unix_millis_time\",         \"text\"       ]     },     \"Phases\": {       \"title\": \"Phases\",       \"type\": \"object\",       \"properties\": {         \"log\": {           \"title\": \"Log\",           \"description\": \"Log entries related to the overall phase\",           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/LogEntry\"           }         },         \"events\": {           \"title\": \"Events\",           \"description\": \"A dictionary whose keys (property names) are the indices of an event in the phase\",           \"type\": \"object\",           \"additionalProperties\": {             \"type\": \"array\",             \"items\": {               \"$ref\": \"#/definitions/LogEntry\"             }           }         }       },       \"additionalProperties\": false     }   } } ```   ### /dispensers/{guid}/state   ``` {   \"title\": \"DispenserState\",   \"type\": \"object\",   \"properties\": {     \"time\": {       \"title\": \"Time\",       \"default\": {         \"sec\": 0,         \"nanosec\": 0       },       \"allOf\": [         {           \"$ref\": \"#/definitions/Time\"         }       ]     },     \"guid\": {       \"title\": \"Guid\",       \"default\": \"\",       \"type\": \"string\"     },     \"mode\": {       \"title\": \"Mode\",       \"default\": 0,       \"minimum\": -2147483648,       \"maximum\": 2147483647,       \"type\": \"integer\"     },     \"request_guid_queue\": {       \"title\": \"Request Guid Queue\",       \"default\": [],       \"type\": \"array\",       \"items\": {         \"type\": \"string\"       }     },     \"seconds_remaining\": {       \"title\": \"Seconds Remaining\",       \"default\": 0,       \"type\": \"number\"     }   },   \"required\": [     \"time\",     \"guid\",     \"mode\",     \"request_guid_queue\",     \"seconds_remaining\"   ],   \"definitions\": {     \"Time\": {       \"title\": \"Time\",       \"type\": \"object\",       \"properties\": {         \"sec\": {           \"title\": \"Sec\",           \"default\": 0,           \"minimum\": -2147483648,           \"maximum\": 2147483647,           \"type\": \"integer\"         },         \"nanosec\": {           \"title\": \"Nanosec\",           \"default\": 0,           \"minimum\": 0,           \"maximum\": 4294967295,           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ]     }   } } ```   ### /dispensers/{guid}/health   ``` {   \"title\": \"DispenserHealth\",   \"type\": \"object\",   \"properties\": {     \"health_status\": {       \"title\": \"Health Status\",       \"maxLength\": 255,       \"nullable\": true,       \"type\": \"string\"     },     \"health_message\": {       \"title\": \"Health Message\",       \"nullable\": true,       \"type\": \"string\"     },     \"id_\": {       \"title\": \"Id \",       \"maxLength\": 255,       \"type\": \"string\"     }   },   \"required\": [     \"health_status\",     \"id_\"   ],   \"additionalProperties\": false } ```   ### /ingestors/{guid}/state   ``` {   \"title\": \"IngestorState\",   \"type\": \"object\",   \"properties\": {     \"time\": {       \"title\": \"Time\",       \"default\": {         \"sec\": 0,         \"nanosec\": 0       },       \"allOf\": [         {           \"$ref\": \"#/definitions/Time\"         }       ]     },     \"guid\": {       \"title\": \"Guid\",       \"default\": \"\",       \"type\": \"string\"     },     \"mode\": {       \"title\": \"Mode\",       \"default\": 0,       \"minimum\": -2147483648,       \"maximum\": 2147483647,       \"type\": \"integer\"     },     \"request_guid_queue\": {       \"title\": \"Request Guid Queue\",       \"default\": [],       \"type\": \"array\",       \"items\": {         \"type\": \"string\"       }     },     \"seconds_remaining\": {       \"title\": \"Seconds Remaining\",       \"default\": 0,       \"type\": \"number\"     }   },   \"required\": [     \"time\",     \"guid\",     \"mode\",     \"request_guid_queue\",     \"seconds_remaining\"   ],   \"definitions\": {     \"Time\": {       \"title\": \"Time\",       \"type\": \"object\",       \"properties\": {         \"sec\": {           \"title\": \"Sec\",           \"default\": 0,           \"minimum\": -2147483648,           \"maximum\": 2147483647,           \"type\": \"integer\"         },         \"nanosec\": {           \"title\": \"Nanosec\",           \"default\": 0,           \"minimum\": 0,           \"maximum\": 4294967295,           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ]     }   } } ```   ### /ingestors/{guid}/health   ``` {   \"title\": \"IngestorHealth\",   \"type\": \"object\",   \"properties\": {     \"health_status\": {       \"title\": \"Health Status\",       \"maxLength\": 255,       \"nullable\": true,       \"type\": \"string\"     },     \"health_message\": {       \"title\": \"Health Message\",       \"nullable\": true,       \"type\": \"string\"     },     \"id_\": {       \"title\": \"Id \",       \"maxLength\": 255,       \"type\": \"string\"     }   },   \"required\": [     \"health_status\",     \"id_\"   ],   \"additionalProperties\": false } ```   ### /fleets/{name}/state   ``` {   \"title\": \"FleetState\",   \"type\": \"object\",   \"properties\": {     \"name\": {       \"title\": \"Name\",       \"type\": \"string\"     },     \"robots\": {       \"title\": \"Robots\",       \"description\": \"A dictionary of the states of the robots that belong to this fleet\",       \"type\": \"object\",       \"additionalProperties\": {         \"$ref\": \"#/definitions/RobotState\"       }     }   },   \"definitions\": {     \"Status2\": {       \"title\": \"Status2\",       \"description\": \"An enumeration.\",       \"enum\": [         \"uninitialized\",         \"offline\",         \"shutdown\",         \"idle\",         \"charging\",         \"working\",         \"error\"       ]     },     \"Location2D\": {       \"title\": \"Location2D\",       \"type\": \"object\",       \"properties\": {         \"map\": {           \"title\": \"Map\",           \"type\": \"string\"         },         \"x\": {           \"title\": \"X\",           \"type\": \"number\"         },         \"y\": {           \"title\": \"Y\",           \"type\": \"number\"         },         \"yaw\": {           \"title\": \"Yaw\",           \"type\": \"number\"         }       },       \"required\": [         \"map\",         \"x\",         \"y\",         \"yaw\"       ]     },     \"Issue\": {       \"title\": \"Issue\",       \"type\": \"object\",       \"properties\": {         \"category\": {           \"title\": \"Category\",           \"description\": \"Category of the robot\'s issue\",           \"type\": \"string\"         },         \"detail\": {           \"title\": \"Detail\",           \"description\": \"Detailed information about the issue\",           \"anyOf\": [             {               \"type\": \"object\"             },             {               \"type\": \"array\",               \"items\": {}             },             {               \"type\": \"string\"             }           ]         }       }     },     \"RobotState\": {       \"title\": \"RobotState\",       \"type\": \"object\",       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"status\": {           \"description\": \"A simple token representing the status of the robot\",           \"allOf\": [             {               \"$ref\": \"#/definitions/Status2\"             }           ]         },         \"task_id\": {           \"title\": \"Task Id\",           \"description\": \"The ID of the task this robot is currently working on. Empty string if the robot is not working on a task.\",           \"type\": \"string\"         },         \"unix_millis_time\": {           \"title\": \"Unix Millis Time\",           \"type\": \"integer\"         },         \"location\": {           \"$ref\": \"#/definitions/Location2D\"         },         \"battery\": {           \"title\": \"Battery\",           \"description\": \"State of charge of the battery. Values range from 0.0 (depleted) to 1.0 (fully charged)\",           \"minimum\": 0.0,           \"maximum\": 1.0,           \"type\": \"number\"         },         \"issues\": {           \"title\": \"Issues\",           \"description\": \"A list of issues with the robot that operators need to address\",           \"type\": \"array\",           \"items\": {             \"$ref\": \"#/definitions/Issue\"           }         }       }     }   } } ```   ### /fleets/{name}/log   ``` {   \"title\": \"FleetState\",   \"type\": \"object\",   \"properties\": {     \"name\": {       \"title\": \"Name\",       \"type\": \"string\"     },     \"log\": {       \"title\": \"Log\",       \"description\": \"Log for the overall fleet\",       \"type\": \"array\",       \"items\": {         \"$ref\": \"#/definitions/LogEntry\"       }     },     \"robots\": {       \"title\": \"Robots\",       \"description\": \"Dictionary of logs for the individual robots. The keys (property names) are the robot names.\",       \"type\": \"object\",       \"additionalProperties\": {         \"type\": \"array\",         \"items\": {           \"$ref\": \"#/definitions/LogEntry\"         }       }     }   },   \"definitions\": {     \"Tier\": {       \"title\": \"Tier\",       \"description\": \"An enumeration.\",       \"enum\": [         \"uninitialized\",         \"info\",         \"warning\",         \"error\"       ]     },     \"LogEntry\": {       \"title\": \"LogEntry\",       \"type\": \"object\",       \"properties\": {         \"seq\": {           \"title\": \"Seq\",           \"description\": \"Sequence number for this entry. Each entry has a unique sequence number which monotonically increase, until integer overflow causes a wrap around.\",           \"exclusiveMaximum\": 4294967296,           \"minimum\": 0,           \"type\": \"integer\"         },         \"tier\": {           \"description\": \"The importance level of the log entry\",           \"allOf\": [             {               \"$ref\": \"#/definitions/Tier\"             }           ]         },         \"unix_millis_time\": {           \"title\": \"Unix Millis Time\",           \"type\": \"integer\"         },         \"text\": {           \"title\": \"Text\",           \"description\": \"The text of the log entry\",           \"type\": \"string\"         }       },       \"required\": [         \"seq\",         \"tier\",         \"unix_millis_time\",         \"text\"       ]     }   } } ```
   * @summary Socket.io endpoint
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public lambdaSocketIoGet(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .lambdaSocketIoGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * DispensersApi - axios parameter creator
 * @export
 */
export const DispensersApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Available in socket.io
     * @summary Get Dispenser Health
     * @param {string} guid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDispenserHealthDispensersGuidHealthGet: async (
      guid: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guid' is not null or undefined
      assertParamExists('getDispenserHealthDispensersGuidHealthGet', 'guid', guid);
      const localVarPath = `/dispensers/{guid}/health`.replace(
        `{${'guid'}}`,
        encodeURIComponent(String(guid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Available in socket.io
     * @summary Get Dispenser State
     * @param {string} guid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDispenserStateDispensersGuidStateGet: async (
      guid: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guid' is not null or undefined
      assertParamExists('getDispenserStateDispensersGuidStateGet', 'guid', guid);
      const localVarPath = `/dispensers/{guid}/state`.replace(
        `{${'guid'}}`,
        encodeURIComponent(String(guid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Dispensers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDispensersDispensersGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/dispensers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DispensersApi - functional programming interface
 * @export
 */
export const DispensersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DispensersApiAxiosParamCreator(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Dispenser Health
     * @param {string} guid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDispenserHealthDispensersGuidHealthGet(
      guid: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DispenserHealth>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getDispenserHealthDispensersGuidHealthGet(guid, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Available in socket.io
     * @summary Get Dispenser State
     * @param {string} guid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDispenserStateDispensersGuidStateGet(
      guid: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DispenserState>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getDispenserStateDispensersGuidStateGet(guid, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get Dispensers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDispensersDispensersGet(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dispenser>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDispensersDispensersGet(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * DispensersApi - factory interface
 * @export
 */
export const DispensersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DispensersApiFp(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Dispenser Health
     * @param {string} guid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDispenserHealthDispensersGuidHealthGet(
      guid: string,
      options?: any,
    ): AxiosPromise<DispenserHealth> {
      return localVarFp
        .getDispenserHealthDispensersGuidHealthGet(guid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Available in socket.io
     * @summary Get Dispenser State
     * @param {string} guid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDispenserStateDispensersGuidStateGet(
      guid: string,
      options?: any,
    ): AxiosPromise<DispenserState> {
      return localVarFp
        .getDispenserStateDispensersGuidStateGet(guid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Dispensers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDispensersDispensersGet(options?: any): AxiosPromise<Array<Dispenser>> {
      return localVarFp
        .getDispensersDispensersGet(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * DispensersApi - object-oriented interface
 * @export
 * @class DispensersApi
 * @extends {BaseAPI}
 */
export class DispensersApi extends BaseAPI {
  /**
   * Available in socket.io
   * @summary Get Dispenser Health
   * @param {string} guid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DispensersApi
   */
  public getDispenserHealthDispensersGuidHealthGet(guid: string, options?: AxiosRequestConfig) {
    return DispensersApiFp(this.configuration)
      .getDispenserHealthDispensersGuidHealthGet(guid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Available in socket.io
   * @summary Get Dispenser State
   * @param {string} guid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DispensersApi
   */
  public getDispenserStateDispensersGuidStateGet(guid: string, options?: AxiosRequestConfig) {
    return DispensersApiFp(this.configuration)
      .getDispenserStateDispensersGuidStateGet(guid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Dispensers
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DispensersApi
   */
  public getDispensersDispensersGet(options?: AxiosRequestConfig) {
    return DispensersApiFp(this.configuration)
      .getDispensersDispensersGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * DoorsApi - axios parameter creator
 * @export
 */
export const DoorsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Available in socket.io
     * @summary Get Door Health
     * @param {string} doorName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDoorHealthDoorsDoorNameHealthGet: async (
      doorName: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'doorName' is not null or undefined
      assertParamExists('getDoorHealthDoorsDoorNameHealthGet', 'doorName', doorName);
      const localVarPath = `/doors/{door_name}/health`.replace(
        `{${'door_name'}}`,
        encodeURIComponent(String(doorName)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Available in socket.io
     * @summary Get Door State
     * @param {string} doorName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDoorStateDoorsDoorNameStateGet: async (
      doorName: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'doorName' is not null or undefined
      assertParamExists('getDoorStateDoorsDoorNameStateGet', 'doorName', doorName);
      const localVarPath = `/doors/{door_name}/state`.replace(
        `{${'door_name'}}`,
        encodeURIComponent(String(doorName)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Doors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDoorsDoorsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/doors`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post Door Request
     * @param {string} doorName
     * @param {DoorRequest} doorRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postDoorRequestDoorsDoorNameRequestPost: async (
      doorName: string,
      doorRequest: DoorRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'doorName' is not null or undefined
      assertParamExists('postDoorRequestDoorsDoorNameRequestPost', 'doorName', doorName);
      // verify required parameter 'doorRequest' is not null or undefined
      assertParamExists('postDoorRequestDoorsDoorNameRequestPost', 'doorRequest', doorRequest);
      const localVarPath = `/doors/{door_name}/request`.replace(
        `{${'door_name'}}`,
        encodeURIComponent(String(doorName)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        doorRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DoorsApi - functional programming interface
 * @export
 */
export const DoorsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DoorsApiAxiosParamCreator(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Door Health
     * @param {string} doorName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDoorHealthDoorsDoorNameHealthGet(
      doorName: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DoorHealth>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDoorHealthDoorsDoorNameHealthGet(
        doorName,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Available in socket.io
     * @summary Get Door State
     * @param {string} doorName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDoorStateDoorsDoorNameStateGet(
      doorName: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DoorState>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDoorStateDoorsDoorNameStateGet(
        doorName,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get Doors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDoorsDoorsGet(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Door>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDoorsDoorsGet(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Post Door Request
     * @param {string} doorName
     * @param {DoorRequest} doorRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postDoorRequestDoorsDoorNameRequestPost(
      doorName: string,
      doorRequest: DoorRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postDoorRequestDoorsDoorNameRequestPost(
          doorName,
          doorRequest,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * DoorsApi - factory interface
 * @export
 */
export const DoorsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DoorsApiFp(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Door Health
     * @param {string} doorName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDoorHealthDoorsDoorNameHealthGet(doorName: string, options?: any): AxiosPromise<DoorHealth> {
      return localVarFp
        .getDoorHealthDoorsDoorNameHealthGet(doorName, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Available in socket.io
     * @summary Get Door State
     * @param {string} doorName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDoorStateDoorsDoorNameStateGet(doorName: string, options?: any): AxiosPromise<DoorState> {
      return localVarFp
        .getDoorStateDoorsDoorNameStateGet(doorName, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Doors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDoorsDoorsGet(options?: any): AxiosPromise<Array<Door>> {
      return localVarFp.getDoorsDoorsGet(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Post Door Request
     * @param {string} doorName
     * @param {DoorRequest} doorRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postDoorRequestDoorsDoorNameRequestPost(
      doorName: string,
      doorRequest: DoorRequest,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .postDoorRequestDoorsDoorNameRequestPost(doorName, doorRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * DoorsApi - object-oriented interface
 * @export
 * @class DoorsApi
 * @extends {BaseAPI}
 */
export class DoorsApi extends BaseAPI {
  /**
   * Available in socket.io
   * @summary Get Door Health
   * @param {string} doorName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DoorsApi
   */
  public getDoorHealthDoorsDoorNameHealthGet(doorName: string, options?: AxiosRequestConfig) {
    return DoorsApiFp(this.configuration)
      .getDoorHealthDoorsDoorNameHealthGet(doorName, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Available in socket.io
   * @summary Get Door State
   * @param {string} doorName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DoorsApi
   */
  public getDoorStateDoorsDoorNameStateGet(doorName: string, options?: AxiosRequestConfig) {
    return DoorsApiFp(this.configuration)
      .getDoorStateDoorsDoorNameStateGet(doorName, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Doors
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DoorsApi
   */
  public getDoorsDoorsGet(options?: AxiosRequestConfig) {
    return DoorsApiFp(this.configuration)
      .getDoorsDoorsGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Post Door Request
   * @param {string} doorName
   * @param {DoorRequest} doorRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DoorsApi
   */
  public postDoorRequestDoorsDoorNameRequestPost(
    doorName: string,
    doorRequest: DoorRequest,
    options?: AxiosRequestConfig,
  ) {
    return DoorsApiFp(this.configuration)
      .postDoorRequestDoorsDoorNameRequestPost(doorName, doorRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * FleetsApi - axios parameter creator
 * @export
 */
export const FleetsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Available in socket.io
     * @summary Get Fleet Log
     * @param {string} name
     * @param {string} [between]          The period of time to fetch, in unix millis.          This can be either a comma separated string or a string prefixed with \&#39;-\&#39; to fetch the last X millis.          Example:             \&quot;1000,2000\&quot; - Fetches logs between unix millis 1000 and 2000.             \&quot;-60000\&quot; - Fetches logs in the last minute.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFleetLogFleetsNameLogGet: async (
      name: string,
      between?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getFleetLogFleetsNameLogGet', 'name', name);
      const localVarPath = `/fleets/{name}/log`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (between !== undefined) {
        localVarQueryParameter['between'] = between;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Available in socket.io
     * @summary Get Fleet State
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFleetStateFleetsNameStateGet: async (
      name: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getFleetStateFleetsNameStateGet', 'name', name);
      const localVarPath = `/fleets/{name}/state`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Fleets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFleetsFleetsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/fleets`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FleetsApi - functional programming interface
 * @export
 */
export const FleetsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FleetsApiAxiosParamCreator(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Fleet Log
     * @param {string} name
     * @param {string} [between]          The period of time to fetch, in unix millis.          This can be either a comma separated string or a string prefixed with \&#39;-\&#39; to fetch the last X millis.          Example:             \&quot;1000,2000\&quot; - Fetches logs between unix millis 1000 and 2000.             \&quot;-60000\&quot; - Fetches logs in the last minute.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFleetLogFleetsNameLogGet(
      name: string,
      between?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ApiServerModelsRmfApiFleetLogFleetState>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFleetLogFleetsNameLogGet(
        name,
        between,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Available in socket.io
     * @summary Get Fleet State
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFleetStateFleetsNameStateGet(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ApiServerModelsRmfApiFleetStateFleetState>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFleetStateFleetsNameStateGet(
        name,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get Fleets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFleetsFleetsGet(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<ApiServerModelsRmfApiFleetStateFleetState>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFleetsFleetsGet(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * FleetsApi - factory interface
 * @export
 */
export const FleetsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = FleetsApiFp(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Fleet Log
     * @param {string} name
     * @param {string} [between]          The period of time to fetch, in unix millis.          This can be either a comma separated string or a string prefixed with \&#39;-\&#39; to fetch the last X millis.          Example:             \&quot;1000,2000\&quot; - Fetches logs between unix millis 1000 and 2000.             \&quot;-60000\&quot; - Fetches logs in the last minute.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFleetLogFleetsNameLogGet(
      name: string,
      between?: string,
      options?: any,
    ): AxiosPromise<ApiServerModelsRmfApiFleetLogFleetState> {
      return localVarFp
        .getFleetLogFleetsNameLogGet(name, between, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Available in socket.io
     * @summary Get Fleet State
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFleetStateFleetsNameStateGet(
      name: string,
      options?: any,
    ): AxiosPromise<ApiServerModelsRmfApiFleetStateFleetState> {
      return localVarFp
        .getFleetStateFleetsNameStateGet(name, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Fleets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFleetsFleetsGet(
      options?: any,
    ): AxiosPromise<Array<ApiServerModelsRmfApiFleetStateFleetState>> {
      return localVarFp.getFleetsFleetsGet(options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * FleetsApi - object-oriented interface
 * @export
 * @class FleetsApi
 * @extends {BaseAPI}
 */
export class FleetsApi extends BaseAPI {
  /**
   * Available in socket.io
   * @summary Get Fleet Log
   * @param {string} name
   * @param {string} [between]          The period of time to fetch, in unix millis.          This can be either a comma separated string or a string prefixed with \&#39;-\&#39; to fetch the last X millis.          Example:             \&quot;1000,2000\&quot; - Fetches logs between unix millis 1000 and 2000.             \&quot;-60000\&quot; - Fetches logs in the last minute.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetsApi
   */
  public getFleetLogFleetsNameLogGet(name: string, between?: string, options?: AxiosRequestConfig) {
    return FleetsApiFp(this.configuration)
      .getFleetLogFleetsNameLogGet(name, between, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Available in socket.io
   * @summary Get Fleet State
   * @param {string} name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetsApi
   */
  public getFleetStateFleetsNameStateGet(name: string, options?: AxiosRequestConfig) {
    return FleetsApiFp(this.configuration)
      .getFleetStateFleetsNameStateGet(name, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Fleets
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetsApi
   */
  public getFleetsFleetsGet(options?: AxiosRequestConfig) {
    return FleetsApiFp(this.configuration)
      .getFleetsFleetsGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * IngestorsApi - axios parameter creator
 * @export
 */
export const IngestorsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Available in socket.io
     * @summary Get Ingestor Health
     * @param {string} guid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIngestorHealthIngestorsGuidHealthGet: async (
      guid: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guid' is not null or undefined
      assertParamExists('getIngestorHealthIngestorsGuidHealthGet', 'guid', guid);
      const localVarPath = `/ingestors/{guid}/health`.replace(
        `{${'guid'}}`,
        encodeURIComponent(String(guid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Available in socket.io
     * @summary Get Ingestor State
     * @param {string} guid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIngestorStateIngestorsGuidStateGet: async (
      guid: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guid' is not null or undefined
      assertParamExists('getIngestorStateIngestorsGuidStateGet', 'guid', guid);
      const localVarPath = `/ingestors/{guid}/state`.replace(
        `{${'guid'}}`,
        encodeURIComponent(String(guid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Ingestors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIngestorsIngestorsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ingestors`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * IngestorsApi - functional programming interface
 * @export
 */
export const IngestorsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = IngestorsApiAxiosParamCreator(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Ingestor Health
     * @param {string} guid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getIngestorHealthIngestorsGuidHealthGet(
      guid: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IngestorHealth>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getIngestorHealthIngestorsGuidHealthGet(guid, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Available in socket.io
     * @summary Get Ingestor State
     * @param {string} guid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getIngestorStateIngestorsGuidStateGet(
      guid: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IngestorState>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getIngestorStateIngestorsGuidStateGet(guid, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get Ingestors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getIngestorsIngestorsGet(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Ingestor>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getIngestorsIngestorsGet(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * IngestorsApi - factory interface
 * @export
 */
export const IngestorsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = IngestorsApiFp(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Ingestor Health
     * @param {string} guid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIngestorHealthIngestorsGuidHealthGet(
      guid: string,
      options?: any,
    ): AxiosPromise<IngestorHealth> {
      return localVarFp
        .getIngestorHealthIngestorsGuidHealthGet(guid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Available in socket.io
     * @summary Get Ingestor State
     * @param {string} guid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIngestorStateIngestorsGuidStateGet(
      guid: string,
      options?: any,
    ): AxiosPromise<IngestorState> {
      return localVarFp
        .getIngestorStateIngestorsGuidStateGet(guid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Ingestors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIngestorsIngestorsGet(options?: any): AxiosPromise<Array<Ingestor>> {
      return localVarFp
        .getIngestorsIngestorsGet(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * IngestorsApi - object-oriented interface
 * @export
 * @class IngestorsApi
 * @extends {BaseAPI}
 */
export class IngestorsApi extends BaseAPI {
  /**
   * Available in socket.io
   * @summary Get Ingestor Health
   * @param {string} guid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IngestorsApi
   */
  public getIngestorHealthIngestorsGuidHealthGet(guid: string, options?: AxiosRequestConfig) {
    return IngestorsApiFp(this.configuration)
      .getIngestorHealthIngestorsGuidHealthGet(guid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Available in socket.io
   * @summary Get Ingestor State
   * @param {string} guid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IngestorsApi
   */
  public getIngestorStateIngestorsGuidStateGet(guid: string, options?: AxiosRequestConfig) {
    return IngestorsApiFp(this.configuration)
      .getIngestorStateIngestorsGuidStateGet(guid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Ingestors
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IngestorsApi
   */
  public getIngestorsIngestorsGet(options?: AxiosRequestConfig) {
    return IngestorsApiFp(this.configuration)
      .getIngestorsIngestorsGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * LiftsApi - axios parameter creator
 * @export
 */
export const LiftsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Available in socket.io
     * @summary Get Lift Health
     * @param {string} liftName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLiftHealthLiftsLiftNameHealthGet: async (
      liftName: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'liftName' is not null or undefined
      assertParamExists('getLiftHealthLiftsLiftNameHealthGet', 'liftName', liftName);
      const localVarPath = `/lifts/{lift_name}/health`.replace(
        `{${'lift_name'}}`,
        encodeURIComponent(String(liftName)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Available in socket.io
     * @summary Get Lift State
     * @param {string} liftName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLiftStateLiftsLiftNameStateGet: async (
      liftName: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'liftName' is not null or undefined
      assertParamExists('getLiftStateLiftsLiftNameStateGet', 'liftName', liftName);
      const localVarPath = `/lifts/{lift_name}/state`.replace(
        `{${'lift_name'}}`,
        encodeURIComponent(String(liftName)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Lifts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLiftsLiftsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/lifts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary  Post Lift Request
     * @param {string} liftName
     * @param {LiftRequest} liftRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postLiftRequestLiftsLiftNameRequestPost: async (
      liftName: string,
      liftRequest: LiftRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'liftName' is not null or undefined
      assertParamExists('postLiftRequestLiftsLiftNameRequestPost', 'liftName', liftName);
      // verify required parameter 'liftRequest' is not null or undefined
      assertParamExists('postLiftRequestLiftsLiftNameRequestPost', 'liftRequest', liftRequest);
      const localVarPath = `/lifts/{lift_name}/request`.replace(
        `{${'lift_name'}}`,
        encodeURIComponent(String(liftName)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        liftRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LiftsApi - functional programming interface
 * @export
 */
export const LiftsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = LiftsApiAxiosParamCreator(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Lift Health
     * @param {string} liftName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLiftHealthLiftsLiftNameHealthGet(
      liftName: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiftHealth>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLiftHealthLiftsLiftNameHealthGet(
        liftName,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Available in socket.io
     * @summary Get Lift State
     * @param {string} liftName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLiftStateLiftsLiftNameStateGet(
      liftName: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiftState>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLiftStateLiftsLiftNameStateGet(
        liftName,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get Lifts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLiftsLiftsGet(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Lift>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLiftsLiftsGet(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary  Post Lift Request
     * @param {string} liftName
     * @param {LiftRequest} liftRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postLiftRequestLiftsLiftNameRequestPost(
      liftName: string,
      liftRequest: LiftRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postLiftRequestLiftsLiftNameRequestPost(
          liftName,
          liftRequest,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * LiftsApi - factory interface
 * @export
 */
export const LiftsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = LiftsApiFp(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Lift Health
     * @param {string} liftName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLiftHealthLiftsLiftNameHealthGet(liftName: string, options?: any): AxiosPromise<LiftHealth> {
      return localVarFp
        .getLiftHealthLiftsLiftNameHealthGet(liftName, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Available in socket.io
     * @summary Get Lift State
     * @param {string} liftName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLiftStateLiftsLiftNameStateGet(liftName: string, options?: any): AxiosPromise<LiftState> {
      return localVarFp
        .getLiftStateLiftsLiftNameStateGet(liftName, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Lifts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLiftsLiftsGet(options?: any): AxiosPromise<Array<Lift>> {
      return localVarFp.getLiftsLiftsGet(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary  Post Lift Request
     * @param {string} liftName
     * @param {LiftRequest} liftRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postLiftRequestLiftsLiftNameRequestPost(
      liftName: string,
      liftRequest: LiftRequest,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .postLiftRequestLiftsLiftNameRequestPost(liftName, liftRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * LiftsApi - object-oriented interface
 * @export
 * @class LiftsApi
 * @extends {BaseAPI}
 */
export class LiftsApi extends BaseAPI {
  /**
   * Available in socket.io
   * @summary Get Lift Health
   * @param {string} liftName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LiftsApi
   */
  public getLiftHealthLiftsLiftNameHealthGet(liftName: string, options?: AxiosRequestConfig) {
    return LiftsApiFp(this.configuration)
      .getLiftHealthLiftsLiftNameHealthGet(liftName, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Available in socket.io
   * @summary Get Lift State
   * @param {string} liftName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LiftsApi
   */
  public getLiftStateLiftsLiftNameStateGet(liftName: string, options?: AxiosRequestConfig) {
    return LiftsApiFp(this.configuration)
      .getLiftStateLiftsLiftNameStateGet(liftName, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Lifts
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LiftsApi
   */
  public getLiftsLiftsGet(options?: AxiosRequestConfig) {
    return LiftsApiFp(this.configuration)
      .getLiftsLiftsGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary  Post Lift Request
   * @param {string} liftName
   * @param {LiftRequest} liftRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LiftsApi
   */
  public postLiftRequestLiftsLiftNameRequestPost(
    liftName: string,
    liftRequest: LiftRequest,
    options?: AxiosRequestConfig,
  ) {
    return LiftsApiFp(this.configuration)
      .postLiftRequestLiftsLiftNameRequestPost(liftName, liftRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TasksApi - axios parameter creator
 * @export
 */
export const TasksApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Del Scheduled Tasks Event
     * @param {number} taskId
     * @param {string} eventDate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    delScheduledTasksEventScheduledTasksTaskIdClearPut: async (
      taskId: number,
      eventDate: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskId' is not null or undefined
      assertParamExists('delScheduledTasksEventScheduledTasksTaskIdClearPut', 'taskId', taskId);
      // verify required parameter 'eventDate' is not null or undefined
      assertParamExists(
        'delScheduledTasksEventScheduledTasksTaskIdClearPut',
        'eventDate',
        eventDate,
      );
      const localVarPath = `/scheduled_tasks/{task_id}/clear`.replace(
        `{${'task_id'}}`,
        encodeURIComponent(String(taskId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (eventDate !== undefined) {
        localVarQueryParameter['event_date'] =
          (eventDate as any) instanceof Date ? (eventDate as any).toISOString() : eventDate;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Del Scheduled Tasks
     * @param {number} taskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    delScheduledTasksScheduledTasksTaskIdDelete: async (
      taskId: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskId' is not null or undefined
      assertParamExists('delScheduledTasksScheduledTasksTaskIdDelete', 'taskId', taskId);
      const localVarPath = `/scheduled_tasks/{task_id}`.replace(
        `{${'task_id'}}`,
        encodeURIComponent(String(taskId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete Favorite Task
     * @param {string} favoriteTaskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFavoriteTaskFavoriteTasksFavoriteTaskIdDelete: async (
      favoriteTaskId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'favoriteTaskId' is not null or undefined
      assertParamExists(
        'deleteFavoriteTaskFavoriteTasksFavoriteTaskIdDelete',
        'favoriteTaskId',
        favoriteTaskId,
      );
      const localVarPath = `/favorite_tasks/{favorite_task_id}`.replace(
        `{${'favorite_task_id'}}`,
        encodeURIComponent(String(favoriteTaskId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Favorites Tasks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFavoritesTasksFavoriteTasksGet: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/favorite_tasks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Scheduled Task
     * @param {number} taskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getScheduledTaskScheduledTasksTaskIdGet: async (
      taskId: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskId' is not null or undefined
      assertParamExists('getScheduledTaskScheduledTasksTaskIdGet', 'taskId', taskId);
      const localVarPath = `/scheduled_tasks/{task_id}`.replace(
        `{${'task_id'}}`,
        encodeURIComponent(String(taskId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Scheduled Tasks
     * @param {string} startBefore Only return scheduled tasks that start before given timestamp
     * @param {string} untilAfter Only return scheduled tasks that stop after given timestamp
     * @param {number} [limit] defaults to 100
     * @param {number} [offset] defaults to 0
     * @param {string} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getScheduledTasksScheduledTasksGet: async (
      startBefore: string,
      untilAfter: string,
      limit?: number,
      offset?: number,
      orderBy?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'startBefore' is not null or undefined
      assertParamExists('getScheduledTasksScheduledTasksGet', 'startBefore', startBefore);
      // verify required parameter 'untilAfter' is not null or undefined
      assertParamExists('getScheduledTasksScheduledTasksGet', 'untilAfter', untilAfter);
      const localVarPath = `/scheduled_tasks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (startBefore !== undefined) {
        localVarQueryParameter['start_before'] =
          (startBefore as any) instanceof Date ? (startBefore as any).toISOString() : startBefore;
      }

      if (untilAfter !== undefined) {
        localVarQueryParameter['until_after'] =
          (untilAfter as any) instanceof Date ? (untilAfter as any).toISOString() : untilAfter;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['order_by'] = orderBy;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Available in socket.io
     * @summary Get Task Log
     * @param {string} taskId task_id
     * @param {string} [between]          The period of time to fetch, in unix millis.          This can be either a comma separated string or a string prefixed with \&#39;-\&#39; to fetch the last X millis.          Example:             \&quot;1000,2000\&quot; - Fetches logs between unix millis 1000 and 2000.             \&quot;-60000\&quot; - Fetches logs in the last minute.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskLogTasksTaskIdLogGet: async (
      taskId: string,
      between?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskId' is not null or undefined
      assertParamExists('getTaskLogTasksTaskIdLogGet', 'taskId', taskId);
      const localVarPath = `/tasks/{task_id}/log`.replace(
        `{${'task_id'}}`,
        encodeURIComponent(String(taskId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (between !== undefined) {
        localVarQueryParameter['between'] = between;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Available in socket.io
     * @summary Get Task State
     * @param {string} taskId task_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskStateTasksTaskIdStateGet: async (
      taskId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskId' is not null or undefined
      assertParamExists('getTaskStateTasksTaskIdStateGet', 'taskId', taskId);
      const localVarPath = `/tasks/{task_id}/state`.replace(
        `{${'task_id'}}`,
        encodeURIComponent(String(taskId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post Activity Discovery
     * @param {ActivityDiscoveryRequest} activityDiscoveryRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postActivityDiscoveryTasksActivityDiscoveryPost: async (
      activityDiscoveryRequest: ActivityDiscoveryRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'activityDiscoveryRequest' is not null or undefined
      assertParamExists(
        'postActivityDiscoveryTasksActivityDiscoveryPost',
        'activityDiscoveryRequest',
        activityDiscoveryRequest,
      );
      const localVarPath = `/tasks/activity_discovery`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        activityDiscoveryRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post Cancel Task
     * @param {CancelTaskRequest} cancelTaskRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postCancelTaskTasksCancelTaskPost: async (
      cancelTaskRequest: CancelTaskRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'cancelTaskRequest' is not null or undefined
      assertParamExists(
        'postCancelTaskTasksCancelTaskPost',
        'cancelTaskRequest',
        cancelTaskRequest,
      );
      const localVarPath = `/tasks/cancel_task`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        cancelTaskRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post Dispatch Task
     * @param {DispatchTaskRequest} dispatchTaskRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postDispatchTaskTasksDispatchTaskPost: async (
      dispatchTaskRequest: DispatchTaskRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'dispatchTaskRequest' is not null or undefined
      assertParamExists(
        'postDispatchTaskTasksDispatchTaskPost',
        'dispatchTaskRequest',
        dispatchTaskRequest,
      );
      const localVarPath = `/tasks/dispatch_task`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        dispatchTaskRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post Favorite Task
     * @param {TaskFavoritePydantic} taskFavoritePydantic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postFavoriteTaskFavoriteTasksPost: async (
      taskFavoritePydantic: TaskFavoritePydantic,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskFavoritePydantic' is not null or undefined
      assertParamExists(
        'postFavoriteTaskFavoriteTasksPost',
        'taskFavoritePydantic',
        taskFavoritePydantic,
      );
      const localVarPath = `/favorite_tasks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        taskFavoritePydantic,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post Interrupt Task
     * @param {TaskInterruptionRequest} taskInterruptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postInterruptTaskTasksInterruptTaskPost: async (
      taskInterruptionRequest: TaskInterruptionRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskInterruptionRequest' is not null or undefined
      assertParamExists(
        'postInterruptTaskTasksInterruptTaskPost',
        'taskInterruptionRequest',
        taskInterruptionRequest,
      );
      const localVarPath = `/tasks/interrupt_task`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        taskInterruptionRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post Kill Task
     * @param {TaskKillRequest} taskKillRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postKillTaskTasksKillTaskPost: async (
      taskKillRequest: TaskKillRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskKillRequest' is not null or undefined
      assertParamExists('postKillTaskTasksKillTaskPost', 'taskKillRequest', taskKillRequest);
      const localVarPath = `/tasks/kill_task`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        taskKillRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post Resume Task
     * @param {TaskResumeRequest} taskResumeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postResumeTaskTasksResumeTaskPost: async (
      taskResumeRequest: TaskResumeRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskResumeRequest' is not null or undefined
      assertParamExists(
        'postResumeTaskTasksResumeTaskPost',
        'taskResumeRequest',
        taskResumeRequest,
      );
      const localVarPath = `/tasks/resume_task`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        taskResumeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post Rewind Task
     * @param {TaskRewindRequest} taskRewindRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postRewindTaskTasksRewindTaskPost: async (
      taskRewindRequest: TaskRewindRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskRewindRequest' is not null or undefined
      assertParamExists(
        'postRewindTaskTasksRewindTaskPost',
        'taskRewindRequest',
        taskRewindRequest,
      );
      const localVarPath = `/tasks/rewind_task`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        taskRewindRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post Robot Task
     * @param {RobotTaskRequest} robotTaskRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postRobotTaskTasksRobotTaskPost: async (
      robotTaskRequest: RobotTaskRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'robotTaskRequest' is not null or undefined
      assertParamExists('postRobotTaskTasksRobotTaskPost', 'robotTaskRequest', robotTaskRequest);
      const localVarPath = `/tasks/robot_task`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        robotTaskRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a scheduled task. Below are some examples of how the schedules are represented. For more examples, check the docs of the underlying library used [here](https://github.com/dbader/schedule/blob/6eb0b5346b1ce35ece5050e65789fa6e44368175/docs/examples.rst).  | every | to | period | at | description | | - | - | - | - | - | | 10 | - | minutes | - | Every 10 minutes | | - | - | hour | - | Every hour | | - | - | day | 10:30 | Every day at 10:30am | | - | - | monday | - | Every monday | | - | - | wednesday | 13:15 | Every wednesday at 01:15pm | | - | - | minute | :17 | Every 17th sec of a mintue | | 5 | 10 | seconds | - | Every 5-10 seconds (randomly) |
     * @summary Post Scheduled Task
     * @param {PostScheduledTaskRequest} postScheduledTaskRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postScheduledTaskScheduledTasksPost: async (
      postScheduledTaskRequest: PostScheduledTaskRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'postScheduledTaskRequest' is not null or undefined
      assertParamExists(
        'postScheduledTaskScheduledTasksPost',
        'postScheduledTaskRequest',
        postScheduledTaskRequest,
      );
      const localVarPath = `/scheduled_tasks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        postScheduledTaskRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post Skip Phase
     * @param {TaskPhaseSkipRequest} taskPhaseSkipRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postSkipPhaseTasksSkipPhasePost: async (
      taskPhaseSkipRequest: TaskPhaseSkipRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskPhaseSkipRequest' is not null or undefined
      assertParamExists(
        'postSkipPhaseTasksSkipPhasePost',
        'taskPhaseSkipRequest',
        taskPhaseSkipRequest,
      );
      const localVarPath = `/tasks/skip_phase`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        taskPhaseSkipRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post Task Discovery
     * @param {TaskDiscoveryRequest} taskDiscoveryRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postTaskDiscoveryTasksTaskDiscoveryPost: async (
      taskDiscoveryRequest: TaskDiscoveryRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskDiscoveryRequest' is not null or undefined
      assertParamExists(
        'postTaskDiscoveryTasksTaskDiscoveryPost',
        'taskDiscoveryRequest',
        taskDiscoveryRequest,
      );
      const localVarPath = `/tasks/task_discovery`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        taskDiscoveryRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post Undo Skip Phase
     * @param {UndoPhaseSkipRequest} undoPhaseSkipRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUndoSkipPhaseTasksUndoSkipPhasePost: async (
      undoPhaseSkipRequest: UndoPhaseSkipRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'undoPhaseSkipRequest' is not null or undefined
      assertParamExists(
        'postUndoSkipPhaseTasksUndoSkipPhasePost',
        'undoPhaseSkipRequest',
        undoPhaseSkipRequest,
      );
      const localVarPath = `/tasks/undo_skip_phase`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        undoPhaseSkipRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Query Task States
     * @param {string} [taskId] comma separated list of task ids
     * @param {string} [category] comma separated list of task categories
     * @param {string} [assignedTo] comma separated list of assigned robot names
     * @param {string} [status] comma separated list of statuses
     * @param {string} [startTimeBetween]          The period of starting time to fetch, in unix millis.          This must be a comma separated string, \&#39;X,Y\&#39; to fetch between X millis and Y millis inclusive.          Example:             \&quot;1000,2000\&quot; - Fetches logs between unix millis 1000 and 2000.
     * @param {string} [finishTimeBetween]          The period of finishing time to fetch, in unix millis.          This must be a comma separated string, \&#39;X,Y\&#39; to fetch between X millis and Y millis inclusive.          Example:             \&quot;1000,2000\&quot; - Fetches logs between unix millis 1000 and 2000.             \&quot;-60000\&quot; - Fetches logs in the last minute.
     * @param {number} [limit] defaults to 100
     * @param {number} [offset] defaults to 0
     * @param {string} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryTaskStatesTasksGet: async (
      taskId?: string,
      category?: string,
      assignedTo?: string,
      status?: string,
      startTimeBetween?: string,
      finishTimeBetween?: string,
      limit?: number,
      offset?: number,
      orderBy?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/tasks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (taskId !== undefined) {
        localVarQueryParameter['task_id'] = taskId;
      }

      if (category !== undefined) {
        localVarQueryParameter['category'] = category;
      }

      if (assignedTo !== undefined) {
        localVarQueryParameter['assigned_to'] = assignedTo;
      }

      if (status !== undefined) {
        localVarQueryParameter['status'] = status;
      }

      if (startTimeBetween !== undefined) {
        localVarQueryParameter['start_time_between'] = startTimeBetween;
      }

      if (finishTimeBetween !== undefined) {
        localVarQueryParameter['finish_time_between'] = finishTimeBetween;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['order_by'] = orderBy;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update Schedule Task
     * @param {number} taskId
     * @param {PostScheduledTaskRequest} postScheduledTaskRequest
     * @param {string} [exceptDate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateScheduleTaskScheduledTasksTaskIdUpdatePost: async (
      taskId: number,
      postScheduledTaskRequest: PostScheduledTaskRequest,
      exceptDate?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskId' is not null or undefined
      assertParamExists('updateScheduleTaskScheduledTasksTaskIdUpdatePost', 'taskId', taskId);
      // verify required parameter 'postScheduledTaskRequest' is not null or undefined
      assertParamExists(
        'updateScheduleTaskScheduledTasksTaskIdUpdatePost',
        'postScheduledTaskRequest',
        postScheduledTaskRequest,
      );
      const localVarPath = `/scheduled_tasks/{task_id}/update`.replace(
        `{${'task_id'}}`,
        encodeURIComponent(String(taskId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (exceptDate !== undefined) {
        localVarQueryParameter['except_date'] =
          (exceptDate as any) instanceof Date ? (exceptDate as any).toISOString() : exceptDate;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        postScheduledTaskRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TasksApi - functional programming interface
 * @export
 */
export const TasksApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TasksApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Del Scheduled Tasks Event
     * @param {number} taskId
     * @param {string} eventDate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async delScheduledTasksEventScheduledTasksTaskIdClearPut(
      taskId: number,
      eventDate: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.delScheduledTasksEventScheduledTasksTaskIdClearPut(
          taskId,
          eventDate,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Del Scheduled Tasks
     * @param {number} taskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async delScheduledTasksScheduledTasksTaskIdDelete(
      taskId: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.delScheduledTasksScheduledTasksTaskIdDelete(
          taskId,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Delete Favorite Task
     * @param {string} favoriteTaskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFavoriteTaskFavoriteTasksFavoriteTaskIdDelete(
      favoriteTaskId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteFavoriteTaskFavoriteTasksFavoriteTaskIdDelete(
          favoriteTaskId,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get Favorites Tasks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFavoritesTasksFavoriteTasksGet(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskFavoritePydantic>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFavoritesTasksFavoriteTasksGet(
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get Scheduled Task
     * @param {number} taskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getScheduledTaskScheduledTasksTaskIdGet(
      taskId: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ApiServerModelsTortoiseModelsScheduledTaskScheduledTask>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getScheduledTaskScheduledTasksTaskIdGet(taskId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get Scheduled Tasks
     * @param {string} startBefore Only return scheduled tasks that start before given timestamp
     * @param {string} untilAfter Only return scheduled tasks that stop after given timestamp
     * @param {number} [limit] defaults to 100
     * @param {number} [offset] defaults to 0
     * @param {string} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getScheduledTasksScheduledTasksGet(
      startBefore: string,
      untilAfter: string,
      limit?: number,
      offset?: number,
      orderBy?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<ApiServerModelsTortoiseModelsScheduledTaskScheduledTask>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getScheduledTasksScheduledTasksGet(
        startBefore,
        untilAfter,
        limit,
        offset,
        orderBy,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Available in socket.io
     * @summary Get Task Log
     * @param {string} taskId task_id
     * @param {string} [between]          The period of time to fetch, in unix millis.          This can be either a comma separated string or a string prefixed with \&#39;-\&#39; to fetch the last X millis.          Example:             \&quot;1000,2000\&quot; - Fetches logs between unix millis 1000 and 2000.             \&quot;-60000\&quot; - Fetches logs in the last minute.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTaskLogTasksTaskIdLogGet(
      taskId: string,
      between?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskEventLog>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskLogTasksTaskIdLogGet(
        taskId,
        between,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Available in socket.io
     * @summary Get Task State
     * @param {string} taskId task_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTaskStateTasksTaskIdStateGet(
      taskId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskState>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskStateTasksTaskIdStateGet(
        taskId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Post Activity Discovery
     * @param {ActivityDiscoveryRequest} activityDiscoveryRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postActivityDiscoveryTasksActivityDiscoveryPost(
      activityDiscoveryRequest: ActivityDiscoveryRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivityDiscovery>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postActivityDiscoveryTasksActivityDiscoveryPost(
          activityDiscoveryRequest,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Post Cancel Task
     * @param {CancelTaskRequest} cancelTaskRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postCancelTaskTasksCancelTaskPost(
      cancelTaskRequest: CancelTaskRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskCancelResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postCancelTaskTasksCancelTaskPost(
        cancelTaskRequest,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Post Dispatch Task
     * @param {DispatchTaskRequest} dispatchTaskRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postDispatchTaskTasksDispatchTaskPost(
      dispatchTaskRequest: DispatchTaskRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskDispatchResponseItem>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postDispatchTaskTasksDispatchTaskPost(
          dispatchTaskRequest,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Post Favorite Task
     * @param {TaskFavoritePydantic} taskFavoritePydantic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postFavoriteTaskFavoriteTasksPost(
      taskFavoritePydantic: TaskFavoritePydantic,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ApiServerModelsTortoiseModelsTasksTaskFavoriteLeaf>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postFavoriteTaskFavoriteTasksPost(
        taskFavoritePydantic,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Post Interrupt Task
     * @param {TaskInterruptionRequest} taskInterruptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postInterruptTaskTasksInterruptTaskPost(
      taskInterruptionRequest: TaskInterruptionRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskInterruptionResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postInterruptTaskTasksInterruptTaskPost(
          taskInterruptionRequest,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Post Kill Task
     * @param {TaskKillRequest} taskKillRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postKillTaskTasksKillTaskPost(
      taskKillRequest: TaskKillRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskKillResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postKillTaskTasksKillTaskPost(
        taskKillRequest,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Post Resume Task
     * @param {TaskResumeRequest} taskResumeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postResumeTaskTasksResumeTaskPost(
      taskResumeRequest: TaskResumeRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResumeResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postResumeTaskTasksResumeTaskPost(
        taskResumeRequest,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Post Rewind Task
     * @param {TaskRewindRequest} taskRewindRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postRewindTaskTasksRewindTaskPost(
      taskRewindRequest: TaskRewindRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskRewindResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postRewindTaskTasksRewindTaskPost(
        taskRewindRequest,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Post Robot Task
     * @param {RobotTaskRequest} robotTaskRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postRobotTaskTasksRobotTaskPost(
      robotTaskRequest: RobotTaskRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RobotTaskResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postRobotTaskTasksRobotTaskPost(
        robotTaskRequest,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Create a scheduled task. Below are some examples of how the schedules are represented. For more examples, check the docs of the underlying library used [here](https://github.com/dbader/schedule/blob/6eb0b5346b1ce35ece5050e65789fa6e44368175/docs/examples.rst).  | every | to | period | at | description | | - | - | - | - | - | | 10 | - | minutes | - | Every 10 minutes | | - | - | hour | - | Every hour | | - | - | day | 10:30 | Every day at 10:30am | | - | - | monday | - | Every monday | | - | - | wednesday | 13:15 | Every wednesday at 01:15pm | | - | - | minute | :17 | Every 17th sec of a mintue | | 5 | 10 | seconds | - | Every 5-10 seconds (randomly) |
     * @summary Post Scheduled Task
     * @param {PostScheduledTaskRequest} postScheduledTaskRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postScheduledTaskScheduledTasksPost(
      postScheduledTaskRequest: PostScheduledTaskRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ApiServerModelsTortoiseModelsScheduledTaskScheduledTask>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postScheduledTaskScheduledTasksPost(
        postScheduledTaskRequest,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Post Skip Phase
     * @param {TaskPhaseSkipRequest} taskPhaseSkipRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postSkipPhaseTasksSkipPhasePost(
      taskPhaseSkipRequest: TaskPhaseSkipRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SkipPhaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postSkipPhaseTasksSkipPhasePost(
        taskPhaseSkipRequest,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Post Task Discovery
     * @param {TaskDiscoveryRequest} taskDiscoveryRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postTaskDiscoveryTasksTaskDiscoveryPost(
      taskDiscoveryRequest: TaskDiscoveryRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskDiscovery>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postTaskDiscoveryTasksTaskDiscoveryPost(
          taskDiscoveryRequest,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Post Undo Skip Phase
     * @param {UndoPhaseSkipRequest} undoPhaseSkipRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postUndoSkipPhaseTasksUndoSkipPhasePost(
      undoPhaseSkipRequest: UndoPhaseSkipRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UndoPhaseSkipResponse>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postUndoSkipPhaseTasksUndoSkipPhasePost(
          undoPhaseSkipRequest,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Query Task States
     * @param {string} [taskId] comma separated list of task ids
     * @param {string} [category] comma separated list of task categories
     * @param {string} [assignedTo] comma separated list of assigned robot names
     * @param {string} [status] comma separated list of statuses
     * @param {string} [startTimeBetween]          The period of starting time to fetch, in unix millis.          This must be a comma separated string, \&#39;X,Y\&#39; to fetch between X millis and Y millis inclusive.          Example:             \&quot;1000,2000\&quot; - Fetches logs between unix millis 1000 and 2000.
     * @param {string} [finishTimeBetween]          The period of finishing time to fetch, in unix millis.          This must be a comma separated string, \&#39;X,Y\&#39; to fetch between X millis and Y millis inclusive.          Example:             \&quot;1000,2000\&quot; - Fetches logs between unix millis 1000 and 2000.             \&quot;-60000\&quot; - Fetches logs in the last minute.
     * @param {number} [limit] defaults to 100
     * @param {number} [offset] defaults to 0
     * @param {string} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async queryTaskStatesTasksGet(
      taskId?: string,
      category?: string,
      assignedTo?: string,
      status?: string,
      startTimeBetween?: string,
      finishTimeBetween?: string,
      limit?: number,
      offset?: number,
      orderBy?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskState>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.queryTaskStatesTasksGet(
        taskId,
        category,
        assignedTo,
        status,
        startTimeBetween,
        finishTimeBetween,
        limit,
        offset,
        orderBy,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Update Schedule Task
     * @param {number} taskId
     * @param {PostScheduledTaskRequest} postScheduledTaskRequest
     * @param {string} [exceptDate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateScheduleTaskScheduledTasksTaskIdUpdatePost(
      taskId: number,
      postScheduledTaskRequest: PostScheduledTaskRequest,
      exceptDate?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ApiServerModelsTortoiseModelsScheduledTaskScheduledTask>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateScheduleTaskScheduledTasksTaskIdUpdatePost(
          taskId,
          postScheduledTaskRequest,
          exceptDate,
          options,
        );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * TasksApi - factory interface
 * @export
 */
export const TasksApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = TasksApiFp(configuration);
  return {
    /**
     *
     * @summary Del Scheduled Tasks Event
     * @param {number} taskId
     * @param {string} eventDate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    delScheduledTasksEventScheduledTasksTaskIdClearPut(
      taskId: number,
      eventDate: string,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .delScheduledTasksEventScheduledTasksTaskIdClearPut(taskId, eventDate, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Del Scheduled Tasks
     * @param {number} taskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    delScheduledTasksScheduledTasksTaskIdDelete(taskId: number, options?: any): AxiosPromise<any> {
      return localVarFp
        .delScheduledTasksScheduledTasksTaskIdDelete(taskId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete Favorite Task
     * @param {string} favoriteTaskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFavoriteTaskFavoriteTasksFavoriteTaskIdDelete(
      favoriteTaskId: string,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .deleteFavoriteTaskFavoriteTasksFavoriteTaskIdDelete(favoriteTaskId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Favorites Tasks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFavoritesTasksFavoriteTasksGet(options?: any): AxiosPromise<Array<TaskFavoritePydantic>> {
      return localVarFp
        .getFavoritesTasksFavoriteTasksGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Scheduled Task
     * @param {number} taskId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getScheduledTaskScheduledTasksTaskIdGet(
      taskId: number,
      options?: any,
    ): AxiosPromise<ApiServerModelsTortoiseModelsScheduledTaskScheduledTask> {
      return localVarFp
        .getScheduledTaskScheduledTasksTaskIdGet(taskId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Scheduled Tasks
     * @param {string} startBefore Only return scheduled tasks that start before given timestamp
     * @param {string} untilAfter Only return scheduled tasks that stop after given timestamp
     * @param {number} [limit] defaults to 100
     * @param {number} [offset] defaults to 0
     * @param {string} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getScheduledTasksScheduledTasksGet(
      startBefore: string,
      untilAfter: string,
      limit?: number,
      offset?: number,
      orderBy?: string,
      options?: any,
    ): AxiosPromise<Array<ApiServerModelsTortoiseModelsScheduledTaskScheduledTask>> {
      return localVarFp
        .getScheduledTasksScheduledTasksGet(
          startBefore,
          untilAfter,
          limit,
          offset,
          orderBy,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Available in socket.io
     * @summary Get Task Log
     * @param {string} taskId task_id
     * @param {string} [between]          The period of time to fetch, in unix millis.          This can be either a comma separated string or a string prefixed with \&#39;-\&#39; to fetch the last X millis.          Example:             \&quot;1000,2000\&quot; - Fetches logs between unix millis 1000 and 2000.             \&quot;-60000\&quot; - Fetches logs in the last minute.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskLogTasksTaskIdLogGet(
      taskId: string,
      between?: string,
      options?: any,
    ): AxiosPromise<TaskEventLog> {
      return localVarFp
        .getTaskLogTasksTaskIdLogGet(taskId, between, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Available in socket.io
     * @summary Get Task State
     * @param {string} taskId task_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskStateTasksTaskIdStateGet(taskId: string, options?: any): AxiosPromise<TaskState> {
      return localVarFp
        .getTaskStateTasksTaskIdStateGet(taskId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Post Activity Discovery
     * @param {ActivityDiscoveryRequest} activityDiscoveryRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postActivityDiscoveryTasksActivityDiscoveryPost(
      activityDiscoveryRequest: ActivityDiscoveryRequest,
      options?: any,
    ): AxiosPromise<ActivityDiscovery> {
      return localVarFp
        .postActivityDiscoveryTasksActivityDiscoveryPost(activityDiscoveryRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Post Cancel Task
     * @param {CancelTaskRequest} cancelTaskRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postCancelTaskTasksCancelTaskPost(
      cancelTaskRequest: CancelTaskRequest,
      options?: any,
    ): AxiosPromise<TaskCancelResponse> {
      return localVarFp
        .postCancelTaskTasksCancelTaskPost(cancelTaskRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Post Dispatch Task
     * @param {DispatchTaskRequest} dispatchTaskRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postDispatchTaskTasksDispatchTaskPost(
      dispatchTaskRequest: DispatchTaskRequest,
      options?: any,
    ): AxiosPromise<TaskDispatchResponseItem> {
      return localVarFp
        .postDispatchTaskTasksDispatchTaskPost(dispatchTaskRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Post Favorite Task
     * @param {TaskFavoritePydantic} taskFavoritePydantic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postFavoriteTaskFavoriteTasksPost(
      taskFavoritePydantic: TaskFavoritePydantic,
      options?: any,
    ): AxiosPromise<ApiServerModelsTortoiseModelsTasksTaskFavoriteLeaf> {
      return localVarFp
        .postFavoriteTaskFavoriteTasksPost(taskFavoritePydantic, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Post Interrupt Task
     * @param {TaskInterruptionRequest} taskInterruptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postInterruptTaskTasksInterruptTaskPost(
      taskInterruptionRequest: TaskInterruptionRequest,
      options?: any,
    ): AxiosPromise<TaskInterruptionResponse> {
      return localVarFp
        .postInterruptTaskTasksInterruptTaskPost(taskInterruptionRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Post Kill Task
     * @param {TaskKillRequest} taskKillRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postKillTaskTasksKillTaskPost(
      taskKillRequest: TaskKillRequest,
      options?: any,
    ): AxiosPromise<TaskKillResponse> {
      return localVarFp
        .postKillTaskTasksKillTaskPost(taskKillRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Post Resume Task
     * @param {TaskResumeRequest} taskResumeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postResumeTaskTasksResumeTaskPost(
      taskResumeRequest: TaskResumeRequest,
      options?: any,
    ): AxiosPromise<TaskResumeResponse> {
      return localVarFp
        .postResumeTaskTasksResumeTaskPost(taskResumeRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Post Rewind Task
     * @param {TaskRewindRequest} taskRewindRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postRewindTaskTasksRewindTaskPost(
      taskRewindRequest: TaskRewindRequest,
      options?: any,
    ): AxiosPromise<TaskRewindResponse> {
      return localVarFp
        .postRewindTaskTasksRewindTaskPost(taskRewindRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Post Robot Task
     * @param {RobotTaskRequest} robotTaskRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postRobotTaskTasksRobotTaskPost(
      robotTaskRequest: RobotTaskRequest,
      options?: any,
    ): AxiosPromise<RobotTaskResponse> {
      return localVarFp
        .postRobotTaskTasksRobotTaskPost(robotTaskRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a scheduled task. Below are some examples of how the schedules are represented. For more examples, check the docs of the underlying library used [here](https://github.com/dbader/schedule/blob/6eb0b5346b1ce35ece5050e65789fa6e44368175/docs/examples.rst).  | every | to | period | at | description | | - | - | - | - | - | | 10 | - | minutes | - | Every 10 minutes | | - | - | hour | - | Every hour | | - | - | day | 10:30 | Every day at 10:30am | | - | - | monday | - | Every monday | | - | - | wednesday | 13:15 | Every wednesday at 01:15pm | | - | - | minute | :17 | Every 17th sec of a mintue | | 5 | 10 | seconds | - | Every 5-10 seconds (randomly) |
     * @summary Post Scheduled Task
     * @param {PostScheduledTaskRequest} postScheduledTaskRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postScheduledTaskScheduledTasksPost(
      postScheduledTaskRequest: PostScheduledTaskRequest,
      options?: any,
    ): AxiosPromise<ApiServerModelsTortoiseModelsScheduledTaskScheduledTask> {
      return localVarFp
        .postScheduledTaskScheduledTasksPost(postScheduledTaskRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Post Skip Phase
     * @param {TaskPhaseSkipRequest} taskPhaseSkipRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postSkipPhaseTasksSkipPhasePost(
      taskPhaseSkipRequest: TaskPhaseSkipRequest,
      options?: any,
    ): AxiosPromise<SkipPhaseResponse> {
      return localVarFp
        .postSkipPhaseTasksSkipPhasePost(taskPhaseSkipRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Post Task Discovery
     * @param {TaskDiscoveryRequest} taskDiscoveryRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postTaskDiscoveryTasksTaskDiscoveryPost(
      taskDiscoveryRequest: TaskDiscoveryRequest,
      options?: any,
    ): AxiosPromise<TaskDiscovery> {
      return localVarFp
        .postTaskDiscoveryTasksTaskDiscoveryPost(taskDiscoveryRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Post Undo Skip Phase
     * @param {UndoPhaseSkipRequest} undoPhaseSkipRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUndoSkipPhaseTasksUndoSkipPhasePost(
      undoPhaseSkipRequest: UndoPhaseSkipRequest,
      options?: any,
    ): AxiosPromise<UndoPhaseSkipResponse> {
      return localVarFp
        .postUndoSkipPhaseTasksUndoSkipPhasePost(undoPhaseSkipRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Query Task States
     * @param {string} [taskId] comma separated list of task ids
     * @param {string} [category] comma separated list of task categories
     * @param {string} [assignedTo] comma separated list of assigned robot names
     * @param {string} [status] comma separated list of statuses
     * @param {string} [startTimeBetween]          The period of starting time to fetch, in unix millis.          This must be a comma separated string, \&#39;X,Y\&#39; to fetch between X millis and Y millis inclusive.          Example:             \&quot;1000,2000\&quot; - Fetches logs between unix millis 1000 and 2000.
     * @param {string} [finishTimeBetween]          The period of finishing time to fetch, in unix millis.          This must be a comma separated string, \&#39;X,Y\&#39; to fetch between X millis and Y millis inclusive.          Example:             \&quot;1000,2000\&quot; - Fetches logs between unix millis 1000 and 2000.             \&quot;-60000\&quot; - Fetches logs in the last minute.
     * @param {number} [limit] defaults to 100
     * @param {number} [offset] defaults to 0
     * @param {string} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryTaskStatesTasksGet(
      taskId?: string,
      category?: string,
      assignedTo?: string,
      status?: string,
      startTimeBetween?: string,
      finishTimeBetween?: string,
      limit?: number,
      offset?: number,
      orderBy?: string,
      options?: any,
    ): AxiosPromise<Array<TaskState>> {
      return localVarFp
        .queryTaskStatesTasksGet(
          taskId,
          category,
          assignedTo,
          status,
          startTimeBetween,
          finishTimeBetween,
          limit,
          offset,
          orderBy,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update Schedule Task
     * @param {number} taskId
     * @param {PostScheduledTaskRequest} postScheduledTaskRequest
     * @param {string} [exceptDate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateScheduleTaskScheduledTasksTaskIdUpdatePost(
      taskId: number,
      postScheduledTaskRequest: PostScheduledTaskRequest,
      exceptDate?: string,
      options?: any,
    ): AxiosPromise<ApiServerModelsTortoiseModelsScheduledTaskScheduledTask> {
      return localVarFp
        .updateScheduleTaskScheduledTasksTaskIdUpdatePost(
          taskId,
          postScheduledTaskRequest,
          exceptDate,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
export class TasksApi extends BaseAPI {
  /**
   *
   * @summary Del Scheduled Tasks Event
   * @param {number} taskId
   * @param {string} eventDate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public delScheduledTasksEventScheduledTasksTaskIdClearPut(
    taskId: number,
    eventDate: string,
    options?: AxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .delScheduledTasksEventScheduledTasksTaskIdClearPut(taskId, eventDate, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Del Scheduled Tasks
   * @param {number} taskId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public delScheduledTasksScheduledTasksTaskIdDelete(taskId: number, options?: AxiosRequestConfig) {
    return TasksApiFp(this.configuration)
      .delScheduledTasksScheduledTasksTaskIdDelete(taskId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete Favorite Task
   * @param {string} favoriteTaskId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public deleteFavoriteTaskFavoriteTasksFavoriteTaskIdDelete(
    favoriteTaskId: string,
    options?: AxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .deleteFavoriteTaskFavoriteTasksFavoriteTaskIdDelete(favoriteTaskId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Favorites Tasks
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public getFavoritesTasksFavoriteTasksGet(options?: AxiosRequestConfig) {
    return TasksApiFp(this.configuration)
      .getFavoritesTasksFavoriteTasksGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Scheduled Task
   * @param {number} taskId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public getScheduledTaskScheduledTasksTaskIdGet(taskId: number, options?: AxiosRequestConfig) {
    return TasksApiFp(this.configuration)
      .getScheduledTaskScheduledTasksTaskIdGet(taskId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Scheduled Tasks
   * @param {string} startBefore Only return scheduled tasks that start before given timestamp
   * @param {string} untilAfter Only return scheduled tasks that stop after given timestamp
   * @param {number} [limit] defaults to 100
   * @param {number} [offset] defaults to 0
   * @param {string} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public getScheduledTasksScheduledTasksGet(
    startBefore: string,
    untilAfter: string,
    limit?: number,
    offset?: number,
    orderBy?: string,
    options?: AxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .getScheduledTasksScheduledTasksGet(startBefore, untilAfter, limit, offset, orderBy, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Available in socket.io
   * @summary Get Task Log
   * @param {string} taskId task_id
   * @param {string} [between]          The period of time to fetch, in unix millis.          This can be either a comma separated string or a string prefixed with \&#39;-\&#39; to fetch the last X millis.          Example:             \&quot;1000,2000\&quot; - Fetches logs between unix millis 1000 and 2000.             \&quot;-60000\&quot; - Fetches logs in the last minute.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public getTaskLogTasksTaskIdLogGet(
    taskId: string,
    between?: string,
    options?: AxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .getTaskLogTasksTaskIdLogGet(taskId, between, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Available in socket.io
   * @summary Get Task State
   * @param {string} taskId task_id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public getTaskStateTasksTaskIdStateGet(taskId: string, options?: AxiosRequestConfig) {
    return TasksApiFp(this.configuration)
      .getTaskStateTasksTaskIdStateGet(taskId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Post Activity Discovery
   * @param {ActivityDiscoveryRequest} activityDiscoveryRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public postActivityDiscoveryTasksActivityDiscoveryPost(
    activityDiscoveryRequest: ActivityDiscoveryRequest,
    options?: AxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .postActivityDiscoveryTasksActivityDiscoveryPost(activityDiscoveryRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Post Cancel Task
   * @param {CancelTaskRequest} cancelTaskRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public postCancelTaskTasksCancelTaskPost(
    cancelTaskRequest: CancelTaskRequest,
    options?: AxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .postCancelTaskTasksCancelTaskPost(cancelTaskRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Post Dispatch Task
   * @param {DispatchTaskRequest} dispatchTaskRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public postDispatchTaskTasksDispatchTaskPost(
    dispatchTaskRequest: DispatchTaskRequest,
    options?: AxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .postDispatchTaskTasksDispatchTaskPost(dispatchTaskRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Post Favorite Task
   * @param {TaskFavoritePydantic} taskFavoritePydantic
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public postFavoriteTaskFavoriteTasksPost(
    taskFavoritePydantic: TaskFavoritePydantic,
    options?: AxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .postFavoriteTaskFavoriteTasksPost(taskFavoritePydantic, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Post Interrupt Task
   * @param {TaskInterruptionRequest} taskInterruptionRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public postInterruptTaskTasksInterruptTaskPost(
    taskInterruptionRequest: TaskInterruptionRequest,
    options?: AxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .postInterruptTaskTasksInterruptTaskPost(taskInterruptionRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Post Kill Task
   * @param {TaskKillRequest} taskKillRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public postKillTaskTasksKillTaskPost(
    taskKillRequest: TaskKillRequest,
    options?: AxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .postKillTaskTasksKillTaskPost(taskKillRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Post Resume Task
   * @param {TaskResumeRequest} taskResumeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public postResumeTaskTasksResumeTaskPost(
    taskResumeRequest: TaskResumeRequest,
    options?: AxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .postResumeTaskTasksResumeTaskPost(taskResumeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Post Rewind Task
   * @param {TaskRewindRequest} taskRewindRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public postRewindTaskTasksRewindTaskPost(
    taskRewindRequest: TaskRewindRequest,
    options?: AxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .postRewindTaskTasksRewindTaskPost(taskRewindRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Post Robot Task
   * @param {RobotTaskRequest} robotTaskRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public postRobotTaskTasksRobotTaskPost(
    robotTaskRequest: RobotTaskRequest,
    options?: AxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .postRobotTaskTasksRobotTaskPost(robotTaskRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a scheduled task. Below are some examples of how the schedules are represented. For more examples, check the docs of the underlying library used [here](https://github.com/dbader/schedule/blob/6eb0b5346b1ce35ece5050e65789fa6e44368175/docs/examples.rst).  | every | to | period | at | description | | - | - | - | - | - | | 10 | - | minutes | - | Every 10 minutes | | - | - | hour | - | Every hour | | - | - | day | 10:30 | Every day at 10:30am | | - | - | monday | - | Every monday | | - | - | wednesday | 13:15 | Every wednesday at 01:15pm | | - | - | minute | :17 | Every 17th sec of a mintue | | 5 | 10 | seconds | - | Every 5-10 seconds (randomly) |
   * @summary Post Scheduled Task
   * @param {PostScheduledTaskRequest} postScheduledTaskRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public postScheduledTaskScheduledTasksPost(
    postScheduledTaskRequest: PostScheduledTaskRequest,
    options?: AxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .postScheduledTaskScheduledTasksPost(postScheduledTaskRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Post Skip Phase
   * @param {TaskPhaseSkipRequest} taskPhaseSkipRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public postSkipPhaseTasksSkipPhasePost(
    taskPhaseSkipRequest: TaskPhaseSkipRequest,
    options?: AxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .postSkipPhaseTasksSkipPhasePost(taskPhaseSkipRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Post Task Discovery
   * @param {TaskDiscoveryRequest} taskDiscoveryRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public postTaskDiscoveryTasksTaskDiscoveryPost(
    taskDiscoveryRequest: TaskDiscoveryRequest,
    options?: AxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .postTaskDiscoveryTasksTaskDiscoveryPost(taskDiscoveryRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Post Undo Skip Phase
   * @param {UndoPhaseSkipRequest} undoPhaseSkipRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public postUndoSkipPhaseTasksUndoSkipPhasePost(
    undoPhaseSkipRequest: UndoPhaseSkipRequest,
    options?: AxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .postUndoSkipPhaseTasksUndoSkipPhasePost(undoPhaseSkipRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Query Task States
   * @param {string} [taskId] comma separated list of task ids
   * @param {string} [category] comma separated list of task categories
   * @param {string} [assignedTo] comma separated list of assigned robot names
   * @param {string} [status] comma separated list of statuses
   * @param {string} [startTimeBetween]          The period of starting time to fetch, in unix millis.          This must be a comma separated string, \&#39;X,Y\&#39; to fetch between X millis and Y millis inclusive.          Example:             \&quot;1000,2000\&quot; - Fetches logs between unix millis 1000 and 2000.
   * @param {string} [finishTimeBetween]          The period of finishing time to fetch, in unix millis.          This must be a comma separated string, \&#39;X,Y\&#39; to fetch between X millis and Y millis inclusive.          Example:             \&quot;1000,2000\&quot; - Fetches logs between unix millis 1000 and 2000.             \&quot;-60000\&quot; - Fetches logs in the last minute.
   * @param {number} [limit] defaults to 100
   * @param {number} [offset] defaults to 0
   * @param {string} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public queryTaskStatesTasksGet(
    taskId?: string,
    category?: string,
    assignedTo?: string,
    status?: string,
    startTimeBetween?: string,
    finishTimeBetween?: string,
    limit?: number,
    offset?: number,
    orderBy?: string,
    options?: AxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .queryTaskStatesTasksGet(
        taskId,
        category,
        assignedTo,
        status,
        startTimeBetween,
        finishTimeBetween,
        limit,
        offset,
        orderBy,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update Schedule Task
   * @param {number} taskId
   * @param {PostScheduledTaskRequest} postScheduledTaskRequest
   * @param {string} [exceptDate]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public updateScheduleTaskScheduledTasksTaskIdUpdatePost(
    taskId: number,
    postScheduledTaskRequest: PostScheduledTaskRequest,
    exceptDate?: string,
    options?: AxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .updateScheduleTaskScheduledTasksTaskIdUpdatePost(
        taskId,
        postScheduledTaskRequest,
        exceptDate,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}
