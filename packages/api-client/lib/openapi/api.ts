/* tslint:disable */
/* eslint-disable */
/**
 * RMF API Server
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface AffineImage
 */
export interface AffineImage {
  /**
   *
   * @type {string}
   * @memberof AffineImage
   */
  name?: string;
  /**
   *
   * @type {number}
   * @memberof AffineImage
   */
  x_offset?: number;
  /**
   *
   * @type {number}
   * @memberof AffineImage
   */
  y_offset?: number;
  /**
   *
   * @type {number}
   * @memberof AffineImage
   */
  yaw?: number;
  /**
   *
   * @type {number}
   * @memberof AffineImage
   */
  scale?: number;
  /**
   *
   * @type {string}
   * @memberof AffineImage
   */
  encoding?: string;
  /**
   *
   * @type {string}
   * @memberof AffineImage
   */
  data: string;
}
/**
 *
 * @export
 * @interface ApiServerModelsFleetsRobotState
 */
export interface ApiServerModelsFleetsRobotState {
  /**
   *
   * @type {string}
   * @memberof ApiServerModelsFleetsRobotState
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof ApiServerModelsFleetsRobotState
   */
  model?: string;
  /**
   *
   * @type {string}
   * @memberof ApiServerModelsFleetsRobotState
   */
  task_id?: string;
  /**
   *
   * @type {number}
   * @memberof ApiServerModelsFleetsRobotState
   */
  seq?: number;
  /**
   *
   * @type {RobotMode}
   * @memberof ApiServerModelsFleetsRobotState
   */
  mode?: RobotMode;
  /**
   *
   * @type {number}
   * @memberof ApiServerModelsFleetsRobotState
   */
  battery_percent?: number;
  /**
   *
   * @type {Location}
   * @memberof ApiServerModelsFleetsRobotState
   */
  location?: Location;
  /**
   *
   * @type {Array<Location>}
   * @memberof ApiServerModelsFleetsRobotState
   */
  path?: Array<Location>;
}
/**
 *
 * @export
 * @interface ApiServerModelsRosPydanticRmfFleetMsgsRobotStateRobotState
 */
export interface ApiServerModelsRosPydanticRmfFleetMsgsRobotStateRobotState {
  /**
   *
   * @type {string}
   * @memberof ApiServerModelsRosPydanticRmfFleetMsgsRobotStateRobotState
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof ApiServerModelsRosPydanticRmfFleetMsgsRobotStateRobotState
   */
  model?: string;
  /**
   *
   * @type {string}
   * @memberof ApiServerModelsRosPydanticRmfFleetMsgsRobotStateRobotState
   */
  task_id?: string;
  /**
   *
   * @type {number}
   * @memberof ApiServerModelsRosPydanticRmfFleetMsgsRobotStateRobotState
   */
  seq?: number;
  /**
   *
   * @type {RobotMode}
   * @memberof ApiServerModelsRosPydanticRmfFleetMsgsRobotStateRobotState
   */
  mode?: RobotMode;
  /**
   *
   * @type {number}
   * @memberof ApiServerModelsRosPydanticRmfFleetMsgsRobotStateRobotState
   */
  battery_percent?: number;
  /**
   *
   * @type {Location}
   * @memberof ApiServerModelsRosPydanticRmfFleetMsgsRobotStateRobotState
   */
  location?: Location;
  /**
   *
   * @type {Array<Location>}
   * @memberof ApiServerModelsRosPydanticRmfFleetMsgsRobotStateRobotState
   */
  path?: Array<Location>;
}
/**
 *
 * @export
 * @interface Behavior
 */
export interface Behavior {
  /**
   *
   * @type {string}
   * @memberof Behavior
   */
  name?: string;
  /**
   *
   * @type {Array<BehaviorParameter>}
   * @memberof Behavior
   */
  parameters?: Array<BehaviorParameter>;
}
/**
 *
 * @export
 * @interface BehaviorParameter
 */
export interface BehaviorParameter {
  /**
   *
   * @type {string}
   * @memberof BehaviorParameter
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof BehaviorParameter
   */
  value?: string;
}
/**
 *
 * @export
 * @interface BuildingMap
 */
export interface BuildingMap {
  /**
   *
   * @type {string}
   * @memberof BuildingMap
   */
  name?: string;
  /**
   *
   * @type {Array<Level>}
   * @memberof BuildingMap
   */
  levels: Array<Level>;
  /**
   *
   * @type {Array<Lift>}
   * @memberof BuildingMap
   */
  lifts?: Array<Lift>;
}
/**
 *
 * @export
 * @interface CancelTask
 */
export interface CancelTask {
  /**
   *
   * @type {string}
   * @memberof CancelTask
   */
  task_id: string;
}
/**
 *
 * @export
 * @interface Clean
 */
export interface Clean {
  /**
   *
   * @type {string}
   * @memberof Clean
   */
  start_waypoint?: string;
}
/**
 *
 * @export
 * @interface CleanTaskDescription
 */
export interface CleanTaskDescription {
  /**
   *
   * @type {string}
   * @memberof CleanTaskDescription
   */
  cleaning_zone: string;
}
/**
 *
 * @export
 * @interface Delivery
 */
export interface Delivery {
  /**
   *
   * @type {string}
   * @memberof Delivery
   */
  task_id?: string;
  /**
   *
   * @type {Array<DispenserRequestItem>}
   * @memberof Delivery
   */
  items?: Array<DispenserRequestItem>;
  /**
   *
   * @type {string}
   * @memberof Delivery
   */
  pickup_place_name?: string;
  /**
   *
   * @type {string}
   * @memberof Delivery
   */
  pickup_dispenser?: string;
  /**
   *
   * @type {Behavior}
   * @memberof Delivery
   */
  pickup_behavior?: Behavior;
  /**
   *
   * @type {string}
   * @memberof Delivery
   */
  dropoff_place_name?: string;
  /**
   *
   * @type {string}
   * @memberof Delivery
   */
  dropoff_ingestor?: string;
  /**
   *
   * @type {Behavior}
   * @memberof Delivery
   */
  dropoff_behavior?: Behavior;
}
/**
 *
 * @export
 * @interface DeliveryTaskDescription
 */
export interface DeliveryTaskDescription {
  /**
   *
   * @type {string}
   * @memberof DeliveryTaskDescription
   */
  pickup_place_name: string;
  /**
   *
   * @type {string}
   * @memberof DeliveryTaskDescription
   */
  pickup_dispenser: string;
  /**
   *
   * @type {string}
   * @memberof DeliveryTaskDescription
   */
  dropoff_ingestor: string;
  /**
   *
   * @type {string}
   * @memberof DeliveryTaskDescription
   */
  dropoff_place_name: string;
}
/**
 *
 * @export
 * @interface Dispenser
 */
export interface Dispenser {
  /**
   *
   * @type {string}
   * @memberof Dispenser
   */
  guid: string;
}
/**
 *
 * @export
 * @interface DispenserHealth
 */
export interface DispenserHealth {
  /**
   *
   * @type {string}
   * @memberof DispenserHealth
   */
  health_status: string | null;
  /**
   *
   * @type {string}
   * @memberof DispenserHealth
   */
  health_message?: string | null;
  /**
   *
   * @type {string}
   * @memberof DispenserHealth
   */
  id_: string;
}
/**
 *
 * @export
 * @interface DispenserRequestItem
 */
export interface DispenserRequestItem {
  /**
   *
   * @type {string}
   * @memberof DispenserRequestItem
   */
  type_guid?: string;
  /**
   *
   * @type {number}
   * @memberof DispenserRequestItem
   */
  quantity?: number;
  /**
   *
   * @type {string}
   * @memberof DispenserRequestItem
   */
  compartment_name?: string;
}
/**
 *
 * @export
 * @interface DispenserState
 */
export interface DispenserState {
  /**
   *
   * @type {Time}
   * @memberof DispenserState
   */
  time?: Time;
  /**
   *
   * @type {string}
   * @memberof DispenserState
   */
  guid?: string;
  /**
   *
   * @type {number}
   * @memberof DispenserState
   */
  mode?: number;
  /**
   *
   * @type {Array<string>}
   * @memberof DispenserState
   */
  request_guid_queue?: Array<string>;
  /**
   *
   * @type {number}
   * @memberof DispenserState
   */
  seconds_remaining?: number;
}
/**
 *
 * @export
 * @interface Door
 */
export interface Door {
  /**
   *
   * @type {string}
   * @memberof Door
   */
  name?: string;
  /**
   *
   * @type {number}
   * @memberof Door
   */
  v1_x?: number;
  /**
   *
   * @type {number}
   * @memberof Door
   */
  v1_y?: number;
  /**
   *
   * @type {number}
   * @memberof Door
   */
  v2_x?: number;
  /**
   *
   * @type {number}
   * @memberof Door
   */
  v2_y?: number;
  /**
   *
   * @type {number}
   * @memberof Door
   */
  door_type?: number;
  /**
   *
   * @type {number}
   * @memberof Door
   */
  motion_range?: number;
  /**
   *
   * @type {number}
   * @memberof Door
   */
  motion_direction?: number;
}
/**
 *
 * @export
 * @interface DoorHealth
 */
export interface DoorHealth {
  /**
   *
   * @type {string}
   * @memberof DoorHealth
   */
  health_status: string | null;
  /**
   *
   * @type {string}
   * @memberof DoorHealth
   */
  health_message?: string | null;
  /**
   *
   * @type {string}
   * @memberof DoorHealth
   */
  id_: string;
}
/**
 *
 * @export
 * @interface DoorMode
 */
export interface DoorMode {
  /**
   *
   * @type {number}
   * @memberof DoorMode
   */
  value?: number;
}
/**
 *
 * @export
 * @interface DoorRequest
 */
export interface DoorRequest {
  /**
   * https://github.com/open-rmf/rmf_internal_msgs/blob/main/rmf_door_msgs/msg/DoorMode.msg
   * @type {number}
   * @memberof DoorRequest
   */
  mode: number;
}
/**
 *
 * @export
 * @interface DoorState
 */
export interface DoorState {
  /**
   *
   * @type {Time}
   * @memberof DoorState
   */
  door_time?: Time;
  /**
   *
   * @type {string}
   * @memberof DoorState
   */
  door_name?: string;
  /**
   *
   * @type {DoorMode}
   * @memberof DoorState
   */
  current_mode?: DoorMode;
}
/**
 *
 * @export
 * @interface Fleet
 */
export interface Fleet {
  /**
   *
   * @type {string}
   * @memberof Fleet
   */
  name: string;
  /**
   *
   * @type {FleetState}
   * @memberof Fleet
   */
  state: FleetState;
}
/**
 *
 * @export
 * @interface FleetState
 */
export interface FleetState {
  /**
   *
   * @type {string}
   * @memberof FleetState
   */
  name?: string;
  /**
   *
   * @type {Array<ApiServerModelsRosPydanticRmfFleetMsgsRobotStateRobotState>}
   * @memberof FleetState
   */
  robots?: Array<ApiServerModelsRosPydanticRmfFleetMsgsRobotStateRobotState>;
}
/**
 *
 * @export
 * @interface Graph
 */
export interface Graph {
  /**
   *
   * @type {string}
   * @memberof Graph
   */
  name?: string;
  /**
   *
   * @type {Array<GraphNode>}
   * @memberof Graph
   */
  vertices?: Array<GraphNode>;
  /**
   *
   * @type {Array<GraphEdge>}
   * @memberof Graph
   */
  edges?: Array<GraphEdge>;
  /**
   *
   * @type {Array<Param>}
   * @memberof Graph
   */
  params?: Array<Param>;
}
/**
 *
 * @export
 * @interface GraphEdge
 */
export interface GraphEdge {
  /**
   *
   * @type {number}
   * @memberof GraphEdge
   */
  v1_idx?: number;
  /**
   *
   * @type {number}
   * @memberof GraphEdge
   */
  v2_idx?: number;
  /**
   *
   * @type {Array<Param>}
   * @memberof GraphEdge
   */
  params?: Array<Param>;
  /**
   *
   * @type {number}
   * @memberof GraphEdge
   */
  edge_type?: number;
}
/**
 *
 * @export
 * @interface GraphNode
 */
export interface GraphNode {
  /**
   *
   * @type {number}
   * @memberof GraphNode
   */
  x?: number;
  /**
   *
   * @type {number}
   * @memberof GraphNode
   */
  y?: number;
  /**
   *
   * @type {string}
   * @memberof GraphNode
   */
  name?: string;
  /**
   *
   * @type {Array<Param>}
   * @memberof GraphNode
   */
  params?: Array<Param>;
}
/**
 *
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
  /**
   *
   * @type {Array<ValidationError>}
   * @memberof HTTPValidationError
   */
  detail?: Array<ValidationError>;
}
/**
 *
 * @export
 * @interface Ingestor
 */
export interface Ingestor {
  /**
   *
   * @type {string}
   * @memberof Ingestor
   */
  guid: string;
}
/**
 *
 * @export
 * @interface IngestorHealth
 */
export interface IngestorHealth {
  /**
   *
   * @type {string}
   * @memberof IngestorHealth
   */
  health_status: string | null;
  /**
   *
   * @type {string}
   * @memberof IngestorHealth
   */
  health_message?: string | null;
  /**
   *
   * @type {string}
   * @memberof IngestorHealth
   */
  id_: string;
}
/**
 *
 * @export
 * @interface IngestorState
 */
export interface IngestorState {
  /**
   *
   * @type {Time}
   * @memberof IngestorState
   */
  time?: Time;
  /**
   *
   * @type {string}
   * @memberof IngestorState
   */
  guid?: string;
  /**
   *
   * @type {number}
   * @memberof IngestorState
   */
  mode?: number;
  /**
   *
   * @type {Array<string>}
   * @memberof IngestorState
   */
  request_guid_queue?: Array<string>;
  /**
   *
   * @type {number}
   * @memberof IngestorState
   */
  seconds_remaining?: number;
}
/**
 *
 * @export
 * @interface Level
 */
export interface Level {
  /**
   *
   * @type {string}
   * @memberof Level
   */
  name?: string;
  /**
   *
   * @type {number}
   * @memberof Level
   */
  elevation?: number;
  /**
   *
   * @type {Array<AffineImage>}
   * @memberof Level
   */
  images: Array<AffineImage>;
  /**
   *
   * @type {Array<Place>}
   * @memberof Level
   */
  places?: Array<Place>;
  /**
   *
   * @type {Array<Door>}
   * @memberof Level
   */
  doors?: Array<Door>;
  /**
   *
   * @type {Array<Graph>}
   * @memberof Level
   */
  nav_graphs?: Array<Graph>;
  /**
   *
   * @type {Graph}
   * @memberof Level
   */
  wall_graph?: Graph;
}
/**
 *
 * @export
 * @interface Lift
 */
export interface Lift {
  /**
   *
   * @type {string}
   * @memberof Lift
   */
  name?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Lift
   */
  levels?: Array<string>;
  /**
   *
   * @type {Array<Door>}
   * @memberof Lift
   */
  doors?: Array<Door>;
  /**
   *
   * @type {Graph}
   * @memberof Lift
   */
  wall_graph?: Graph;
  /**
   *
   * @type {number}
   * @memberof Lift
   */
  ref_x?: number;
  /**
   *
   * @type {number}
   * @memberof Lift
   */
  ref_y?: number;
  /**
   *
   * @type {number}
   * @memberof Lift
   */
  ref_yaw?: number;
  /**
   *
   * @type {number}
   * @memberof Lift
   */
  width?: number;
  /**
   *
   * @type {number}
   * @memberof Lift
   */
  depth?: number;
}
/**
 *
 * @export
 * @interface LiftHealth
 */
export interface LiftHealth {
  /**
   *
   * @type {string}
   * @memberof LiftHealth
   */
  health_status: string | null;
  /**
   *
   * @type {string}
   * @memberof LiftHealth
   */
  health_message?: string | null;
  /**
   *
   * @type {string}
   * @memberof LiftHealth
   */
  id_: string;
}
/**
 *
 * @export
 * @interface LiftRequest
 */
export interface LiftRequest {
  /**
   * https://github.com/open-rmf/rmf_internal_msgs/blob/main/rmf_lift_msgs/msg/LiftRequest.msg
   * @type {number}
   * @memberof LiftRequest
   */
  request_type: number;
  /**
   * https://github.com/open-rmf/rmf_internal_msgs/blob/main/rmf_lift_msgs/msg/LiftRequest.msg
   * @type {number}
   * @memberof LiftRequest
   */
  door_mode: number;
  /**
   *
   * @type {string}
   * @memberof LiftRequest
   */
  destination: string;
}
/**
 *
 * @export
 * @interface LiftState
 */
export interface LiftState {
  /**
   *
   * @type {Time}
   * @memberof LiftState
   */
  lift_time?: Time;
  /**
   *
   * @type {string}
   * @memberof LiftState
   */
  lift_name?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof LiftState
   */
  available_floors?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof LiftState
   */
  current_floor?: string;
  /**
   *
   * @type {string}
   * @memberof LiftState
   */
  destination_floor?: string;
  /**
   *
   * @type {number}
   * @memberof LiftState
   */
  door_state?: number;
  /**
   *
   * @type {number}
   * @memberof LiftState
   */
  motion_state?: number;
  /**
   *
   * @type {Array<number>}
   * @memberof LiftState
   */
  available_modes: Array<number>;
  /**
   *
   * @type {number}
   * @memberof LiftState
   */
  current_mode?: number;
  /**
   *
   * @type {string}
   * @memberof LiftState
   */
  session_id?: string;
}
/**
 *
 * @export
 * @interface Location
 */
export interface Location {
  /**
   *
   * @type {Time}
   * @memberof Location
   */
  t?: Time;
  /**
   *
   * @type {number}
   * @memberof Location
   */
  x?: number;
  /**
   *
   * @type {number}
   * @memberof Location
   */
  y?: number;
  /**
   *
   * @type {number}
   * @memberof Location
   */
  yaw?: number;
  /**
   *
   * @type {string}
   * @memberof Location
   */
  level_name?: string;
  /**
   *
   * @type {number}
   * @memberof Location
   */
  index?: number;
}
/**
 *
 * @export
 * @interface Loop
 */
export interface Loop {
  /**
   *
   * @type {string}
   * @memberof Loop
   */
  task_id?: string;
  /**
   *
   * @type {string}
   * @memberof Loop
   */
  robot_type?: string;
  /**
   *
   * @type {number}
   * @memberof Loop
   */
  num_loops?: number;
  /**
   *
   * @type {string}
   * @memberof Loop
   */
  start_name?: string;
  /**
   *
   * @type {string}
   * @memberof Loop
   */
  finish_name?: string;
}
/**
 *
 * @export
 * @interface LoopTaskDescription
 */
export interface LoopTaskDescription {
  /**
   *
   * @type {number}
   * @memberof LoopTaskDescription
   */
  num_loops: number;
  /**
   *
   * @type {string}
   * @memberof LoopTaskDescription
   */
  start_name: string;
  /**
   *
   * @type {string}
   * @memberof LoopTaskDescription
   */
  finish_name: string;
}
/**
 *
 * @export
 * @interface Param
 */
export interface Param {
  /**
   *
   * @type {string}
   * @memberof Param
   */
  name?: string;
  /**
   *
   * @type {number}
   * @memberof Param
   */
  type?: number;
  /**
   *
   * @type {number}
   * @memberof Param
   */
  value_int?: number;
  /**
   *
   * @type {number}
   * @memberof Param
   */
  value_float?: number;
  /**
   *
   * @type {string}
   * @memberof Param
   */
  value_string?: string;
  /**
   *
   * @type {boolean}
   * @memberof Param
   */
  value_bool?: boolean;
}
/**
 *
 * @export
 * @interface Permission
 */
export interface Permission {
  /**
   *
   * @type {string}
   * @memberof Permission
   */
  authz_grp: string;
  /**
   *
   * @type {string}
   * @memberof Permission
   */
  action: string;
}
/**
 *
 * @export
 * @interface Place
 */
export interface Place {
  /**
   *
   * @type {string}
   * @memberof Place
   */
  name?: string;
  /**
   *
   * @type {number}
   * @memberof Place
   */
  x?: number;
  /**
   *
   * @type {number}
   * @memberof Place
   */
  y?: number;
  /**
   *
   * @type {number}
   * @memberof Place
   */
  yaw?: number;
  /**
   *
   * @type {number}
   * @memberof Place
   */
  position_tolerance?: number;
  /**
   *
   * @type {number}
   * @memberof Place
   */
  yaw_tolerance?: number;
}
/**
 *
 * @export
 * @interface PostMakeAdmin
 */
export interface PostMakeAdmin {
  /**
   *
   * @type {boolean}
   * @memberof PostMakeAdmin
   */
  admin: boolean;
}
/**
 *
 * @export
 * @interface PostRoles
 */
export interface PostRoles {
  /**
   *
   * @type {string}
   * @memberof PostRoles
   */
  name: string;
}
/**
 *
 * @export
 * @interface PostUsers
 */
export interface PostUsers {
  /**
   *
   * @type {string}
   * @memberof PostUsers
   */
  username: string;
  /**
   *
   * @type {boolean}
   * @memberof PostUsers
   */
  is_admin?: boolean;
}
/**
 *
 * @export
 * @interface Priority
 */
export interface Priority {
  /**
   *
   * @type {number}
   * @memberof Priority
   */
  value?: number;
}
/**
 *
 * @export
 * @interface Robot
 */
export interface Robot {
  /**
   *
   * @type {string}
   * @memberof Robot
   */
  fleet: string;
  /**
   *
   * @type {string}
   * @memberof Robot
   */
  name: string;
  /**
   *
   * @type {ApiServerModelsFleetsRobotState}
   * @memberof Robot
   */
  state: ApiServerModelsFleetsRobotState;
  /**
   *
   * @type {Array<Task>}
   * @memberof Robot
   */
  tasks?: Array<Task>;
}
/**
 *
 * @export
 * @interface RobotHealth
 */
export interface RobotHealth {
  /**
   *
   * @type {string}
   * @memberof RobotHealth
   */
  health_status: string | null;
  /**
   *
   * @type {string}
   * @memberof RobotHealth
   */
  health_message?: string | null;
  /**
   *
   * @type {string}
   * @memberof RobotHealth
   */
  id_: string;
}
/**
 *
 * @export
 * @interface RobotMode
 */
export interface RobotMode {
  /**
   *
   * @type {number}
   * @memberof RobotMode
   */
  mode?: number;
  /**
   *
   * @type {number}
   * @memberof RobotMode
   */
  mode_request_id?: number;
}
/**
 *
 * @export
 * @interface Station
 */
export interface Station {
  /**
   *
   * @type {string}
   * @memberof Station
   */
  task_id?: string;
  /**
   *
   * @type {string}
   * @memberof Station
   */
  robot_type?: string;
  /**
   *
   * @type {string}
   * @memberof Station
   */
  place_name?: string;
}
/**
 *
 * @export
 * @interface SubmitTask
 */
export interface SubmitTask {
  /**
   *
   * @type {TaskTypeEnum}
   * @memberof SubmitTask
   */
  task_type: TaskTypeEnum;
  /**
   *
   * @type {number}
   * @memberof SubmitTask
   */
  start_time: number;
  /**
   *
   * @type {number}
   * @memberof SubmitTask
   */
  priority?: number;
  /**
   *
   * @type {CleanTaskDescription | LoopTaskDescription | DeliveryTaskDescription}
   * @memberof SubmitTask
   */
  description: CleanTaskDescription | LoopTaskDescription | DeliveryTaskDescription;
}
/**
 *
 * @export
 * @interface SubmitTaskResponse
 */
export interface SubmitTaskResponse {
  /**
   *
   * @type {string}
   * @memberof SubmitTaskResponse
   */
  task_id: string;
}
/**
 *
 * @export
 * @interface Task
 */
export interface Task {
  /**
   *
   * @type {string}
   * @memberof Task
   */
  task_id: string;
  /**
   *
   * @type {string}
   * @memberof Task
   */
  authz_grp?: string;
  /**
   *
   * @type {TaskSummary}
   * @memberof Task
   */
  summary: TaskSummary;
  /**
   *
   * @type {TaskProgress}
   * @memberof Task
   */
  progress: TaskProgress;
}
/**
 *
 * @export
 * @interface TaskDescription
 */
export interface TaskDescription {
  /**
   *
   * @type {Time}
   * @memberof TaskDescription
   */
  start_time?: Time;
  /**
   *
   * @type {Priority}
   * @memberof TaskDescription
   */
  priority?: Priority;
  /**
   *
   * @type {TaskType}
   * @memberof TaskDescription
   */
  task_type?: TaskType;
  /**
   *
   * @type {Station}
   * @memberof TaskDescription
   */
  station?: Station;
  /**
   *
   * @type {Loop}
   * @memberof TaskDescription
   */
  loop?: Loop;
  /**
   *
   * @type {Delivery}
   * @memberof TaskDescription
   */
  delivery?: Delivery;
  /**
   *
   * @type {Clean}
   * @memberof TaskDescription
   */
  clean?: Clean;
}
/**
 *
 * @export
 * @interface TaskProfile
 */
export interface TaskProfile {
  /**
   *
   * @type {string}
   * @memberof TaskProfile
   */
  task_id?: string;
  /**
   *
   * @type {Time}
   * @memberof TaskProfile
   */
  submission_time?: Time;
  /**
   *
   * @type {TaskDescription}
   * @memberof TaskProfile
   */
  description?: TaskDescription;
}
/**
 *
 * @export
 * @interface TaskProgress
 */
export interface TaskProgress {
  /**
   *
   * @type {string}
   * @memberof TaskProgress
   */
  status: string;
}
/**
 *
 * @export
 * @interface TaskSummary
 */
export interface TaskSummary {
  /**
   *
   * @type {string}
   * @memberof TaskSummary
   */
  fleet_name?: string;
  /**
   *
   * @type {string}
   * @memberof TaskSummary
   */
  task_id?: string;
  /**
   *
   * @type {TaskProfile}
   * @memberof TaskSummary
   */
  task_profile?: TaskProfile;
  /**
   *
   * @type {number}
   * @memberof TaskSummary
   */
  state?: number;
  /**
   *
   * @type {string}
   * @memberof TaskSummary
   */
  status?: string;
  /**
   *
   * @type {Time}
   * @memberof TaskSummary
   */
  submission_time?: Time;
  /**
   *
   * @type {Time}
   * @memberof TaskSummary
   */
  start_time?: Time;
  /**
   *
   * @type {Time}
   * @memberof TaskSummary
   */
  end_time?: Time;
  /**
   *
   * @type {string}
   * @memberof TaskSummary
   */
  robot_name?: string;
  /**
   *
   * @type {string}
   * @memberof TaskSummary
   */
  authz_grp?: string;
}
/**
 *
 * @export
 * @interface TaskType
 */
export interface TaskType {
  /**
   *
   * @type {number}
   * @memberof TaskType
   */
  type?: number;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export enum TaskTypeEnum {
  NUMBER_4 = 4,
  NUMBER_1 = 1,
  NUMBER_2 = 2,
}

/**
 *
 * @export
 * @interface Time
 */
export interface Time {
  /**
   *
   * @type {number}
   * @memberof Time
   */
  sec?: number;
  /**
   *
   * @type {number}
   * @memberof Time
   */
  nanosec?: number;
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {string}
   * @memberof User
   */
  username: string;
  /**
   *
   * @type {boolean}
   * @memberof User
   */
  is_admin?: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof User
   */
  roles?: Array<string>;
}
/**
 *
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
  /**
   *
   * @type {Array<string>}
   * @memberof ValidationError
   */
  loc: Array<string>;
  /**
   *
   * @type {string}
   * @memberof ValidationError
   */
  msg: string;
  /**
   *
   * @type {string}
   * @memberof ValidationError
   */
  type: string;
}

/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Add a permission to a role
     * @summary Add Role Permission
     * @param {string} role
     * @param {Permission} permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addRolePermissionAdminRolesRolePermissionsPost: async (
      role: string,
      permission: Permission,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'role' is not null or undefined
      assertParamExists('addRolePermissionAdminRolesRolePermissionsPost', 'role', role);
      // verify required parameter 'permission' is not null or undefined
      assertParamExists('addRolePermissionAdminRolesRolePermissionsPost', 'permission', permission);
      const localVarPath = `/admin/roles/{role}/permissions`.replace(
        `{${'role'}}`,
        encodeURIComponent(String(role)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        permission,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Add role to a user
     * @summary Add User Role
     * @param {string} username
     * @param {PostRoles} postRoles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUserRoleAdminUsersUsernameRolesPost: async (
      username: string,
      postRoles: PostRoles,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists('addUserRoleAdminUsersUsernameRolesPost', 'username', username);
      // verify required parameter 'postRoles' is not null or undefined
      assertParamExists('addUserRoleAdminUsersUsernameRolesPost', 'postRoles', postRoles);
      const localVarPath = `/admin/users/{username}/roles`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        postRoles,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a new role
     * @summary Create Role
     * @param {PostRoles} postRoles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRoleAdminRolesPost: async (
      postRoles: PostRoles,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'postRoles' is not null or undefined
      assertParamExists('createRoleAdminRolesPost', 'postRoles', postRoles);
      const localVarPath = `/admin/roles`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        postRoles,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a user
     * @summary Create User
     * @param {PostUsers} postUsers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUserAdminUsersPost: async (
      postUsers: PostUsers,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'postUsers' is not null or undefined
      assertParamExists('createUserAdminUsersPost', 'postUsers', postUsers);
      const localVarPath = `/admin/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        postUsers,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a role
     * @summary Delete Role
     * @param {string} role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRoleAdminRolesRoleDelete: async (
      role: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'role' is not null or undefined
      assertParamExists('deleteRoleAdminRolesRoleDelete', 'role', role);
      const localVarPath = `/admin/roles/{role}`.replace(
        `{${'role'}}`,
        encodeURIComponent(String(role)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a user  This only performs a soft delete, while the user is deleted from the app database, it still exists in the idp so they can still log in, the user will then be re-created with the default permissions.
     * @summary Delete User
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserAdminUsersUsernameDelete: async (
      username: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists('deleteUserAdminUsersUsernameDelete', 'username', username);
      const localVarPath = `/admin/users/{username}`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Remove role from a user
     * @summary Delete User Role
     * @param {string} username
     * @param {string} role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserRoleAdminUsersUsernameRolesRoleDelete: async (
      username: string,
      role: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists('deleteUserRoleAdminUsersUsernameRolesRoleDelete', 'username', username);
      // verify required parameter 'role' is not null or undefined
      assertParamExists('deleteUserRoleAdminUsersUsernameRolesRoleDelete', 'role', role);
      const localVarPath = `/admin/users/{username}/roles/{role}`
        .replace(`{${'username'}}`, encodeURIComponent(String(username)))
        .replace(`{${'role'}}`, encodeURIComponent(String(role)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get all permissions of a role
     * @summary Get Role Permissions
     * @param {string} role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRolePermissionsAdminRolesRolePermissionsGet: async (
      role: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'role' is not null or undefined
      assertParamExists('getRolePermissionsAdminRolesRolePermissionsGet', 'role', role);
      const localVarPath = `/admin/roles/{role}/permissions`.replace(
        `{${'role'}}`,
        encodeURIComponent(String(role)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get all roles
     * @summary Get Roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRolesAdminRolesGet: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/admin/roles`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a user
     * @summary Get User
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserAdminUsersUsernameGet: async (
      username: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists('getUserAdminUsersUsernameGet', 'username', username);
      const localVarPath = `/admin/users/{username}`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Search users
     * @summary Get Users
     * @param {string} [username] filters username that starts with the value
     * @param {boolean} [isAdmin]
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {string} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersAdminUsersGet: async (
      username?: string,
      isAdmin?: boolean,
      limit?: number,
      offset?: number,
      orderBy?: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/admin/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (username !== undefined) {
        localVarQueryParameter['username'] = username;
      }

      if (isAdmin !== undefined) {
        localVarQueryParameter['is_admin'] = isAdmin;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['order_by'] = orderBy;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Make or remove admin privilege from a user
     * @summary Make Admin
     * @param {string} username
     * @param {PostMakeAdmin} postMakeAdmin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    makeAdminAdminUsersUsernameMakeAdminPost: async (
      username: string,
      postMakeAdmin: PostMakeAdmin,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists('makeAdminAdminUsersUsernameMakeAdminPost', 'username', username);
      // verify required parameter 'postMakeAdmin' is not null or undefined
      assertParamExists('makeAdminAdminUsersUsernameMakeAdminPost', 'postMakeAdmin', postMakeAdmin);
      const localVarPath = `/admin/users/{username}/make_admin`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        postMakeAdmin,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a permission from a role
     * @summary Remove Role Permission
     * @param {string} role
     * @param {Permission} permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeRolePermissionAdminRolesRolePermissionsRemovePost: async (
      role: string,
      permission: Permission,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'role' is not null or undefined
      assertParamExists('removeRolePermissionAdminRolesRolePermissionsRemovePost', 'role', role);
      // verify required parameter 'permission' is not null or undefined
      assertParamExists(
        'removeRolePermissionAdminRolesRolePermissionsRemovePost',
        'permission',
        permission,
      );
      const localVarPath = `/admin/roles/{role}/permissions/remove`.replace(
        `{${'role'}}`,
        encodeURIComponent(String(role)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        permission,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Set the roles of a user
     * @summary Set User Roles
     * @param {string} username
     * @param {Array<PostRoles>} postRoles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserRolesAdminUsersUsernameRolesPut: async (
      username: string,
      postRoles: Array<PostRoles>,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists('setUserRolesAdminUsersUsernameRolesPut', 'username', username);
      // verify required parameter 'postRoles' is not null or undefined
      assertParamExists('setUserRolesAdminUsersUsernameRolesPut', 'postRoles', postRoles);
      const localVarPath = `/admin/users/{username}/roles`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        postRoles,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration);
  return {
    /**
     * Add a permission to a role
     * @summary Add Role Permission
     * @param {string} role
     * @param {Permission} permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addRolePermissionAdminRolesRolePermissionsPost(
      role: string,
      permission: Permission,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addRolePermissionAdminRolesRolePermissionsPost(
        role,
        permission,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Add role to a user
     * @summary Add User Role
     * @param {string} username
     * @param {PostRoles} postRoles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addUserRoleAdminUsersUsernameRolesPost(
      username: string,
      postRoles: PostRoles,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addUserRoleAdminUsersUsernameRolesPost(
        username,
        postRoles,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Create a new role
     * @summary Create Role
     * @param {PostRoles} postRoles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRoleAdminRolesPost(
      postRoles: PostRoles,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createRoleAdminRolesPost(
        postRoles,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Create a user
     * @summary Create User
     * @param {PostUsers} postUsers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createUserAdminUsersPost(
      postUsers: PostUsers,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createUserAdminUsersPost(
        postUsers,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Delete a role
     * @summary Delete Role
     * @param {string} role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteRoleAdminRolesRoleDelete(
      role: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRoleAdminRolesRoleDelete(
        role,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Delete a user  This only performs a soft delete, while the user is deleted from the app database, it still exists in the idp so they can still log in, the user will then be re-created with the default permissions.
     * @summary Delete User
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUserAdminUsersUsernameDelete(
      username: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserAdminUsersUsernameDelete(
        username,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Remove role from a user
     * @summary Delete User Role
     * @param {string} username
     * @param {string} role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUserRoleAdminUsersUsernameRolesRoleDelete(
      username: string,
      role: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserRoleAdminUsersUsernameRolesRoleDelete(
        username,
        role,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get all permissions of a role
     * @summary Get Role Permissions
     * @param {string} role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRolePermissionsAdminRolesRolePermissionsGet(
      role: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Permission>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRolePermissionsAdminRolesRolePermissionsGet(
        role,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get all roles
     * @summary Get Roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRolesAdminRolesGet(
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRolesAdminRolesGet(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get a user
     * @summary Get User
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserAdminUsersUsernameGet(
      username: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAdminUsersUsernameGet(
        username,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Search users
     * @summary Get Users
     * @param {string} [username] filters username that starts with the value
     * @param {boolean} [isAdmin]
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {string} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsersAdminUsersGet(
      username?: string,
      isAdmin?: boolean,
      limit?: number,
      offset?: number,
      orderBy?: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersAdminUsersGet(
        username,
        isAdmin,
        limit,
        offset,
        orderBy,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Make or remove admin privilege from a user
     * @summary Make Admin
     * @param {string} username
     * @param {PostMakeAdmin} postMakeAdmin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async makeAdminAdminUsersUsernameMakeAdminPost(
      username: string,
      postMakeAdmin: PostMakeAdmin,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.makeAdminAdminUsersUsernameMakeAdminPost(
        username,
        postMakeAdmin,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Delete a permission from a role
     * @summary Remove Role Permission
     * @param {string} role
     * @param {Permission} permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeRolePermissionAdminRolesRolePermissionsRemovePost(
      role: string,
      permission: Permission,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeRolePermissionAdminRolesRolePermissionsRemovePost(
        role,
        permission,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Set the roles of a user
     * @summary Set User Roles
     * @param {string} username
     * @param {Array<PostRoles>} postRoles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setUserRolesAdminUsersUsernameRolesPut(
      username: string,
      postRoles: Array<PostRoles>,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setUserRolesAdminUsersUsernameRolesPut(
        username,
        postRoles,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AdminApiFp(configuration);
  return {
    /**
     * Add a permission to a role
     * @summary Add Role Permission
     * @param {string} role
     * @param {Permission} permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addRolePermissionAdminRolesRolePermissionsPost(
      role: string,
      permission: Permission,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .addRolePermissionAdminRolesRolePermissionsPost(role, permission, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Add role to a user
     * @summary Add User Role
     * @param {string} username
     * @param {PostRoles} postRoles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUserRoleAdminUsersUsernameRolesPost(
      username: string,
      postRoles: PostRoles,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .addUserRoleAdminUsersUsernameRolesPost(username, postRoles, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a new role
     * @summary Create Role
     * @param {PostRoles} postRoles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRoleAdminRolesPost(postRoles: PostRoles, options?: any): AxiosPromise<any> {
      return localVarFp
        .createRoleAdminRolesPost(postRoles, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a user
     * @summary Create User
     * @param {PostUsers} postUsers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUserAdminUsersPost(postUsers: PostUsers, options?: any): AxiosPromise<any> {
      return localVarFp
        .createUserAdminUsersPost(postUsers, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete a role
     * @summary Delete Role
     * @param {string} role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRoleAdminRolesRoleDelete(role: string, options?: any): AxiosPromise<any> {
      return localVarFp
        .deleteRoleAdminRolesRoleDelete(role, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete a user  This only performs a soft delete, while the user is deleted from the app database, it still exists in the idp so they can still log in, the user will then be re-created with the default permissions.
     * @summary Delete User
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserAdminUsersUsernameDelete(username: string, options?: any): AxiosPromise<any> {
      return localVarFp
        .deleteUserAdminUsersUsernameDelete(username, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Remove role from a user
     * @summary Delete User Role
     * @param {string} username
     * @param {string} role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserRoleAdminUsersUsernameRolesRoleDelete(
      username: string,
      role: string,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .deleteUserRoleAdminUsersUsernameRolesRoleDelete(username, role, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get all permissions of a role
     * @summary Get Role Permissions
     * @param {string} role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRolePermissionsAdminRolesRolePermissionsGet(
      role: string,
      options?: any,
    ): AxiosPromise<Array<Permission>> {
      return localVarFp
        .getRolePermissionsAdminRolesRolePermissionsGet(role, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get all roles
     * @summary Get Roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRolesAdminRolesGet(options?: any): AxiosPromise<Array<string>> {
      return localVarFp.getRolesAdminRolesGet(options).then((request) => request(axios, basePath));
    },
    /**
     * Get a user
     * @summary Get User
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserAdminUsersUsernameGet(username: string, options?: any): AxiosPromise<User> {
      return localVarFp
        .getUserAdminUsersUsernameGet(username, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Search users
     * @summary Get Users
     * @param {string} [username] filters username that starts with the value
     * @param {boolean} [isAdmin]
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {string} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersAdminUsersGet(
      username?: string,
      isAdmin?: boolean,
      limit?: number,
      offset?: number,
      orderBy?: string,
      options?: any,
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .getUsersAdminUsersGet(username, isAdmin, limit, offset, orderBy, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Make or remove admin privilege from a user
     * @summary Make Admin
     * @param {string} username
     * @param {PostMakeAdmin} postMakeAdmin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    makeAdminAdminUsersUsernameMakeAdminPost(
      username: string,
      postMakeAdmin: PostMakeAdmin,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .makeAdminAdminUsersUsernameMakeAdminPost(username, postMakeAdmin, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete a permission from a role
     * @summary Remove Role Permission
     * @param {string} role
     * @param {Permission} permission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeRolePermissionAdminRolesRolePermissionsRemovePost(
      role: string,
      permission: Permission,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .removeRolePermissionAdminRolesRolePermissionsRemovePost(role, permission, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Set the roles of a user
     * @summary Set User Roles
     * @param {string} username
     * @param {Array<PostRoles>} postRoles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserRolesAdminUsersUsernameRolesPut(
      username: string,
      postRoles: Array<PostRoles>,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .setUserRolesAdminUsersUsernameRolesPut(username, postRoles, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
  /**
   * Add a permission to a role
   * @summary Add Role Permission
   * @param {string} role
   * @param {Permission} permission
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public addRolePermissionAdminRolesRolePermissionsPost(
    role: string,
    permission: Permission,
    options?: any,
  ) {
    return AdminApiFp(this.configuration)
      .addRolePermissionAdminRolesRolePermissionsPost(role, permission, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Add role to a user
   * @summary Add User Role
   * @param {string} username
   * @param {PostRoles} postRoles
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public addUserRoleAdminUsersUsernameRolesPost(
    username: string,
    postRoles: PostRoles,
    options?: any,
  ) {
    return AdminApiFp(this.configuration)
      .addUserRoleAdminUsersUsernameRolesPost(username, postRoles, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a new role
   * @summary Create Role
   * @param {PostRoles} postRoles
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public createRoleAdminRolesPost(postRoles: PostRoles, options?: any) {
    return AdminApiFp(this.configuration)
      .createRoleAdminRolesPost(postRoles, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a user
   * @summary Create User
   * @param {PostUsers} postUsers
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public createUserAdminUsersPost(postUsers: PostUsers, options?: any) {
    return AdminApiFp(this.configuration)
      .createUserAdminUsersPost(postUsers, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete a role
   * @summary Delete Role
   * @param {string} role
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public deleteRoleAdminRolesRoleDelete(role: string, options?: any) {
    return AdminApiFp(this.configuration)
      .deleteRoleAdminRolesRoleDelete(role, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete a user  This only performs a soft delete, while the user is deleted from the app database, it still exists in the idp so they can still log in, the user will then be re-created with the default permissions.
   * @summary Delete User
   * @param {string} username
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public deleteUserAdminUsersUsernameDelete(username: string, options?: any) {
    return AdminApiFp(this.configuration)
      .deleteUserAdminUsersUsernameDelete(username, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Remove role from a user
   * @summary Delete User Role
   * @param {string} username
   * @param {string} role
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public deleteUserRoleAdminUsersUsernameRolesRoleDelete(
    username: string,
    role: string,
    options?: any,
  ) {
    return AdminApiFp(this.configuration)
      .deleteUserRoleAdminUsersUsernameRolesRoleDelete(username, role, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get all permissions of a role
   * @summary Get Role Permissions
   * @param {string} role
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public getRolePermissionsAdminRolesRolePermissionsGet(role: string, options?: any) {
    return AdminApiFp(this.configuration)
      .getRolePermissionsAdminRolesRolePermissionsGet(role, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get all roles
   * @summary Get Roles
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public getRolesAdminRolesGet(options?: any) {
    return AdminApiFp(this.configuration)
      .getRolesAdminRolesGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a user
   * @summary Get User
   * @param {string} username
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public getUserAdminUsersUsernameGet(username: string, options?: any) {
    return AdminApiFp(this.configuration)
      .getUserAdminUsersUsernameGet(username, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Search users
   * @summary Get Users
   * @param {string} [username] filters username that starts with the value
   * @param {boolean} [isAdmin]
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {string} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public getUsersAdminUsersGet(
    username?: string,
    isAdmin?: boolean,
    limit?: number,
    offset?: number,
    orderBy?: string,
    options?: any,
  ) {
    return AdminApiFp(this.configuration)
      .getUsersAdminUsersGet(username, isAdmin, limit, offset, orderBy, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Make or remove admin privilege from a user
   * @summary Make Admin
   * @param {string} username
   * @param {PostMakeAdmin} postMakeAdmin
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public makeAdminAdminUsersUsernameMakeAdminPost(
    username: string,
    postMakeAdmin: PostMakeAdmin,
    options?: any,
  ) {
    return AdminApiFp(this.configuration)
      .makeAdminAdminUsersUsernameMakeAdminPost(username, postMakeAdmin, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete a permission from a role
   * @summary Remove Role Permission
   * @param {string} role
   * @param {Permission} permission
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public removeRolePermissionAdminRolesRolePermissionsRemovePost(
    role: string,
    permission: Permission,
    options?: any,
  ) {
    return AdminApiFp(this.configuration)
      .removeRolePermissionAdminRolesRolePermissionsRemovePost(role, permission, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Set the roles of a user
   * @summary Set User Roles
   * @param {string} username
   * @param {Array<PostRoles>} postRoles
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public setUserRolesAdminUsersUsernameRolesPut(
    username: string,
    postRoles: Array<PostRoles>,
    options?: any,
  ) {
    return AdminApiFp(this.configuration)
      .setUserRolesAdminUsersUsernameRolesPut(username, postRoles, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * BuildingApi - axios parameter creator
 * @export
 */
export const BuildingApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Available in socket.io
     * @summary Get Building Map
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildingMapBuildingMapGet: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/building_map`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * BuildingApi - functional programming interface
 * @export
 */
export const BuildingApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = BuildingApiAxiosParamCreator(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Building Map
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBuildingMapBuildingMapGet(
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BuildingMap>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBuildingMapBuildingMapGet(
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * BuildingApi - factory interface
 * @export
 */
export const BuildingApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = BuildingApiFp(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Building Map
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildingMapBuildingMapGet(options?: any): AxiosPromise<BuildingMap> {
      return localVarFp
        .getBuildingMapBuildingMapGet(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * BuildingApi - object-oriented interface
 * @export
 * @class BuildingApi
 * @extends {BaseAPI}
 */
export class BuildingApi extends BaseAPI {
  /**
   * Available in socket.io
   * @summary Get Building Map
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildingApi
   */
  public getBuildingMapBuildingMapGet(options?: any) {
    return BuildingApiFp(this.configuration)
      .getBuildingMapBuildingMapGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Get the effective permissions of the current user
     * @summary Get Effective Permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEffectivePermissionsPermissionsGet: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/permissions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the currently logged in user
     * @summary Get User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserUserGet: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/user`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration);
  return {
    /**
     * Get the effective permissions of the current user
     * @summary Get Effective Permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEffectivePermissionsPermissionsGet(
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Permission>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEffectivePermissionsPermissionsGet(
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get the currently logged in user
     * @summary Get User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserUserGet(
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserUserGet(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DefaultApiFp(configuration);
  return {
    /**
     * Get the effective permissions of the current user
     * @summary Get Effective Permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEffectivePermissionsPermissionsGet(options?: any): AxiosPromise<Array<Permission>> {
      return localVarFp
        .getEffectivePermissionsPermissionsGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get the currently logged in user
     * @summary Get User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserUserGet(options?: any): AxiosPromise<User> {
      return localVarFp.getUserUserGet(options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   * Get the effective permissions of the current user
   * @summary Get Effective Permissions
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getEffectivePermissionsPermissionsGet(options?: any) {
    return DefaultApiFp(this.configuration)
      .getEffectivePermissionsPermissionsGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get the currently logged in user
   * @summary Get User
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getUserUserGet(options?: any) {
    return DefaultApiFp(this.configuration)
      .getUserUserGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * DispensersApi - axios parameter creator
 * @export
 */
export const DispensersApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Available in socket.io
     * @summary Get Dispenser Health
     * @param {string} guid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDispenserHealthDispensersGuidHealthGet: async (
      guid: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guid' is not null or undefined
      assertParamExists('getDispenserHealthDispensersGuidHealthGet', 'guid', guid);
      const localVarPath = `/dispensers/{guid}/health`.replace(
        `{${'guid'}}`,
        encodeURIComponent(String(guid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Available in socket.io
     * @summary Get Dispenser State
     * @param {string} guid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDispenserStateDispensersGuidStateGet: async (
      guid: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guid' is not null or undefined
      assertParamExists('getDispenserStateDispensersGuidStateGet', 'guid', guid);
      const localVarPath = `/dispensers/{guid}/state`.replace(
        `{${'guid'}}`,
        encodeURIComponent(String(guid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Dispensers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDispensersDispensersGet: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/dispensers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DispensersApi - functional programming interface
 * @export
 */
export const DispensersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DispensersApiAxiosParamCreator(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Dispenser Health
     * @param {string} guid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDispenserHealthDispensersGuidHealthGet(
      guid: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DispenserHealth>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDispenserHealthDispensersGuidHealthGet(
        guid,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Available in socket.io
     * @summary Get Dispenser State
     * @param {string} guid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDispenserStateDispensersGuidStateGet(
      guid: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DispenserState>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDispenserStateDispensersGuidStateGet(
        guid,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get Dispensers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDispensersDispensersGet(
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dispenser>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDispensersDispensersGet(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * DispensersApi - factory interface
 * @export
 */
export const DispensersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DispensersApiFp(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Dispenser Health
     * @param {string} guid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDispenserHealthDispensersGuidHealthGet(
      guid: string,
      options?: any,
    ): AxiosPromise<DispenserHealth> {
      return localVarFp
        .getDispenserHealthDispensersGuidHealthGet(guid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Available in socket.io
     * @summary Get Dispenser State
     * @param {string} guid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDispenserStateDispensersGuidStateGet(
      guid: string,
      options?: any,
    ): AxiosPromise<DispenserState> {
      return localVarFp
        .getDispenserStateDispensersGuidStateGet(guid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Dispensers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDispensersDispensersGet(options?: any): AxiosPromise<Array<Dispenser>> {
      return localVarFp
        .getDispensersDispensersGet(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * DispensersApi - object-oriented interface
 * @export
 * @class DispensersApi
 * @extends {BaseAPI}
 */
export class DispensersApi extends BaseAPI {
  /**
   * Available in socket.io
   * @summary Get Dispenser Health
   * @param {string} guid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DispensersApi
   */
  public getDispenserHealthDispensersGuidHealthGet(guid: string, options?: any) {
    return DispensersApiFp(this.configuration)
      .getDispenserHealthDispensersGuidHealthGet(guid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Available in socket.io
   * @summary Get Dispenser State
   * @param {string} guid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DispensersApi
   */
  public getDispenserStateDispensersGuidStateGet(guid: string, options?: any) {
    return DispensersApiFp(this.configuration)
      .getDispenserStateDispensersGuidStateGet(guid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Dispensers
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DispensersApi
   */
  public getDispensersDispensersGet(options?: any) {
    return DispensersApiFp(this.configuration)
      .getDispensersDispensersGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * DoorsApi - axios parameter creator
 * @export
 */
export const DoorsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Available in socket.io
     * @summary Get Door Health
     * @param {string} doorName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDoorHealthDoorsDoorNameHealthGet: async (
      doorName: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'doorName' is not null or undefined
      assertParamExists('getDoorHealthDoorsDoorNameHealthGet', 'doorName', doorName);
      const localVarPath = `/doors/{door_name}/health`.replace(
        `{${'door_name'}}`,
        encodeURIComponent(String(doorName)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Available in socket.io
     * @summary Get Door State
     * @param {string} doorName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDoorStateDoorsDoorNameStateGet: async (
      doorName: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'doorName' is not null or undefined
      assertParamExists('getDoorStateDoorsDoorNameStateGet', 'doorName', doorName);
      const localVarPath = `/doors/{door_name}/state`.replace(
        `{${'door_name'}}`,
        encodeURIComponent(String(doorName)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Doors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDoorsDoorsGet: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/doors`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post Door Request
     * @param {string} doorName
     * @param {DoorRequest} doorRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postDoorRequestDoorsDoorNameRequestPost: async (
      doorName: string,
      doorRequest: DoorRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'doorName' is not null or undefined
      assertParamExists('postDoorRequestDoorsDoorNameRequestPost', 'doorName', doorName);
      // verify required parameter 'doorRequest' is not null or undefined
      assertParamExists('postDoorRequestDoorsDoorNameRequestPost', 'doorRequest', doorRequest);
      const localVarPath = `/doors/{door_name}/request`.replace(
        `{${'door_name'}}`,
        encodeURIComponent(String(doorName)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        doorRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DoorsApi - functional programming interface
 * @export
 */
export const DoorsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DoorsApiAxiosParamCreator(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Door Health
     * @param {string} doorName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDoorHealthDoorsDoorNameHealthGet(
      doorName: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DoorHealth>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDoorHealthDoorsDoorNameHealthGet(
        doorName,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Available in socket.io
     * @summary Get Door State
     * @param {string} doorName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDoorStateDoorsDoorNameStateGet(
      doorName: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DoorState>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDoorStateDoorsDoorNameStateGet(
        doorName,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get Doors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDoorsDoorsGet(
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Door>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDoorsDoorsGet(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Post Door Request
     * @param {string} doorName
     * @param {DoorRequest} doorRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postDoorRequestDoorsDoorNameRequestPost(
      doorName: string,
      doorRequest: DoorRequest,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postDoorRequestDoorsDoorNameRequestPost(
        doorName,
        doorRequest,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * DoorsApi - factory interface
 * @export
 */
export const DoorsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DoorsApiFp(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Door Health
     * @param {string} doorName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDoorHealthDoorsDoorNameHealthGet(doorName: string, options?: any): AxiosPromise<DoorHealth> {
      return localVarFp
        .getDoorHealthDoorsDoorNameHealthGet(doorName, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Available in socket.io
     * @summary Get Door State
     * @param {string} doorName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDoorStateDoorsDoorNameStateGet(doorName: string, options?: any): AxiosPromise<DoorState> {
      return localVarFp
        .getDoorStateDoorsDoorNameStateGet(doorName, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Doors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDoorsDoorsGet(options?: any): AxiosPromise<Array<Door>> {
      return localVarFp.getDoorsDoorsGet(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Post Door Request
     * @param {string} doorName
     * @param {DoorRequest} doorRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postDoorRequestDoorsDoorNameRequestPost(
      doorName: string,
      doorRequest: DoorRequest,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .postDoorRequestDoorsDoorNameRequestPost(doorName, doorRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * DoorsApi - object-oriented interface
 * @export
 * @class DoorsApi
 * @extends {BaseAPI}
 */
export class DoorsApi extends BaseAPI {
  /**
   * Available in socket.io
   * @summary Get Door Health
   * @param {string} doorName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DoorsApi
   */
  public getDoorHealthDoorsDoorNameHealthGet(doorName: string, options?: any) {
    return DoorsApiFp(this.configuration)
      .getDoorHealthDoorsDoorNameHealthGet(doorName, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Available in socket.io
   * @summary Get Door State
   * @param {string} doorName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DoorsApi
   */
  public getDoorStateDoorsDoorNameStateGet(doorName: string, options?: any) {
    return DoorsApiFp(this.configuration)
      .getDoorStateDoorsDoorNameStateGet(doorName, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Doors
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DoorsApi
   */
  public getDoorsDoorsGet(options?: any) {
    return DoorsApiFp(this.configuration)
      .getDoorsDoorsGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Post Door Request
   * @param {string} doorName
   * @param {DoorRequest} doorRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DoorsApi
   */
  public postDoorRequestDoorsDoorNameRequestPost(
    doorName: string,
    doorRequest: DoorRequest,
    options?: any,
  ) {
    return DoorsApiFp(this.configuration)
      .postDoorRequestDoorsDoorNameRequestPost(doorName, doorRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * FleetsApi - axios parameter creator
 * @export
 */
export const FleetsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Available in socket.io
     * @summary Get Fleet State
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFleetStateFleetsNameStateGet: async (
      name: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getFleetStateFleetsNameStateGet', 'name', name);
      const localVarPath = `/fleets/{name}/state`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Fleets
     * @param {string} [fleetName] comma separated list of fleet names
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {string} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFleetsFleetsGet: async (
      fleetName?: string,
      limit?: number,
      offset?: number,
      orderBy?: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/fleets`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (fleetName !== undefined) {
        localVarQueryParameter['fleet_name'] = fleetName;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['order_by'] = orderBy;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Available in socket.io
     * @summary Get Robot Health
     * @param {string} fleet
     * @param {string} robot
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRobotHealthFleetsFleetRobotHealthGet: async (
      fleet: string,
      robot: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'fleet' is not null or undefined
      assertParamExists('getRobotHealthFleetsFleetRobotHealthGet', 'fleet', fleet);
      // verify required parameter 'robot' is not null or undefined
      assertParamExists('getRobotHealthFleetsFleetRobotHealthGet', 'robot', robot);
      const localVarPath = `/fleets/{fleet}/{robot}/health`
        .replace(`{${'fleet'}}`, encodeURIComponent(String(fleet)))
        .replace(`{${'robot'}}`, encodeURIComponent(String(robot)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Robots
     * @param {string} [fleetName] comma separated list of fleet names
     * @param {string} [robotName] comma separated list of robot names
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {string} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRobotsFleetsRobotsGet: async (
      fleetName?: string,
      robotName?: string,
      limit?: number,
      offset?: number,
      orderBy?: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/fleets/robots`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (fleetName !== undefined) {
        localVarQueryParameter['fleet_name'] = fleetName;
      }

      if (robotName !== undefined) {
        localVarQueryParameter['robot_name'] = robotName;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['order_by'] = orderBy;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FleetsApi - functional programming interface
 * @export
 */
export const FleetsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FleetsApiAxiosParamCreator(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Fleet State
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFleetStateFleetsNameStateGet(
      name: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FleetState>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFleetStateFleetsNameStateGet(
        name,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get Fleets
     * @param {string} [fleetName] comma separated list of fleet names
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {string} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFleetsFleetsGet(
      fleetName?: string,
      limit?: number,
      offset?: number,
      orderBy?: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Fleet>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFleetsFleetsGet(
        fleetName,
        limit,
        offset,
        orderBy,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Available in socket.io
     * @summary Get Robot Health
     * @param {string} fleet
     * @param {string} robot
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRobotHealthFleetsFleetRobotHealthGet(
      fleet: string,
      robot: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RobotHealth>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRobotHealthFleetsFleetRobotHealthGet(
        fleet,
        robot,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get Robots
     * @param {string} [fleetName] comma separated list of fleet names
     * @param {string} [robotName] comma separated list of robot names
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {string} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRobotsFleetsRobotsGet(
      fleetName?: string,
      robotName?: string,
      limit?: number,
      offset?: number,
      orderBy?: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Robot>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRobotsFleetsRobotsGet(
        fleetName,
        robotName,
        limit,
        offset,
        orderBy,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * FleetsApi - factory interface
 * @export
 */
export const FleetsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = FleetsApiFp(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Fleet State
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFleetStateFleetsNameStateGet(name: string, options?: any): AxiosPromise<FleetState> {
      return localVarFp
        .getFleetStateFleetsNameStateGet(name, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Fleets
     * @param {string} [fleetName] comma separated list of fleet names
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {string} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFleetsFleetsGet(
      fleetName?: string,
      limit?: number,
      offset?: number,
      orderBy?: string,
      options?: any,
    ): AxiosPromise<Array<Fleet>> {
      return localVarFp
        .getFleetsFleetsGet(fleetName, limit, offset, orderBy, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Available in socket.io
     * @summary Get Robot Health
     * @param {string} fleet
     * @param {string} robot
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRobotHealthFleetsFleetRobotHealthGet(
      fleet: string,
      robot: string,
      options?: any,
    ): AxiosPromise<RobotHealth> {
      return localVarFp
        .getRobotHealthFleetsFleetRobotHealthGet(fleet, robot, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Robots
     * @param {string} [fleetName] comma separated list of fleet names
     * @param {string} [robotName] comma separated list of robot names
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {string} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRobotsFleetsRobotsGet(
      fleetName?: string,
      robotName?: string,
      limit?: number,
      offset?: number,
      orderBy?: string,
      options?: any,
    ): AxiosPromise<Array<Robot>> {
      return localVarFp
        .getRobotsFleetsRobotsGet(fleetName, robotName, limit, offset, orderBy, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * FleetsApi - object-oriented interface
 * @export
 * @class FleetsApi
 * @extends {BaseAPI}
 */
export class FleetsApi extends BaseAPI {
  /**
   * Available in socket.io
   * @summary Get Fleet State
   * @param {string} name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetsApi
   */
  public getFleetStateFleetsNameStateGet(name: string, options?: any) {
    return FleetsApiFp(this.configuration)
      .getFleetStateFleetsNameStateGet(name, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Fleets
   * @param {string} [fleetName] comma separated list of fleet names
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {string} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetsApi
   */
  public getFleetsFleetsGet(
    fleetName?: string,
    limit?: number,
    offset?: number,
    orderBy?: string,
    options?: any,
  ) {
    return FleetsApiFp(this.configuration)
      .getFleetsFleetsGet(fleetName, limit, offset, orderBy, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Available in socket.io
   * @summary Get Robot Health
   * @param {string} fleet
   * @param {string} robot
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetsApi
   */
  public getRobotHealthFleetsFleetRobotHealthGet(fleet: string, robot: string, options?: any) {
    return FleetsApiFp(this.configuration)
      .getRobotHealthFleetsFleetRobotHealthGet(fleet, robot, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Robots
   * @param {string} [fleetName] comma separated list of fleet names
   * @param {string} [robotName] comma separated list of robot names
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {string} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetsApi
   */
  public getRobotsFleetsRobotsGet(
    fleetName?: string,
    robotName?: string,
    limit?: number,
    offset?: number,
    orderBy?: string,
    options?: any,
  ) {
    return FleetsApiFp(this.configuration)
      .getRobotsFleetsRobotsGet(fleetName, robotName, limit, offset, orderBy, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * IngestorsApi - axios parameter creator
 * @export
 */
export const IngestorsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Available in socket.io
     * @summary Get Ingestor Health
     * @param {string} guid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIngestorHealthIngestorsGuidHealthGet: async (
      guid: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guid' is not null or undefined
      assertParamExists('getIngestorHealthIngestorsGuidHealthGet', 'guid', guid);
      const localVarPath = `/ingestors/{guid}/health`.replace(
        `{${'guid'}}`,
        encodeURIComponent(String(guid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Available in socket.io
     * @summary Get Ingestor State
     * @param {string} guid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIngestorStateIngestorsGuidStateGet: async (
      guid: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guid' is not null or undefined
      assertParamExists('getIngestorStateIngestorsGuidStateGet', 'guid', guid);
      const localVarPath = `/ingestors/{guid}/state`.replace(
        `{${'guid'}}`,
        encodeURIComponent(String(guid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Ingestors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIngestorsIngestorsGet: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/ingestors`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * IngestorsApi - functional programming interface
 * @export
 */
export const IngestorsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = IngestorsApiAxiosParamCreator(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Ingestor Health
     * @param {string} guid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getIngestorHealthIngestorsGuidHealthGet(
      guid: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IngestorHealth>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getIngestorHealthIngestorsGuidHealthGet(
        guid,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Available in socket.io
     * @summary Get Ingestor State
     * @param {string} guid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getIngestorStateIngestorsGuidStateGet(
      guid: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IngestorState>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getIngestorStateIngestorsGuidStateGet(
        guid,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get Ingestors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getIngestorsIngestorsGet(
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Ingestor>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getIngestorsIngestorsGet(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * IngestorsApi - factory interface
 * @export
 */
export const IngestorsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = IngestorsApiFp(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Ingestor Health
     * @param {string} guid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIngestorHealthIngestorsGuidHealthGet(
      guid: string,
      options?: any,
    ): AxiosPromise<IngestorHealth> {
      return localVarFp
        .getIngestorHealthIngestorsGuidHealthGet(guid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Available in socket.io
     * @summary Get Ingestor State
     * @param {string} guid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIngestorStateIngestorsGuidStateGet(
      guid: string,
      options?: any,
    ): AxiosPromise<IngestorState> {
      return localVarFp
        .getIngestorStateIngestorsGuidStateGet(guid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Ingestors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIngestorsIngestorsGet(options?: any): AxiosPromise<Array<Ingestor>> {
      return localVarFp
        .getIngestorsIngestorsGet(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * IngestorsApi - object-oriented interface
 * @export
 * @class IngestorsApi
 * @extends {BaseAPI}
 */
export class IngestorsApi extends BaseAPI {
  /**
   * Available in socket.io
   * @summary Get Ingestor Health
   * @param {string} guid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IngestorsApi
   */
  public getIngestorHealthIngestorsGuidHealthGet(guid: string, options?: any) {
    return IngestorsApiFp(this.configuration)
      .getIngestorHealthIngestorsGuidHealthGet(guid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Available in socket.io
   * @summary Get Ingestor State
   * @param {string} guid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IngestorsApi
   */
  public getIngestorStateIngestorsGuidStateGet(guid: string, options?: any) {
    return IngestorsApiFp(this.configuration)
      .getIngestorStateIngestorsGuidStateGet(guid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Ingestors
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IngestorsApi
   */
  public getIngestorsIngestorsGet(options?: any) {
    return IngestorsApiFp(this.configuration)
      .getIngestorsIngestorsGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * LiftsApi - axios parameter creator
 * @export
 */
export const LiftsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Available in socket.io
     * @summary Get Lift Health
     * @param {string} liftName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLiftHealthLiftsLiftNameHealthGet: async (
      liftName: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'liftName' is not null or undefined
      assertParamExists('getLiftHealthLiftsLiftNameHealthGet', 'liftName', liftName);
      const localVarPath = `/lifts/{lift_name}/health`.replace(
        `{${'lift_name'}}`,
        encodeURIComponent(String(liftName)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Available in socket.io
     * @summary Get Lift State
     * @param {string} liftName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLiftStateLiftsLiftNameStateGet: async (
      liftName: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'liftName' is not null or undefined
      assertParamExists('getLiftStateLiftsLiftNameStateGet', 'liftName', liftName);
      const localVarPath = `/lifts/{lift_name}/state`.replace(
        `{${'lift_name'}}`,
        encodeURIComponent(String(liftName)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Lifts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLiftsLiftsGet: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/lifts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary  Post Lift Request
     * @param {string} liftName
     * @param {LiftRequest} liftRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postLiftRequestLiftsLiftNameRequestPost: async (
      liftName: string,
      liftRequest: LiftRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'liftName' is not null or undefined
      assertParamExists('postLiftRequestLiftsLiftNameRequestPost', 'liftName', liftName);
      // verify required parameter 'liftRequest' is not null or undefined
      assertParamExists('postLiftRequestLiftsLiftNameRequestPost', 'liftRequest', liftRequest);
      const localVarPath = `/lifts/{lift_name}/request`.replace(
        `{${'lift_name'}}`,
        encodeURIComponent(String(liftName)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        liftRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LiftsApi - functional programming interface
 * @export
 */
export const LiftsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = LiftsApiAxiosParamCreator(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Lift Health
     * @param {string} liftName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLiftHealthLiftsLiftNameHealthGet(
      liftName: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiftHealth>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLiftHealthLiftsLiftNameHealthGet(
        liftName,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Available in socket.io
     * @summary Get Lift State
     * @param {string} liftName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLiftStateLiftsLiftNameStateGet(
      liftName: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiftState>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLiftStateLiftsLiftNameStateGet(
        liftName,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get Lifts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLiftsLiftsGet(
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Lift>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLiftsLiftsGet(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary  Post Lift Request
     * @param {string} liftName
     * @param {LiftRequest} liftRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postLiftRequestLiftsLiftNameRequestPost(
      liftName: string,
      liftRequest: LiftRequest,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postLiftRequestLiftsLiftNameRequestPost(
        liftName,
        liftRequest,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * LiftsApi - factory interface
 * @export
 */
export const LiftsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = LiftsApiFp(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Lift Health
     * @param {string} liftName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLiftHealthLiftsLiftNameHealthGet(liftName: string, options?: any): AxiosPromise<LiftHealth> {
      return localVarFp
        .getLiftHealthLiftsLiftNameHealthGet(liftName, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Available in socket.io
     * @summary Get Lift State
     * @param {string} liftName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLiftStateLiftsLiftNameStateGet(liftName: string, options?: any): AxiosPromise<LiftState> {
      return localVarFp
        .getLiftStateLiftsLiftNameStateGet(liftName, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Lifts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLiftsLiftsGet(options?: any): AxiosPromise<Array<Lift>> {
      return localVarFp.getLiftsLiftsGet(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary  Post Lift Request
     * @param {string} liftName
     * @param {LiftRequest} liftRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postLiftRequestLiftsLiftNameRequestPost(
      liftName: string,
      liftRequest: LiftRequest,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .postLiftRequestLiftsLiftNameRequestPost(liftName, liftRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * LiftsApi - object-oriented interface
 * @export
 * @class LiftsApi
 * @extends {BaseAPI}
 */
export class LiftsApi extends BaseAPI {
  /**
   * Available in socket.io
   * @summary Get Lift Health
   * @param {string} liftName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LiftsApi
   */
  public getLiftHealthLiftsLiftNameHealthGet(liftName: string, options?: any) {
    return LiftsApiFp(this.configuration)
      .getLiftHealthLiftsLiftNameHealthGet(liftName, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Available in socket.io
   * @summary Get Lift State
   * @param {string} liftName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LiftsApi
   */
  public getLiftStateLiftsLiftNameStateGet(liftName: string, options?: any) {
    return LiftsApiFp(this.configuration)
      .getLiftStateLiftsLiftNameStateGet(liftName, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Lifts
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LiftsApi
   */
  public getLiftsLiftsGet(options?: any) {
    return LiftsApiFp(this.configuration)
      .getLiftsLiftsGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary  Post Lift Request
   * @param {string} liftName
   * @param {LiftRequest} liftRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LiftsApi
   */
  public postLiftRequestLiftsLiftNameRequestPost(
    liftName: string,
    liftRequest: LiftRequest,
    options?: any,
  ) {
    return LiftsApiFp(this.configuration)
      .postLiftRequestLiftsLiftNameRequestPost(liftName, liftRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TasksApi - axios parameter creator
 * @export
 */
export const TasksApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Cancel Task
     * @param {CancelTask} cancelTask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelTaskTasksCancelTaskPost: async (
      cancelTask: CancelTask,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'cancelTask' is not null or undefined
      assertParamExists('cancelTaskTasksCancelTaskPost', 'cancelTask', cancelTask);
      const localVarPath = `/tasks/cancel_task`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        cancelTask,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Available in socket.io
     * @summary Get Task Summary
     * @param {string} taskId task_id with \&#39;/\&#39; replaced with \&#39;__\&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskSummaryTasksTaskIdSummaryGet: async (
      taskId: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskId' is not null or undefined
      assertParamExists('getTaskSummaryTasksTaskIdSummaryGet', 'taskId', taskId);
      const localVarPath = `/tasks/{task_id}/summary`.replace(
        `{${'task_id'}}`,
        encodeURIComponent(String(taskId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Tasks
     * @param {string} [taskId] comma separated list of task ids
     * @param {string} [fleetName] comma separated list of fleet names
     * @param {string} [submissionTimeSince]
     * @param {string} [startTimeSince]
     * @param {string} [endTimeSince]
     * @param {string} [robotName] comma separated list of robot names
     * @param {string} [state] comma separated list of states
     * @param {string} [taskType] comma separated list of task types
     * @param {number} [priority]
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {string} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTasksTasksGet: async (
      taskId?: string,
      fleetName?: string,
      submissionTimeSince?: string,
      startTimeSince?: string,
      endTimeSince?: string,
      robotName?: string,
      state?: string,
      taskType?: string,
      priority?: number,
      limit?: number,
      offset?: number,
      orderBy?: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/tasks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (taskId !== undefined) {
        localVarQueryParameter['task_id'] = taskId;
      }

      if (fleetName !== undefined) {
        localVarQueryParameter['fleet_name'] = fleetName;
      }

      if (submissionTimeSince !== undefined) {
        localVarQueryParameter['submission_time_since'] =
          (submissionTimeSince as any) instanceof Date
            ? (submissionTimeSince as any).toISOString()
            : submissionTimeSince;
      }

      if (startTimeSince !== undefined) {
        localVarQueryParameter['start_time_since'] =
          (startTimeSince as any) instanceof Date
            ? (startTimeSince as any).toISOString()
            : startTimeSince;
      }

      if (endTimeSince !== undefined) {
        localVarQueryParameter['end_time_since'] =
          (endTimeSince as any) instanceof Date
            ? (endTimeSince as any).toISOString()
            : endTimeSince;
      }

      if (robotName !== undefined) {
        localVarQueryParameter['robot_name'] = robotName;
      }

      if (state !== undefined) {
        localVarQueryParameter['state'] = state;
      }

      if (taskType !== undefined) {
        localVarQueryParameter['task_type'] = taskType;
      }

      if (priority !== undefined) {
        localVarQueryParameter['priority'] = priority;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['order_by'] = orderBy;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Submit Task
     * @param {SubmitTask} submitTask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitTaskTasksSubmitTaskPost: async (
      submitTask: SubmitTask,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'submitTask' is not null or undefined
      assertParamExists('submitTaskTasksSubmitTaskPost', 'submitTask', submitTask);
      const localVarPath = `/tasks/submit_task`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        submitTask,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TasksApi - functional programming interface
 * @export
 */
export const TasksApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TasksApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Cancel Task
     * @param {CancelTask} cancelTask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cancelTaskTasksCancelTaskPost(
      cancelTask: CancelTask,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.cancelTaskTasksCancelTaskPost(
        cancelTask,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Available in socket.io
     * @summary Get Task Summary
     * @param {string} taskId task_id with \&#39;/\&#39; replaced with \&#39;__\&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTaskSummaryTasksTaskIdSummaryGet(
      taskId: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskSummary>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskSummaryTasksTaskIdSummaryGet(
        taskId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get Tasks
     * @param {string} [taskId] comma separated list of task ids
     * @param {string} [fleetName] comma separated list of fleet names
     * @param {string} [submissionTimeSince]
     * @param {string} [startTimeSince]
     * @param {string} [endTimeSince]
     * @param {string} [robotName] comma separated list of robot names
     * @param {string} [state] comma separated list of states
     * @param {string} [taskType] comma separated list of task types
     * @param {number} [priority]
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {string} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTasksTasksGet(
      taskId?: string,
      fleetName?: string,
      submissionTimeSince?: string,
      startTimeSince?: string,
      endTimeSince?: string,
      robotName?: string,
      state?: string,
      taskType?: string,
      priority?: number,
      limit?: number,
      offset?: number,
      orderBy?: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTasksTasksGet(
        taskId,
        fleetName,
        submissionTimeSince,
        startTimeSince,
        endTimeSince,
        robotName,
        state,
        taskType,
        priority,
        limit,
        offset,
        orderBy,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Submit Task
     * @param {SubmitTask} submitTask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async submitTaskTasksSubmitTaskPost(
      submitTask: SubmitTask,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmitTaskResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.submitTaskTasksSubmitTaskPost(
        submitTask,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * TasksApi - factory interface
 * @export
 */
export const TasksApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = TasksApiFp(configuration);
  return {
    /**
     *
     * @summary Cancel Task
     * @param {CancelTask} cancelTask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelTaskTasksCancelTaskPost(cancelTask: CancelTask, options?: any): AxiosPromise<any> {
      return localVarFp
        .cancelTaskTasksCancelTaskPost(cancelTask, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Available in socket.io
     * @summary Get Task Summary
     * @param {string} taskId task_id with \&#39;/\&#39; replaced with \&#39;__\&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskSummaryTasksTaskIdSummaryGet(taskId: string, options?: any): AxiosPromise<TaskSummary> {
      return localVarFp
        .getTaskSummaryTasksTaskIdSummaryGet(taskId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Tasks
     * @param {string} [taskId] comma separated list of task ids
     * @param {string} [fleetName] comma separated list of fleet names
     * @param {string} [submissionTimeSince]
     * @param {string} [startTimeSince]
     * @param {string} [endTimeSince]
     * @param {string} [robotName] comma separated list of robot names
     * @param {string} [state] comma separated list of states
     * @param {string} [taskType] comma separated list of task types
     * @param {number} [priority]
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {string} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTasksTasksGet(
      taskId?: string,
      fleetName?: string,
      submissionTimeSince?: string,
      startTimeSince?: string,
      endTimeSince?: string,
      robotName?: string,
      state?: string,
      taskType?: string,
      priority?: number,
      limit?: number,
      offset?: number,
      orderBy?: string,
      options?: any,
    ): AxiosPromise<Array<Task>> {
      return localVarFp
        .getTasksTasksGet(
          taskId,
          fleetName,
          submissionTimeSince,
          startTimeSince,
          endTimeSince,
          robotName,
          state,
          taskType,
          priority,
          limit,
          offset,
          orderBy,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Submit Task
     * @param {SubmitTask} submitTask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitTaskTasksSubmitTaskPost(
      submitTask: SubmitTask,
      options?: any,
    ): AxiosPromise<SubmitTaskResponse> {
      return localVarFp
        .submitTaskTasksSubmitTaskPost(submitTask, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
export class TasksApi extends BaseAPI {
  /**
   *
   * @summary Cancel Task
   * @param {CancelTask} cancelTask
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public cancelTaskTasksCancelTaskPost(cancelTask: CancelTask, options?: any) {
    return TasksApiFp(this.configuration)
      .cancelTaskTasksCancelTaskPost(cancelTask, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Available in socket.io
   * @summary Get Task Summary
   * @param {string} taskId task_id with \&#39;/\&#39; replaced with \&#39;__\&#39;
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public getTaskSummaryTasksTaskIdSummaryGet(taskId: string, options?: any) {
    return TasksApiFp(this.configuration)
      .getTaskSummaryTasksTaskIdSummaryGet(taskId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Tasks
   * @param {string} [taskId] comma separated list of task ids
   * @param {string} [fleetName] comma separated list of fleet names
   * @param {string} [submissionTimeSince]
   * @param {string} [startTimeSince]
   * @param {string} [endTimeSince]
   * @param {string} [robotName] comma separated list of robot names
   * @param {string} [state] comma separated list of states
   * @param {string} [taskType] comma separated list of task types
   * @param {number} [priority]
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {string} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public getTasksTasksGet(
    taskId?: string,
    fleetName?: string,
    submissionTimeSince?: string,
    startTimeSince?: string,
    endTimeSince?: string,
    robotName?: string,
    state?: string,
    taskType?: string,
    priority?: number,
    limit?: number,
    offset?: number,
    orderBy?: string,
    options?: any,
  ) {
    return TasksApiFp(this.configuration)
      .getTasksTasksGet(
        taskId,
        fleetName,
        submissionTimeSince,
        startTimeSince,
        endTimeSince,
        robotName,
        state,
        taskType,
        priority,
        limit,
        offset,
        orderBy,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Submit Task
   * @param {SubmitTask} submitTask
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public submitTaskTasksSubmitTaskPost(submitTask: SubmitTask, options?: any) {
    return TasksApiFp(this.configuration)
      .submitTaskTasksSubmitTaskPost(submitTask, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
