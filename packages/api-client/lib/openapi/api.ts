/* tslint:disable */
/* eslint-disable */
/**
 * RMF API Server
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 *
 * @export
 * @interface Activity
 */
export interface Activity {
  /**
   * The category of this activity. There must not be any duplicate activity categories per fleet.
   * @type {string}
   * @memberof Activity
   */
  category: string;
  /**
   * Details about the behavior of the activity.
   * @type {string}
   * @memberof Activity
   */
  detail: string;
  /**
   *
   * @type {object}
   * @memberof Activity
   */
  description_schema?: object | null;
}
/**
 *
 * @export
 * @interface ActivityDiscovery
 */
export interface ActivityDiscovery {
  /**
   *
   * @type {Array<Datum>}
   * @memberof ActivityDiscovery
   */
  data?: Array<Datum> | null;
}
/**
 *
 * @export
 * @interface ActivityDiscoveryRequest
 */
export interface ActivityDiscoveryRequest {
  /**
   * Indicate that this is an activity discovery request
   * @type {any}
   * @memberof ActivityDiscoveryRequest
   */
  type: any;
}
/**
 *
 * @export
 * @interface AffineImage
 */
export interface AffineImage {
  /**
   *
   * @type {string}
   * @memberof AffineImage
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof AffineImage
   */
  x_offset: number;
  /**
   *
   * @type {number}
   * @memberof AffineImage
   */
  y_offset: number;
  /**
   *
   * @type {number}
   * @memberof AffineImage
   */
  yaw: number;
  /**
   *
   * @type {number}
   * @memberof AffineImage
   */
  scale: number;
  /**
   *
   * @type {string}
   * @memberof AffineImage
   */
  encoding: string;
  /**
   *
   * @type {string}
   * @memberof AffineImage
   */
  data: string;
}
/**
 *
 * @export
 * @enum {string}
 */

export const ApiServerModelsRmfApiRobotStateStatus = {
  Uninitialized: 'uninitialized',
  Offline: 'offline',
  Shutdown: 'shutdown',
  Idle: 'idle',
  Charging: 'charging',
  Working: 'working',
  Error: 'error',
} as const;

export type ApiServerModelsRmfApiRobotStateStatus =
  (typeof ApiServerModelsRmfApiRobotStateStatus)[keyof typeof ApiServerModelsRmfApiRobotStateStatus];

/**
 *
 * @export
 * @enum {string}
 */

export const ApiServerModelsRmfApiTaskStateStatus = {
  Uninitialized: 'uninitialized',
  Blocked: 'blocked',
  Error: 'error',
  Failed: 'failed',
  Queued: 'queued',
  Standby: 'standby',
  Underway: 'underway',
  Delayed: 'delayed',
  Skipped: 'skipped',
  Canceled: 'canceled',
  Killed: 'killed',
  Completed: 'completed',
} as const;

export type ApiServerModelsRmfApiTaskStateStatus =
  (typeof ApiServerModelsRmfApiTaskStateStatus)[keyof typeof ApiServerModelsRmfApiTaskStateStatus];

/**
 *
 * @export
 * @interface AssignedTo
 */
export interface AssignedTo {
  /**
   *
   * @type {string}
   * @memberof AssignedTo
   */
  group: string;
  /**
   *
   * @type {string}
   * @memberof AssignedTo
   */
  name: string;
}
/**
 *
 * @export
 * @interface Assignment
 */
export interface Assignment {
  /**
   *
   * @type {string}
   * @memberof Assignment
   */
  fleet_name?: string | null;
  /**
   *
   * @type {string}
   * @memberof Assignment
   */
  expected_robot_name?: string | null;
}
/**
 *
 * @export
 * @interface Booking
 */
export interface Booking {
  /**
   * The unique identifier for this task
   * @type {string}
   * @memberof Booking
   */
  id: string;
  /**
   *
   * @type {number}
   * @memberof Booking
   */
  unix_millis_earliest_start_time?: number | null;
  /**
   *
   * @type {number}
   * @memberof Booking
   */
  unix_millis_request_time?: number | null;
  /**
   *
   * @type {Priority}
   * @memberof Booking
   */
  priority?: Priority | null;
  /**
   *
   * @type {Array<string>}
   * @memberof Booking
   */
  labels?: Array<string> | null;
  /**
   *
   * @type {string}
   * @memberof Booking
   */
  requester?: string | null;
}
/**
 *
 * @export
 * @interface BuildingMap
 */
export interface BuildingMap {
  /**
   *
   * @type {string}
   * @memberof BuildingMap
   */
  name: string;
  /**
   *
   * @type {Array<Level>}
   * @memberof BuildingMap
   */
  levels: Array<Level>;
  /**
   *
   * @type {Array<Lift>}
   * @memberof BuildingMap
   */
  lifts: Array<Lift>;
}
/**
 *
 * @export
 * @interface CancelTaskRequest
 */
export interface CancelTaskRequest {
  /**
   * Indicate that this is a task cancellation request
   * @type {any}
   * @memberof CancelTaskRequest
   */
  type: any;
  /**
   * Specify the task ID to cancel
   * @type {string}
   * @memberof CancelTaskRequest
   */
  task_id: string;
  /**
   *
   * @type {Array<string>}
   * @memberof CancelTaskRequest
   */
  labels?: Array<string> | null;
}
/**
 *
 * @export
 * @interface Cancellation
 */
export interface Cancellation {
  /**
   * The time that the cancellation request arrived
   * @type {number}
   * @memberof Cancellation
   */
  unix_millis_request_time: number;
  /**
   * Labels to describe the cancel request
   * @type {Array<string>}
   * @memberof Cancellation
   */
  labels: Array<string>;
}
/**
 *
 * @export
 * @interface Data
 */
export interface Data {
  /**
   *
   * @type {string}
   * @memberof Data
   */
  fleet_name?: string | null;
  /**
   *
   * @type {Array<Task>}
   * @memberof Data
   */
  tasks?: Array<Task> | null;
}
/**
 *
 * @export
 * @interface Datum
 */
export interface Datum {
  /**
   * Name of the fleet that supports these activities
   * @type {string}
   * @memberof Datum
   */
  fleet_name: string;
  /**
   * List of activities that the fleet supports
   * @type {Array<Activity>}
   * @memberof Datum
   */
  activities: Array<Activity>;
}
/**
 *
 * @export
 * @interface Detail
 */
export interface Detail {}
/**
 * Detailed information about the issue
 * @export
 * @interface Detail1
 */
export interface Detail1 {}
/**
 *
 * @export
 * @interface Dispatch
 */
export interface Dispatch {
  /**
   *
   * @type {Status2}
   * @memberof Dispatch
   */
  status: Status2;
  /**
   *
   * @type {Assignment}
   * @memberof Dispatch
   */
  assignment?: Assignment | null;
  /**
   *
   * @type {Array<Error>}
   * @memberof Dispatch
   */
  errors?: Array<Error> | null;
}

/**
 *
 * @export
 * @interface DispatchTaskRequest
 */
export interface DispatchTaskRequest {
  /**
   * Indicate that this is a task dispatch request
   * @type {any}
   * @memberof DispatchTaskRequest
   */
  type: any;
  /**
   *
   * @type {TaskRequest}
   * @memberof DispatchTaskRequest
   */
  request: TaskRequest;
}
/**
 *
 * @export
 * @interface Dispenser
 */
export interface Dispenser {
  /**
   *
   * @type {string}
   * @memberof Dispenser
   */
  guid: string;
}
/**
 *
 * @export
 * @interface DispenserHealth
 */
export interface DispenserHealth {
  /**
   *
   * @type {string}
   * @memberof DispenserHealth
   */
  id_: string;
  /**
   *
   * @type {HealthStatus}
   * @memberof DispenserHealth
   */
  health_status: HealthStatus;
  /**
   *
   * @type {string}
   * @memberof DispenserHealth
   */
  health_message: string | null;
}

/**
 *
 * @export
 * @interface DispenserState
 */
export interface DispenserState {
  /**
   *
   * @type {Time}
   * @memberof DispenserState
   */
  time: Time;
  /**
   *
   * @type {string}
   * @memberof DispenserState
   */
  guid: string;
  /**
   *
   * @type {number}
   * @memberof DispenserState
   */
  mode: number;
  /**
   *
   * @type {Array<string>}
   * @memberof DispenserState
   */
  request_guid_queue: Array<string>;
  /**
   *
   * @type {number}
   * @memberof DispenserState
   */
  seconds_remaining: number;
}
/**
 *
 * @export
 * @interface Door
 */
export interface Door {
  /**
   *
   * @type {string}
   * @memberof Door
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof Door
   */
  v1_x: number;
  /**
   *
   * @type {number}
   * @memberof Door
   */
  v1_y: number;
  /**
   *
   * @type {number}
   * @memberof Door
   */
  v2_x: number;
  /**
   *
   * @type {number}
   * @memberof Door
   */
  v2_y: number;
  /**
   *
   * @type {number}
   * @memberof Door
   */
  door_type: number;
  /**
   *
   * @type {number}
   * @memberof Door
   */
  motion_range: number;
  /**
   *
   * @type {number}
   * @memberof Door
   */
  motion_direction: number;
}
/**
 *
 * @export
 * @interface DoorHealth
 */
export interface DoorHealth {
  /**
   *
   * @type {string}
   * @memberof DoorHealth
   */
  id_: string;
  /**
   *
   * @type {HealthStatus}
   * @memberof DoorHealth
   */
  health_status: HealthStatus;
  /**
   *
   * @type {string}
   * @memberof DoorHealth
   */
  health_message: string | null;
}

/**
 *
 * @export
 * @interface DoorMode
 */
export interface DoorMode {
  /**
   *
   * @type {number}
   * @memberof DoorMode
   */
  value: number;
}
/**
 *
 * @export
 * @interface DoorRequest
 */
export interface DoorRequest {
  /**
   * https://github.com/open-rmf/rmf_internal_msgs/blob/main/rmf_door_msgs/msg/DoorMode.msg
   * @type {number}
   * @memberof DoorRequest
   */
  mode: number;
}
/**
 *
 * @export
 * @interface DoorState
 */
export interface DoorState {
  /**
   *
   * @type {Time}
   * @memberof DoorState
   */
  door_time: Time;
  /**
   *
   * @type {string}
   * @memberof DoorState
   */
  door_name: string;
  /**
   *
   * @type {DoorMode}
   * @memberof DoorState
   */
  current_mode: DoorMode;
}
/**
 *
 * @export
 * @interface EventState
 */
export interface EventState {
  /**
   *
   * @type {number}
   * @memberof EventState
   */
  id: number;
  /**
   *
   * @type {ApiServerModelsRmfApiTaskStateStatus}
   * @memberof EventState
   */
  status?: ApiServerModelsRmfApiTaskStateStatus | null;
  /**
   *
   * @type {string}
   * @memberof EventState
   */
  name?: string | null;
  /**
   *
   * @type {Detail}
   * @memberof EventState
   */
  detail?: Detail | null;
  /**
   *
   * @type {Array<number>}
   * @memberof EventState
   */
  deps?: Array<number> | null;
}

/**
 *
 * @export
 * @interface FleetLog
 */
export interface FleetLog {
  /**
   *
   * @type {string}
   * @memberof FleetLog
   */
  name?: string | null;
  /**
   *
   * @type {Array<LogEntry>}
   * @memberof FleetLog
   */
  log?: Array<LogEntry> | null;
  /**
   *
   * @type {{ [key: string]: Array<LogEntry>; }}
   * @memberof FleetLog
   */
  robots?: { [key: string]: Array<LogEntry> } | null;
}
/**
 *
 * @export
 * @interface FleetState
 */
export interface FleetState {
  /**
   *
   * @type {string}
   * @memberof FleetState
   */
  name?: string | null;
  /**
   *
   * @type {{ [key: string]: RobotState; }}
   * @memberof FleetState
   */
  robots?: { [key: string]: RobotState } | null;
}
/**
 *
 * @export
 * @interface Graph
 */
export interface Graph {
  /**
   *
   * @type {string}
   * @memberof Graph
   */
  name: string;
  /**
   *
   * @type {Array<GraphNode>}
   * @memberof Graph
   */
  vertices: Array<GraphNode>;
  /**
   *
   * @type {Array<GraphEdge>}
   * @memberof Graph
   */
  edges: Array<GraphEdge>;
  /**
   *
   * @type {Array<Param>}
   * @memberof Graph
   */
  params: Array<Param>;
}
/**
 *
 * @export
 * @interface GraphEdge
 */
export interface GraphEdge {
  /**
   *
   * @type {number}
   * @memberof GraphEdge
   */
  v1_idx: number;
  /**
   *
   * @type {number}
   * @memberof GraphEdge
   */
  v2_idx: number;
  /**
   *
   * @type {Array<Param>}
   * @memberof GraphEdge
   */
  params: Array<Param>;
  /**
   *
   * @type {number}
   * @memberof GraphEdge
   */
  edge_type: number;
}
/**
 *
 * @export
 * @interface GraphNode
 */
export interface GraphNode {
  /**
   *
   * @type {number}
   * @memberof GraphNode
   */
  x: number;
  /**
   *
   * @type {number}
   * @memberof GraphNode
   */
  y: number;
  /**
   *
   * @type {string}
   * @memberof GraphNode
   */
  name: string;
  /**
   *
   * @type {Array<Param>}
   * @memberof GraphNode
   */
  params: Array<Param>;
}
/**
 *
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
  /**
   *
   * @type {Array<ValidationError>}
   * @memberof HTTPValidationError
   */
  detail?: Array<ValidationError>;
}
/**
 *
 * @export
 * @enum {string}
 */

export const HealthStatus = {
  Healthy: 'Healthy',
  Unhealthy: 'Unhealthy',
  Dead: 'Dead',
} as const;

export type HealthStatus = (typeof HealthStatus)[keyof typeof HealthStatus];

/**
 *
 * @export
 * @interface Ingestor
 */
export interface Ingestor {
  /**
   *
   * @type {string}
   * @memberof Ingestor
   */
  guid: string;
}
/**
 *
 * @export
 * @interface IngestorHealth
 */
export interface IngestorHealth {
  /**
   *
   * @type {string}
   * @memberof IngestorHealth
   */
  id_: string;
  /**
   *
   * @type {HealthStatus}
   * @memberof IngestorHealth
   */
  health_status: HealthStatus;
  /**
   *
   * @type {string}
   * @memberof IngestorHealth
   */
  health_message: string | null;
}

/**
 *
 * @export
 * @interface IngestorState
 */
export interface IngestorState {
  /**
   *
   * @type {Time}
   * @memberof IngestorState
   */
  time: Time;
  /**
   *
   * @type {string}
   * @memberof IngestorState
   */
  guid: string;
  /**
   *
   * @type {number}
   * @memberof IngestorState
   */
  mode: number;
  /**
   *
   * @type {Array<string>}
   * @memberof IngestorState
   */
  request_guid_queue: Array<string>;
  /**
   *
   * @type {number}
   * @memberof IngestorState
   */
  seconds_remaining: number;
}
/**
 *
 * @export
 * @interface Interruption
 */
export interface Interruption {
  /**
   * The time that the interruption request arrived
   * @type {number}
   * @memberof Interruption
   */
  unix_millis_request_time: number;
  /**
   * Labels to describe the purpose of the interruption
   * @type {Array<string>}
   * @memberof Interruption
   */
  labels: Array<string>;
  /**
   *
   * @type {ResumedBy}
   * @memberof Interruption
   */
  resumed_by?: ResumedBy | null;
}
/**
 *
 * @export
 * @interface Issue
 */
export interface Issue {
  /**
   *
   * @type {string}
   * @memberof Issue
   */
  category?: string | null;
  /**
   *
   * @type {Detail1}
   * @memberof Issue
   */
  detail?: Detail1 | null;
}
/**
 *
 * @export
 * @interface Killed
 */
export interface Killed {
  /**
   * The time that the cancellation request arrived
   * @type {number}
   * @memberof Killed
   */
  unix_millis_request_time: number;
  /**
   * Labels to describe the kill request
   * @type {Array<string>}
   * @memberof Killed
   */
  labels: Array<string>;
}
/**
 *
 * @export
 * @interface Level
 */
export interface Level {
  /**
   *
   * @type {string}
   * @memberof Level
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof Level
   */
  elevation: number;
  /**
   *
   * @type {Array<AffineImage>}
   * @memberof Level
   */
  images: Array<AffineImage>;
  /**
   *
   * @type {Array<Place>}
   * @memberof Level
   */
  places: Array<Place>;
  /**
   *
   * @type {Array<Door>}
   * @memberof Level
   */
  doors: Array<Door>;
  /**
   *
   * @type {Array<Graph>}
   * @memberof Level
   */
  nav_graphs: Array<Graph>;
  /**
   *
   * @type {Graph}
   * @memberof Level
   */
  wall_graph: Graph;
}
/**
 *
 * @export
 * @interface Lift
 */
export interface Lift {
  /**
   *
   * @type {string}
   * @memberof Lift
   */
  name: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Lift
   */
  levels: Array<string>;
  /**
   *
   * @type {Array<Door>}
   * @memberof Lift
   */
  doors: Array<Door>;
  /**
   *
   * @type {Graph}
   * @memberof Lift
   */
  wall_graph: Graph;
  /**
   *
   * @type {number}
   * @memberof Lift
   */
  ref_x: number;
  /**
   *
   * @type {number}
   * @memberof Lift
   */
  ref_y: number;
  /**
   *
   * @type {number}
   * @memberof Lift
   */
  ref_yaw: number;
  /**
   *
   * @type {number}
   * @memberof Lift
   */
  width: number;
  /**
   *
   * @type {number}
   * @memberof Lift
   */
  depth: number;
}
/**
 *
 * @export
 * @interface LiftHealth
 */
export interface LiftHealth {
  /**
   *
   * @type {string}
   * @memberof LiftHealth
   */
  id_: string;
  /**
   *
   * @type {HealthStatus}
   * @memberof LiftHealth
   */
  health_status: HealthStatus;
  /**
   *
   * @type {string}
   * @memberof LiftHealth
   */
  health_message: string | null;
}

/**
 *
 * @export
 * @interface LiftRequest
 */
export interface LiftRequest {
  /**
   * https://github.com/open-rmf/rmf_internal_msgs/blob/main/rmf_lift_msgs/msg/LiftRequest.msg
   * @type {number}
   * @memberof LiftRequest
   */
  request_type: number;
  /**
   * https://github.com/open-rmf/rmf_internal_msgs/blob/main/rmf_lift_msgs/msg/LiftRequest.msg
   * @type {number}
   * @memberof LiftRequest
   */
  door_mode: number;
  /**
   *
   * @type {string}
   * @memberof LiftRequest
   */
  destination: string;
}
/**
 *
 * @export
 * @interface LiftState
 */
export interface LiftState {
  /**
   *
   * @type {Time}
   * @memberof LiftState
   */
  lift_time: Time;
  /**
   *
   * @type {string}
   * @memberof LiftState
   */
  lift_name: string;
  /**
   *
   * @type {Array<string>}
   * @memberof LiftState
   */
  available_floors: Array<string>;
  /**
   *
   * @type {string}
   * @memberof LiftState
   */
  current_floor: string;
  /**
   *
   * @type {string}
   * @memberof LiftState
   */
  destination_floor: string;
  /**
   *
   * @type {number}
   * @memberof LiftState
   */
  door_state: number;
  /**
   *
   * @type {number}
   * @memberof LiftState
   */
  motion_state: number;
  /**
   *
   * @type {Array<number>}
   * @memberof LiftState
   */
  available_modes: Array<number>;
  /**
   *
   * @type {number}
   * @memberof LiftState
   */
  current_mode: number;
  /**
   *
   * @type {string}
   * @memberof LiftState
   */
  session_id: string;
}
/**
 *
 * @export
 * @interface Location2D
 */
export interface Location2D {
  /**
   *
   * @type {string}
   * @memberof Location2D
   */
  map: string;
  /**
   *
   * @type {number}
   * @memberof Location2D
   */
  x: number;
  /**
   *
   * @type {number}
   * @memberof Location2D
   */
  y: number;
  /**
   *
   * @type {number}
   * @memberof Location2D
   */
  yaw: number;
}
/**
 *
 * @export
 * @interface LocationInner
 */
export interface LocationInner {}
/**
 *
 * @export
 * @interface LogEntry
 */
export interface LogEntry {
  /**
   * Sequence number for this entry. Each entry has a unique sequence number which monotonically increase, until integer overflow causes a wrap around.
   * @type {number}
   * @memberof LogEntry
   */
  seq: number;
  /**
   * The importance level of the log entry
   * @type {Tier}
   * @memberof LogEntry
   */
  tier: Tier;
  /**
   *
   * @type {number}
   * @memberof LogEntry
   */
  unix_millis_time: number;
  /**
   * The text of the log entry
   * @type {string}
   * @memberof LogEntry
   */
  text: string;
}

/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
  /**
   *
   * @type {number}
   * @memberof ModelError
   */
  code?: number | null;
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  category?: string | null;
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  detail?: string | null;
}
/**
 *
 * @export
 * @interface Param
 */
export interface Param {
  /**
   *
   * @type {string}
   * @memberof Param
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof Param
   */
  type: number;
  /**
   *
   * @type {number}
   * @memberof Param
   */
  value_int: number;
  /**
   *
   * @type {number}
   * @memberof Param
   */
  value_float: number;
  /**
   *
   * @type {string}
   * @memberof Param
   */
  value_string: string;
  /**
   *
   * @type {boolean}
   * @memberof Param
   */
  value_bool: boolean;
}
/**
 *
 * @export
 * @enum {string}
 */

export const Period = {
  Monday: 'monday',
  Tuesday: 'tuesday',
  Wednesday: 'wednesday',
  Thursday: 'thursday',
  Friday: 'friday',
  Saturday: 'saturday',
  Sunday: 'sunday',
  Day: 'day',
  Hour: 'hour',
  Minute: 'minute',
} as const;

export type Period = (typeof Period)[keyof typeof Period];

/**
 *
 * @export
 * @interface Permission
 */
export interface Permission {
  /**
   *
   * @type {string}
   * @memberof Permission
   */
  authz_grp: string;
  /**
   *
   * @type {string}
   * @memberof Permission
   */
  action: string;
}
/**
 *
 * @export
 * @interface Phase
 */
export interface Phase {
  /**
   *
   * @type {number}
   * @memberof Phase
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof Phase
   */
  category?: string;
  /**
   *
   * @type {Detail}
   * @memberof Phase
   */
  detail?: Detail | null;
  /**
   *
   * @type {number}
   * @memberof Phase
   */
  unix_millis_start_time?: number | null;
  /**
   *
   * @type {number}
   * @memberof Phase
   */
  unix_millis_finish_time?: number | null;
  /**
   *
   * @type {number}
   * @memberof Phase
   */
  original_estimate_millis?: number;
  /**
   *
   * @type {number}
   * @memberof Phase
   */
  estimate_millis?: number;
  /**
   *
   * @type {number}
   * @memberof Phase
   */
  final_event_id?: number;
  /**
   *
   * @type {{ [key: string]: EventState; }}
   * @memberof Phase
   */
  events?: { [key: string]: EventState } | null;
  /**
   *
   * @type {{ [key: string]: SkipPhaseRequest; }}
   * @memberof Phase
   */
  skip_requests?: { [key: string]: SkipPhaseRequest } | null;
}
/**
 *
 * @export
 * @interface Phases
 */
export interface Phases {
  /**
   *
   * @type {Array<LogEntry>}
   * @memberof Phases
   */
  log?: Array<LogEntry> | null;
  /**
   *
   * @type {{ [key: string]: Array<LogEntry>; }}
   * @memberof Phases
   */
  events?: { [key: string]: Array<LogEntry> } | null;
}
/**
 *
 * @export
 * @interface Place
 */
export interface Place {
  /**
   *
   * @type {string}
   * @memberof Place
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof Place
   */
  x: number;
  /**
   *
   * @type {number}
   * @memberof Place
   */
  y: number;
  /**
   *
   * @type {number}
   * @memberof Place
   */
  yaw: number;
  /**
   *
   * @type {number}
   * @memberof Place
   */
  position_tolerance: number;
  /**
   *
   * @type {number}
   * @memberof Place
   */
  yaw_tolerance: number;
}
/**
 *
 * @export
 * @interface PostMakeAdmin
 */
export interface PostMakeAdmin {
  /**
   *
   * @type {boolean}
   * @memberof PostMakeAdmin
   */
  admin: boolean;
}
/**
 *
 * @export
 * @interface PostRoles
 */
export interface PostRoles {
  /**
   *
   * @type {string}
   * @memberof PostRoles
   */
  name: string;
}
/**
 *
 * @export
 * @interface PostScheduledTaskRequest
 */
export interface PostScheduledTaskRequest {
  /**
   *
   * @type {TaskRequest}
   * @memberof PostScheduledTaskRequest
   */
  task_request: TaskRequest;
  /**
   *
   * @type {Array<ScheduledTaskSchedule>}
   * @memberof PostScheduledTaskRequest
   */
  schedules: Array<ScheduledTaskSchedule>;
}
/**
 *
 * @export
 * @interface PostUsers
 */
export interface PostUsers {
  /**
   *
   * @type {string}
   * @memberof PostUsers
   */
  username: string;
  /**
   *
   * @type {boolean}
   * @memberof PostUsers
   */
  is_admin?: boolean;
}
/**
 * Priority information about this task
 * @export
 * @interface Priority
 */
export interface Priority {}
/**
 *
 * @export
 * @interface ResumedBy
 */
export interface ResumedBy {
  /**
   *
   * @type {number}
   * @memberof ResumedBy
   */
  unix_millis_request_time?: number | null;
  /**
   * Labels to describe the resume request
   * @type {Array<string>}
   * @memberof ResumedBy
   */
  labels: Array<string>;
}
/**
 *
 * @export
 * @interface RobotState
 */
export interface RobotState {
  /**
   *
   * @type {string}
   * @memberof RobotState
   */
  name?: string | null;
  /**
   *
   * @type {ApiServerModelsRmfApiRobotStateStatus}
   * @memberof RobotState
   */
  status?: ApiServerModelsRmfApiRobotStateStatus | null;
  /**
   *
   * @type {string}
   * @memberof RobotState
   */
  task_id?: string | null;
  /**
   *
   * @type {number}
   * @memberof RobotState
   */
  unix_millis_time?: number | null;
  /**
   *
   * @type {Location2D}
   * @memberof RobotState
   */
  location?: Location2D | null;
  /**
   *
   * @type {number}
   * @memberof RobotState
   */
  battery?: number | null;
  /**
   *
   * @type {Array<Issue>}
   * @memberof RobotState
   */
  issues?: Array<Issue> | null;
}

/**
 *
 * @export
 * @interface RobotTaskRequest
 */
export interface RobotTaskRequest {
  /**
   * Indicate that this is a task dispatch request
   * @type {string}
   * @memberof RobotTaskRequest
   */
  type: string;
  /**
   * The name of the robot
   * @type {string}
   * @memberof RobotTaskRequest
   */
  robot: string;
  /**
   * The fleet the robot belongs to
   * @type {string}
   * @memberof RobotTaskRequest
   */
  fleet: string;
  /**
   *
   * @type {TaskRequest}
   * @memberof RobotTaskRequest
   */
  request: TaskRequest;
}
/**
 *
 * @export
 * @interface RobotTaskResponse
 */
export interface RobotTaskResponse {
  /**
   *
   * @type {}
   * @memberof RobotTaskResponse
   */
  success: null;
  /**
   *
   * @type {TaskState}
   * @memberof RobotTaskResponse
   */
  state: TaskState;
  /**
   *
   * @type {Array<Error>}
   * @memberof RobotTaskResponse
   */
  errors?: Array<Error> | null;
}
/**
 *
 * @export
 * @interface ScheduledTask
 */
export interface ScheduledTask {
  /**
   *
   * @type {number}
   * @memberof ScheduledTask
   */
  id: number;
  /**
   *
   * @type {TaskRequest}
   * @memberof ScheduledTask
   */
  task_request: TaskRequest;
  /**
   *
   * @type {string}
   * @memberof ScheduledTask
   */
  created_by: string;
  /**
   *
   * @type {Array<ScheduledTaskSchedule>}
   * @memberof ScheduledTask
   */
  schedules: Array<ScheduledTaskSchedule>;
  /**
   *
   * @type {string}
   * @memberof ScheduledTask
   */
  last_ran?: string | null;
  /**
   *
   * @type {Array<string>}
   * @memberof ScheduledTask
   */
  except_dates?: Array<string> | null;
}
/**
 *
 * @export
 * @interface ScheduledTaskSchedule
 */
export interface ScheduledTaskSchedule {
  /**
   *
   * @type {number}
   * @memberof ScheduledTaskSchedule
   */
  every?: number | null;
  /**
   *
   * @type {string}
   * @memberof ScheduledTaskSchedule
   */
  start_from?: string | null;
  /**
   *
   * @type {string}
   * @memberof ScheduledTaskSchedule
   */
  until?: string | null;
  /**
   *
   * @type {Period}
   * @memberof ScheduledTaskSchedule
   */
  period: Period;
  /**
   *
   * @type {string}
   * @memberof ScheduledTaskSchedule
   */
  at?: string | null;
}

/**
 *
 * @export
 * @interface SimpleResponse
 */
export interface SimpleResponse {
  /**
   *
   * @type {any}
   * @memberof SimpleResponse
   */
  success: any;
  /**
   * If the request failed, these error messages will explain why
   * @type {Array<Error>}
   * @memberof SimpleResponse
   */
  errors: Array<Error>;
}
/**
 *
 * @export
 * @interface SimpleResponse1
 */
export interface SimpleResponse1 {
  /**
   *
   * @type {any}
   * @memberof SimpleResponse1
   */
  success: any;
}
/**
 *
 * @export
 * @interface SimpleResponse2
 */
export interface SimpleResponse2 {
  /**
   *
   * @type {any}
   * @memberof SimpleResponse2
   */
  success: any;
  /**
   * If the request failed, these error messages will explain why
   * @type {Array<Error>}
   * @memberof SimpleResponse2
   */
  errors: Array<Error>;
}
/**
 *
 * @export
 * @interface SkipPhaseRequest
 */
export interface SkipPhaseRequest {
  /**
   * The time that the skip request arrived
   * @type {number}
   * @memberof SkipPhaseRequest
   */
  unix_millis_request_time: number;
  /**
   * Labels to describe the purpose of the skip request
   * @type {Array<string>}
   * @memberof SkipPhaseRequest
   */
  labels: Array<string>;
  /**
   *
   * @type {Undo}
   * @memberof SkipPhaseRequest
   */
  undo?: Undo | null;
}
/**
 *
 * @export
 * @interface SkipPhaseResponse
 */
export interface SkipPhaseResponse {
  /**
   *
   * @type {any}
   * @memberof SkipPhaseResponse
   */
  success: any;
  /**
   * A token for the request. The value of this token is unique within the scope of this request and can be used by other requests to reference this request.
   * @type {string}
   * @memberof SkipPhaseResponse
   */
  token: string;
  /**
   * Any error messages explaining why the request failed.
   * @type {Array<Error>}
   * @memberof SkipPhaseResponse
   */
  errors: Array<Error>;
}
/**
 *
 * @export
 * @enum {string}
 */

export const Status2 = {
  Queued: 'queued',
  Selected: 'selected',
  Dispatched: 'dispatched',
  FailedToAssign: 'failed_to_assign',
  CanceledInFlight: 'canceled_in_flight',
} as const;

export type Status2 = (typeof Status2)[keyof typeof Status2];

/**
 *
 * @export
 * @interface Task
 */
export interface Task {
  /**
   * The category of this task. There must not be any duplicate task categories per fleet.
   * @type {string}
   * @memberof Task
   */
  category: string;
  /**
   * Details about the behavior of the task.
   * @type {string}
   * @memberof Task
   */
  detail: string;
  /**
   *
   * @type {object}
   * @memberof Task
   */
  description_schema?: object | null;
}
/**
 *
 * @export
 * @interface TaskCancelResponse
 */
export interface TaskCancelResponse {
  /**
   *
   * @type {object}
   * @memberof TaskCancelResponse
   */
  success: object;
  /**
   * If the request failed, these error messages will explain why
   * @type {Array<Error>}
   * @memberof TaskCancelResponse
   */
  errors: Array<Error>;
}
/**
 *
 * @export
 * @interface TaskDiscovery
 */
export interface TaskDiscovery {
  /**
   * Indicate that this is an task discovery update
   * @type {any}
   * @memberof TaskDiscovery
   */
  type: any;
  /**
   *
   * @type {Data}
   * @memberof TaskDiscovery
   */
  data: Data;
}
/**
 *
 * @export
 * @interface TaskDiscoveryRequest
 */
export interface TaskDiscoveryRequest {
  /**
   * Indicate that this is a task discovery request
   * @type {any}
   * @memberof TaskDiscoveryRequest
   */
  type: any;
}
/**
 *
 * @export
 * @interface TaskDispatchResponse
 */
export interface TaskDispatchResponse {
  /**
   *
   * @type {}
   * @memberof TaskDispatchResponse
   */
  success: null;
  /**
   *
   * @type {TaskState}
   * @memberof TaskDispatchResponse
   */
  state: TaskState;
  /**
   *
   * @type {Array<Error>}
   * @memberof TaskDispatchResponse
   */
  errors?: Array<Error> | null;
}
/**
 *
 * @export
 * @interface TaskDispatchResponse1
 */
export interface TaskDispatchResponse1 {
  /**
   *
   * @type {any}
   * @memberof TaskDispatchResponse1
   */
  success: any;
  /**
   *
   * @type {TaskState}
   * @memberof TaskDispatchResponse1
   */
  state: TaskState;
}
/**
 *
 * @export
 * @interface TaskDispatchResponse2
 */
export interface TaskDispatchResponse2 {
  /**
   *
   * @type {}
   * @memberof TaskDispatchResponse2
   */
  success?: null;
  /**
   *
   * @type {Array<Error>}
   * @memberof TaskDispatchResponse2
   */
  errors?: Array<Error> | null;
}
/**
 *
 * @export
 * @interface TaskEventLog
 */
export interface TaskEventLog {
  /**
   *
   * @type {string}
   * @memberof TaskEventLog
   */
  task_id: string;
  /**
   *
   * @type {Array<LogEntry>}
   * @memberof TaskEventLog
   */
  log?: Array<LogEntry> | null;
  /**
   *
   * @type {{ [key: string]: Phases; }}
   * @memberof TaskEventLog
   */
  phases?: { [key: string]: Phases } | null;
}
/**
 *
 * @export
 * @interface TaskFavoritePydantic
 */
export interface TaskFavoritePydantic {
  /**
   *
   * @type {string}
   * @memberof TaskFavoritePydantic
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof TaskFavoritePydantic
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof TaskFavoritePydantic
   */
  unix_millis_earliest_start_time: number;
  /**
   *
   * @type {object}
   * @memberof TaskFavoritePydantic
   */
  priority: object | null;
  /**
   *
   * @type {string}
   * @memberof TaskFavoritePydantic
   */
  category: string;
  /**
   *
   * @type {object}
   * @memberof TaskFavoritePydantic
   */
  description: object | null;
  /**
   *
   * @type {string}
   * @memberof TaskFavoritePydantic
   */
  user: string;
}
/**
 *
 * @export
 * @interface TaskInterruptionRequest
 */
export interface TaskInterruptionRequest {
  /**
   * Indicate that this is a task interruption request
   * @type {any}
   * @memberof TaskInterruptionRequest
   */
  type: any;
  /**
   * Specify the task ID to interrupt
   * @type {string}
   * @memberof TaskInterruptionRequest
   */
  task_id: string;
  /**
   *
   * @type {Array<string>}
   * @memberof TaskInterruptionRequest
   */
  labels?: Array<string> | null;
}
/**
 *
 * @export
 * @interface TaskInterruptionResponse
 */
export interface TaskInterruptionResponse {
  /**
   *
   * @type {any}
   * @memberof TaskInterruptionResponse
   */
  success: any;
  /**
   * A token for the request. The value of this token is unique within the scope of this request and can be used by other requests to reference this request.
   * @type {string}
   * @memberof TaskInterruptionResponse
   */
  token: string;
  /**
   * Any error messages explaining why the request failed.
   * @type {Array<Error>}
   * @memberof TaskInterruptionResponse
   */
  errors: Array<Error>;
}
/**
 *
 * @export
 * @interface TaskKillRequest
 */
export interface TaskKillRequest {
  /**
   * Indicate that this is a task kill request
   * @type {any}
   * @memberof TaskKillRequest
   */
  type: any;
  /**
   * Specify the task ID to kill
   * @type {string}
   * @memberof TaskKillRequest
   */
  task_id: string;
  /**
   *
   * @type {Array<string>}
   * @memberof TaskKillRequest
   */
  labels?: Array<string> | null;
}
/**
 *
 * @export
 * @interface TaskKillResponse
 */
export interface TaskKillResponse {
  /**
   *
   * @type {object}
   * @memberof TaskKillResponse
   */
  success: object;
  /**
   * If the request failed, these error messages will explain why
   * @type {Array<Error>}
   * @memberof TaskKillResponse
   */
  errors: Array<Error>;
}
/**
 *
 * @export
 * @interface TaskPhaseSkipRequest
 */
export interface TaskPhaseSkipRequest {
  /**
   * Indicate that this is a phase skip request
   * @type {any}
   * @memberof TaskPhaseSkipRequest
   */
  type: any;
  /**
   * Specify the task ID whose phase should be skipped
   * @type {string}
   * @memberof TaskPhaseSkipRequest
   */
  task_id: string;
  /**
   * Specify the phase that should be skipped
   * @type {number}
   * @memberof TaskPhaseSkipRequest
   */
  phase_id: number;
  /**
   *
   * @type {Array<string>}
   * @memberof TaskPhaseSkipRequest
   */
  labels?: Array<string> | null;
}
/**
 *
 * @export
 * @interface TaskRequest
 */
export interface TaskRequest {
  /**
   *
   * @type {number}
   * @memberof TaskRequest
   */
  unix_millis_earliest_start_time?: number | null;
  /**
   *
   * @type {number}
   * @memberof TaskRequest
   */
  unix_millis_request_time?: number | null;
  /**
   *
   * @type {object}
   * @memberof TaskRequest
   */
  priority?: object | null;
  /**
   *
   * @type {string}
   * @memberof TaskRequest
   */
  category: string;
  /**
   * A description of the task. This must match a schema supported by a fleet for the category of this task request.
   * @type {any}
   * @memberof TaskRequest
   */
  description: any;
  /**
   *
   * @type {Array<string>}
   * @memberof TaskRequest
   */
  labels?: Array<string> | null;
  /**
   *
   * @type {string}
   * @memberof TaskRequest
   */
  requester?: string | null;
  /**
   *
   * @type {string}
   * @memberof TaskRequest
   */
  fleet_name?: string | null;
}
/**
 *
 * @export
 * @interface TaskResumeRequest
 */
export interface TaskResumeRequest {
  /**
   * Indicate that this is a task resuming request
   * @type {}
   * @memberof TaskResumeRequest
   */
  type?: null;
  /**
   *
   * @type {string}
   * @memberof TaskResumeRequest
   */
  for_task?: string | null;
  /**
   *
   * @type {Array<string>}
   * @memberof TaskResumeRequest
   */
  for_tokens?: Array<string> | null;
  /**
   *
   * @type {Array<string>}
   * @memberof TaskResumeRequest
   */
  labels?: Array<string> | null;
}
/**
 *
 * @export
 * @interface TaskResumeResponse
 */
export interface TaskResumeResponse {
  /**
   *
   * @type {object}
   * @memberof TaskResumeResponse
   */
  success: object;
  /**
   * If the request failed, these error messages will explain why
   * @type {Array<Error>}
   * @memberof TaskResumeResponse
   */
  errors: Array<Error>;
}
/**
 *
 * @export
 * @interface TaskRewindRequest
 */
export interface TaskRewindRequest {
  /**
   * Indicate that this is a task rewind request
   * @type {any}
   * @memberof TaskRewindRequest
   */
  type: any;
  /**
   * Specify the ID of the task that should rewind
   * @type {string}
   * @memberof TaskRewindRequest
   */
  task_id: string;
  /**
   * Specify the phase that should be rewound to. The task will restart at the beginning of this phase.
   * @type {number}
   * @memberof TaskRewindRequest
   */
  phase_id: number;
}
/**
 *
 * @export
 * @interface TaskRewindResponse
 */
export interface TaskRewindResponse {
  /**
   *
   * @type {object}
   * @memberof TaskRewindResponse
   */
  success: object;
  /**
   * If the request failed, these error messages will explain why
   * @type {Array<Error>}
   * @memberof TaskRewindResponse
   */
  errors: Array<Error>;
}
/**
 *
 * @export
 * @interface TaskState
 */
export interface TaskState {
  /**
   *
   * @type {Booking}
   * @memberof TaskState
   */
  booking: Booking;
  /**
   *
   * @type {string}
   * @memberof TaskState
   */
  category?: string;
  /**
   *
   * @type {Detail}
   * @memberof TaskState
   */
  detail?: Detail | null;
  /**
   *
   * @type {number}
   * @memberof TaskState
   */
  unix_millis_start_time?: number | null;
  /**
   *
   * @type {number}
   * @memberof TaskState
   */
  unix_millis_finish_time?: number | null;
  /**
   *
   * @type {number}
   * @memberof TaskState
   */
  original_estimate_millis?: number;
  /**
   *
   * @type {number}
   * @memberof TaskState
   */
  estimate_millis?: number;
  /**
   *
   * @type {AssignedTo}
   * @memberof TaskState
   */
  assigned_to?: AssignedTo | null;
  /**
   *
   * @type {ApiServerModelsRmfApiTaskStateStatus}
   * @memberof TaskState
   */
  status?: ApiServerModelsRmfApiTaskStateStatus | null;
  /**
   *
   * @type {Dispatch}
   * @memberof TaskState
   */
  dispatch?: Dispatch | null;
  /**
   *
   * @type {{ [key: string]: Phase; }}
   * @memberof TaskState
   */
  phases?: { [key: string]: Phase } | null;
  /**
   *
   * @type {Array<number>}
   * @memberof TaskState
   */
  completed?: Array<number> | null;
  /**
   *
   * @type {number}
   * @memberof TaskState
   */
  active?: number;
  /**
   *
   * @type {Array<number>}
   * @memberof TaskState
   */
  pending?: Array<number> | null;
  /**
   *
   * @type {{ [key: string]: Interruption; }}
   * @memberof TaskState
   */
  interruptions?: { [key: string]: Interruption } | null;
  /**
   *
   * @type {Cancellation}
   * @memberof TaskState
   */
  cancellation?: Cancellation | null;
  /**
   *
   * @type {Killed}
   * @memberof TaskState
   */
  killed?: Killed | null;
}

/**
 *
 * @export
 * @enum {string}
 */

export const Tier = {
  Uninitialized: 'uninitialized',
  Info: 'info',
  Warning: 'warning',
  Error: 'error',
} as const;

export type Tier = (typeof Tier)[keyof typeof Tier];

/**
 *
 * @export
 * @interface Time
 */
export interface Time {
  /**
   *
   * @type {number}
   * @memberof Time
   */
  sec: number;
  /**
   *
   * @type {number}
   * @memberof Time
   */
  nanosec: number;
}
/**
 *
 * @export
 * @interface TokenResponse
 */
export interface TokenResponse {
  /**
   *
   * @type {any}
   * @memberof TokenResponse
   */
  success: any;
  /**
   * A token for the request. The value of this token is unique within the scope of this request and can be used by other requests to reference this request.
   * @type {string}
   * @memberof TokenResponse
   */
  token: string;
  /**
   * Any error messages explaining why the request failed.
   * @type {Array<Error>}
   * @memberof TokenResponse
   */
  errors: Array<Error>;
}
/**
 *
 * @export
 * @interface TokenResponse1
 */
export interface TokenResponse1 {
  /**
   *
   * @type {any}
   * @memberof TokenResponse1
   */
  success: any;
  /**
   * A token for the request. The value of this token is unique within the scope of this request and can be used by other requests to reference this request.
   * @type {string}
   * @memberof TokenResponse1
   */
  token: string;
}
/**
 *
 * @export
 * @interface TokenResponse2
 */
export interface TokenResponse2 {
  /**
   *
   * @type {any}
   * @memberof TokenResponse2
   */
  success: any;
  /**
   * Any error messages explaining why the request failed.
   * @type {Array<Error>}
   * @memberof TokenResponse2
   */
  errors: Array<Error>;
}
/**
 * General alert that can be triggered by events.
 * @export
 * @interface TortoiseContribPydanticCreatorApiServerModelsTortoiseModelsAlertsAlertLeaf
 */
export interface TortoiseContribPydanticCreatorApiServerModelsTortoiseModelsAlertsAlertLeaf {
  /**
   *
   * @type {string}
   * @memberof TortoiseContribPydanticCreatorApiServerModelsTortoiseModelsAlertsAlertLeaf
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof TortoiseContribPydanticCreatorApiServerModelsTortoiseModelsAlertsAlertLeaf
   */
  original_id: string;
  /**
   * Default: default<br/>Task: task<br/>Fleet: fleet<br/>Robot: robot
   * @type {string}
   * @memberof TortoiseContribPydanticCreatorApiServerModelsTortoiseModelsAlertsAlertLeaf
   */
  category: string;
  /**
   *
   * @type {number}
   * @memberof TortoiseContribPydanticCreatorApiServerModelsTortoiseModelsAlertsAlertLeaf
   */
  unix_millis_created_time: number;
  /**
   *
   * @type {string}
   * @memberof TortoiseContribPydanticCreatorApiServerModelsTortoiseModelsAlertsAlertLeaf
   */
  acknowledged_by: string | null;
  /**
   *
   * @type {number}
   * @memberof TortoiseContribPydanticCreatorApiServerModelsTortoiseModelsAlertsAlertLeaf
   */
  unix_millis_acknowledged_time: number | null;
}
/**
 *
 * @export
 * @interface TortoiseContribPydanticCreatorApiServerModelsTortoiseModelsBeaconsBeaconStateLeaf
 */
export interface TortoiseContribPydanticCreatorApiServerModelsTortoiseModelsBeaconsBeaconStateLeaf {
  /**
   *
   * @type {string}
   * @memberof TortoiseContribPydanticCreatorApiServerModelsTortoiseModelsBeaconsBeaconStateLeaf
   */
  id: string;
  /**
   *
   * @type {boolean}
   * @memberof TortoiseContribPydanticCreatorApiServerModelsTortoiseModelsBeaconsBeaconStateLeaf
   */
  online: boolean;
  /**
   *
   * @type {string}
   * @memberof TortoiseContribPydanticCreatorApiServerModelsTortoiseModelsBeaconsBeaconStateLeaf
   */
  category: string | null;
  /**
   *
   * @type {boolean}
   * @memberof TortoiseContribPydanticCreatorApiServerModelsTortoiseModelsBeaconsBeaconStateLeaf
   */
  activated: boolean;
  /**
   *
   * @type {string}
   * @memberof TortoiseContribPydanticCreatorApiServerModelsTortoiseModelsBeaconsBeaconStateLeaf
   */
  level: string | null;
}
/**
 *
 * @export
 * @interface Undo
 */
export interface Undo {
  /**
   * The time that the undo skip request arrived
   * @type {number}
   * @memberof Undo
   */
  unix_millis_request_time: number;
  /**
   * Labels to describe the undo skip request
   * @type {Array<string>}
   * @memberof Undo
   */
  labels: Array<string>;
}
/**
 *
 * @export
 * @interface UndoPhaseSkipRequest
 */
export interface UndoPhaseSkipRequest {
  /**
   * Indicate that this is a request to undo a phase skip request
   * @type {}
   * @memberof UndoPhaseSkipRequest
   */
  type?: null;
  /**
   *
   * @type {string}
   * @memberof UndoPhaseSkipRequest
   */
  for_task?: string | null;
  /**
   *
   * @type {Array<string>}
   * @memberof UndoPhaseSkipRequest
   */
  for_tokens?: Array<string> | null;
  /**
   *
   * @type {Array<string>}
   * @memberof UndoPhaseSkipRequest
   */
  labels?: Array<string> | null;
}
/**
 *
 * @export
 * @interface UndoPhaseSkipResponse
 */
export interface UndoPhaseSkipResponse {
  /**
   *
   * @type {object}
   * @memberof UndoPhaseSkipResponse
   */
  success: object;
  /**
   * If the request failed, these error messages will explain why
   * @type {Array<Error>}
   * @memberof UndoPhaseSkipResponse
   */
  errors: Array<Error>;
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {string}
   * @memberof User
   */
  username: string;
  /**
   *
   * @type {boolean}
   * @memberof User
   */
  is_admin: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof User
   */
  roles: Array<string>;
}
/**
 *
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
  /**
   *
   * @type {Array<LocationInner>}
   * @memberof ValidationError
   */
  loc: Array<LocationInner>;
  /**
   *
   * @type {string}
   * @memberof ValidationError
   */
  msg: string;
  /**
   *
   * @type {string}
   * @memberof ValidationError
   */
  type: string;
}

/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Add a permission to a role
     * @summary Add Role Permission
     * @param {string} role
     * @param {Permission} permission
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addRolePermissionAdminRolesRolePermissionsPost: async (
      role: string,
      permission: Permission,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'role' is not null or undefined
      assertParamExists('addRolePermissionAdminRolesRolePermissionsPost', 'role', role);
      // verify required parameter 'permission' is not null or undefined
      assertParamExists('addRolePermissionAdminRolesRolePermissionsPost', 'permission', permission);
      const localVarPath = `/admin/roles/{role}/permissions`.replace(
        `{${'role'}}`,
        encodeURIComponent(String(role)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        permission,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Add role to a user
     * @summary Add User Role
     * @param {string} username
     * @param {PostRoles} postRoles
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUserRoleAdminUsersUsernameRolesPost: async (
      username: string,
      postRoles: PostRoles,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists('addUserRoleAdminUsersUsernameRolesPost', 'username', username);
      // verify required parameter 'postRoles' is not null or undefined
      assertParamExists('addUserRoleAdminUsersUsernameRolesPost', 'postRoles', postRoles);
      const localVarPath = `/admin/users/{username}/roles`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        postRoles,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a new role
     * @summary Create Role
     * @param {PostRoles} postRoles
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRoleAdminRolesPost: async (
      postRoles: PostRoles,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'postRoles' is not null or undefined
      assertParamExists('createRoleAdminRolesPost', 'postRoles', postRoles);
      const localVarPath = `/admin/roles`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        postRoles,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a user
     * @summary Create User
     * @param {PostUsers} postUsers
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUserAdminUsersPost: async (
      postUsers: PostUsers,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'postUsers' is not null or undefined
      assertParamExists('createUserAdminUsersPost', 'postUsers', postUsers);
      const localVarPath = `/admin/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        postUsers,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a role
     * @summary Delete Role
     * @param {string} role
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRoleAdminRolesRoleDelete: async (
      role: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'role' is not null or undefined
      assertParamExists('deleteRoleAdminRolesRoleDelete', 'role', role);
      const localVarPath = `/admin/roles/{role}`.replace(
        `{${'role'}}`,
        encodeURIComponent(String(role)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a user  This only performs a soft delete, while the user is deleted from the app database, it still exists in the idp so they can still log in, the user will then be re-created with the default permissions.
     * @summary Delete User
     * @param {string} username
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserAdminUsersUsernameDelete: async (
      username: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists('deleteUserAdminUsersUsernameDelete', 'username', username);
      const localVarPath = `/admin/users/{username}`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Remove role from a user
     * @summary Delete User Role
     * @param {string} username
     * @param {string} role
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserRoleAdminUsersUsernameRolesRoleDelete: async (
      username: string,
      role: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists('deleteUserRoleAdminUsersUsernameRolesRoleDelete', 'username', username);
      // verify required parameter 'role' is not null or undefined
      assertParamExists('deleteUserRoleAdminUsersUsernameRolesRoleDelete', 'role', role);
      const localVarPath = `/admin/users/{username}/roles/{role}`
        .replace(`{${'username'}}`, encodeURIComponent(String(username)))
        .replace(`{${'role'}}`, encodeURIComponent(String(role)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get all permissions of a role
     * @summary Get Role Permissions
     * @param {string} role
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRolePermissionsAdminRolesRolePermissionsGet: async (
      role: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'role' is not null or undefined
      assertParamExists('getRolePermissionsAdminRolesRolePermissionsGet', 'role', role);
      const localVarPath = `/admin/roles/{role}/permissions`.replace(
        `{${'role'}}`,
        encodeURIComponent(String(role)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get all roles
     * @summary Get Roles
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRolesAdminRolesGet: async (
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/admin/roles`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a user
     * @summary Get User
     * @param {string} username
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserAdminUsersUsernameGet: async (
      username: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists('getUserAdminUsersUsernameGet', 'username', username);
      const localVarPath = `/admin/users/{username}`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Search users
     * @summary Get Users
     * @param {string | null} [username] filters username that starts with the value
     * @param {boolean | null} [isAdmin]
     * @param {number | null} [limit] defaults to 100
     * @param {number | null} [offset] defaults to 0
     * @param {string | null} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersAdminUsersGet: async (
      username?: string | null,
      isAdmin?: boolean | null,
      limit?: number | null,
      offset?: number | null,
      orderBy?: string | null,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/admin/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (username !== undefined) {
        localVarQueryParameter['username'] = username;
      }

      if (isAdmin !== undefined) {
        localVarQueryParameter['is_admin'] = isAdmin;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['order_by'] = orderBy;
      }

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Make or remove admin privilege from a user
     * @summary Make Admin
     * @param {string} username
     * @param {PostMakeAdmin} postMakeAdmin
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    makeAdminAdminUsersUsernameMakeAdminPost: async (
      username: string,
      postMakeAdmin: PostMakeAdmin,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists('makeAdminAdminUsersUsernameMakeAdminPost', 'username', username);
      // verify required parameter 'postMakeAdmin' is not null or undefined
      assertParamExists('makeAdminAdminUsersUsernameMakeAdminPost', 'postMakeAdmin', postMakeAdmin);
      const localVarPath = `/admin/users/{username}/make_admin`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        postMakeAdmin,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a permission from a role
     * @summary Remove Role Permission
     * @param {string} role
     * @param {Permission} permission
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeRolePermissionAdminRolesRolePermissionsRemovePost: async (
      role: string,
      permission: Permission,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'role' is not null or undefined
      assertParamExists('removeRolePermissionAdminRolesRolePermissionsRemovePost', 'role', role);
      // verify required parameter 'permission' is not null or undefined
      assertParamExists(
        'removeRolePermissionAdminRolesRolePermissionsRemovePost',
        'permission',
        permission,
      );
      const localVarPath = `/admin/roles/{role}/permissions/remove`.replace(
        `{${'role'}}`,
        encodeURIComponent(String(role)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        permission,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Set the roles of a user
     * @summary Set User Roles
     * @param {string} username
     * @param {Array<PostRoles>} postRoles
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserRolesAdminUsersUsernameRolesPut: async (
      username: string,
      postRoles: Array<PostRoles>,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists('setUserRolesAdminUsersUsernameRolesPut', 'username', username);
      // verify required parameter 'postRoles' is not null or undefined
      assertParamExists('setUserRolesAdminUsersUsernameRolesPut', 'postRoles', postRoles);
      const localVarPath = `/admin/users/{username}/roles`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        postRoles,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration);
  return {
    /**
     * Add a permission to a role
     * @summary Add Role Permission
     * @param {string} role
     * @param {Permission} permission
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addRolePermissionAdminRolesRolePermissionsPost(
      role: string,
      permission: Permission,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.addRolePermissionAdminRolesRolePermissionsPost(
          role,
          permission,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.addRolePermissionAdminRolesRolePermissionsPost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Add role to a user
     * @summary Add User Role
     * @param {string} username
     * @param {PostRoles} postRoles
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addUserRoleAdminUsersUsernameRolesPost(
      username: string,
      postRoles: PostRoles,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.addUserRoleAdminUsersUsernameRolesPost(
          username,
          postRoles,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.addUserRoleAdminUsersUsernameRolesPost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Create a new role
     * @summary Create Role
     * @param {PostRoles} postRoles
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRoleAdminRolesPost(
      postRoles: PostRoles,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createRoleAdminRolesPost(
        postRoles,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.createRoleAdminRolesPost']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Create a user
     * @summary Create User
     * @param {PostUsers} postUsers
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createUserAdminUsersPost(
      postUsers: PostUsers,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createUserAdminUsersPost(
        postUsers,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.createUserAdminUsersPost']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Delete a role
     * @summary Delete Role
     * @param {string} role
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteRoleAdminRolesRoleDelete(
      role: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRoleAdminRolesRoleDelete(
        role,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.deleteRoleAdminRolesRoleDelete']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Delete a user  This only performs a soft delete, while the user is deleted from the app database, it still exists in the idp so they can still log in, the user will then be re-created with the default permissions.
     * @summary Delete User
     * @param {string} username
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUserAdminUsersUsernameDelete(
      username: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserAdminUsersUsernameDelete(
        username,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.deleteUserAdminUsersUsernameDelete']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Remove role from a user
     * @summary Delete User Role
     * @param {string} username
     * @param {string} role
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUserRoleAdminUsersUsernameRolesRoleDelete(
      username: string,
      role: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteUserRoleAdminUsersUsernameRolesRoleDelete(
          username,
          role,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.deleteUserRoleAdminUsersUsernameRolesRoleDelete']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get all permissions of a role
     * @summary Get Role Permissions
     * @param {string} role
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRolePermissionsAdminRolesRolePermissionsGet(
      role: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Permission>>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getRolePermissionsAdminRolesRolePermissionsGet(
          role,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.getRolePermissionsAdminRolesRolePermissionsGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get all roles
     * @summary Get Roles
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRolesAdminRolesGet(
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRolesAdminRolesGet(
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.getRolesAdminRolesGet']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get a user
     * @summary Get User
     * @param {string} username
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserAdminUsersUsernameGet(
      username: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAdminUsersUsernameGet(
        username,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.getUserAdminUsersUsernameGet']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Search users
     * @summary Get Users
     * @param {string | null} [username] filters username that starts with the value
     * @param {boolean | null} [isAdmin]
     * @param {number | null} [limit] defaults to 100
     * @param {number | null} [offset] defaults to 0
     * @param {string | null} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsersAdminUsersGet(
      username?: string | null,
      isAdmin?: boolean | null,
      limit?: number | null,
      offset?: number | null,
      orderBy?: string | null,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersAdminUsersGet(
        username,
        isAdmin,
        limit,
        offset,
        orderBy,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.getUsersAdminUsersGet']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Make or remove admin privilege from a user
     * @summary Make Admin
     * @param {string} username
     * @param {PostMakeAdmin} postMakeAdmin
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async makeAdminAdminUsersUsernameMakeAdminPost(
      username: string,
      postMakeAdmin: PostMakeAdmin,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.makeAdminAdminUsersUsernameMakeAdminPost(
          username,
          postMakeAdmin,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.makeAdminAdminUsersUsernameMakeAdminPost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Delete a permission from a role
     * @summary Remove Role Permission
     * @param {string} role
     * @param {Permission} permission
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeRolePermissionAdminRolesRolePermissionsRemovePost(
      role: string,
      permission: Permission,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.removeRolePermissionAdminRolesRolePermissionsRemovePost(
          role,
          permission,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.removeRolePermissionAdminRolesRolePermissionsRemovePost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Set the roles of a user
     * @summary Set User Roles
     * @param {string} username
     * @param {Array<PostRoles>} postRoles
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setUserRolesAdminUsersUsernameRolesPut(
      username: string,
      postRoles: Array<PostRoles>,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.setUserRolesAdminUsersUsernameRolesPut(
          username,
          postRoles,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.setUserRolesAdminUsersUsernameRolesPut']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AdminApiFp(configuration);
  return {
    /**
     * Add a permission to a role
     * @summary Add Role Permission
     * @param {string} role
     * @param {Permission} permission
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addRolePermissionAdminRolesRolePermissionsPost(
      role: string,
      permission: Permission,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .addRolePermissionAdminRolesRolePermissionsPost(role, permission, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Add role to a user
     * @summary Add User Role
     * @param {string} username
     * @param {PostRoles} postRoles
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUserRoleAdminUsersUsernameRolesPost(
      username: string,
      postRoles: PostRoles,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .addUserRoleAdminUsersUsernameRolesPost(username, postRoles, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a new role
     * @summary Create Role
     * @param {PostRoles} postRoles
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRoleAdminRolesPost(
      postRoles: PostRoles,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .createRoleAdminRolesPost(postRoles, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a user
     * @summary Create User
     * @param {PostUsers} postUsers
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUserAdminUsersPost(
      postUsers: PostUsers,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .createUserAdminUsersPost(postUsers, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete a role
     * @summary Delete Role
     * @param {string} role
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRoleAdminRolesRoleDelete(
      role: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .deleteRoleAdminRolesRoleDelete(role, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete a user  This only performs a soft delete, while the user is deleted from the app database, it still exists in the idp so they can still log in, the user will then be re-created with the default permissions.
     * @summary Delete User
     * @param {string} username
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserAdminUsersUsernameDelete(
      username: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .deleteUserAdminUsersUsernameDelete(username, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Remove role from a user
     * @summary Delete User Role
     * @param {string} username
     * @param {string} role
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserRoleAdminUsersUsernameRolesRoleDelete(
      username: string,
      role: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .deleteUserRoleAdminUsersUsernameRolesRoleDelete(username, role, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get all permissions of a role
     * @summary Get Role Permissions
     * @param {string} role
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRolePermissionsAdminRolesRolePermissionsGet(
      role: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<Array<Permission>> {
      return localVarFp
        .getRolePermissionsAdminRolesRolePermissionsGet(role, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get all roles
     * @summary Get Roles
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRolesAdminRolesGet(
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .getRolesAdminRolesGet(authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a user
     * @summary Get User
     * @param {string} username
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserAdminUsersUsernameGet(
      username: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<User> {
      return localVarFp
        .getUserAdminUsersUsernameGet(username, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Search users
     * @summary Get Users
     * @param {string | null} [username] filters username that starts with the value
     * @param {boolean | null} [isAdmin]
     * @param {number | null} [limit] defaults to 100
     * @param {number | null} [offset] defaults to 0
     * @param {string | null} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersAdminUsersGet(
      username?: string | null,
      isAdmin?: boolean | null,
      limit?: number | null,
      offset?: number | null,
      orderBy?: string | null,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .getUsersAdminUsersGet(username, isAdmin, limit, offset, orderBy, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Make or remove admin privilege from a user
     * @summary Make Admin
     * @param {string} username
     * @param {PostMakeAdmin} postMakeAdmin
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    makeAdminAdminUsersUsernameMakeAdminPost(
      username: string,
      postMakeAdmin: PostMakeAdmin,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .makeAdminAdminUsersUsernameMakeAdminPost(username, postMakeAdmin, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete a permission from a role
     * @summary Remove Role Permission
     * @param {string} role
     * @param {Permission} permission
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeRolePermissionAdminRolesRolePermissionsRemovePost(
      role: string,
      permission: Permission,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .removeRolePermissionAdminRolesRolePermissionsRemovePost(
          role,
          permission,
          authorization,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Set the roles of a user
     * @summary Set User Roles
     * @param {string} username
     * @param {Array<PostRoles>} postRoles
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserRolesAdminUsersUsernameRolesPut(
      username: string,
      postRoles: Array<PostRoles>,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .setUserRolesAdminUsersUsernameRolesPut(username, postRoles, authorization, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
  /**
   * Add a permission to a role
   * @summary Add Role Permission
   * @param {string} role
   * @param {Permission} permission
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public addRolePermissionAdminRolesRolePermissionsPost(
    role: string,
    permission: Permission,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .addRolePermissionAdminRolesRolePermissionsPost(role, permission, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Add role to a user
   * @summary Add User Role
   * @param {string} username
   * @param {PostRoles} postRoles
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public addUserRoleAdminUsersUsernameRolesPost(
    username: string,
    postRoles: PostRoles,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .addUserRoleAdminUsersUsernameRolesPost(username, postRoles, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a new role
   * @summary Create Role
   * @param {PostRoles} postRoles
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public createRoleAdminRolesPost(
    postRoles: PostRoles,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .createRoleAdminRolesPost(postRoles, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a user
   * @summary Create User
   * @param {PostUsers} postUsers
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public createUserAdminUsersPost(
    postUsers: PostUsers,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .createUserAdminUsersPost(postUsers, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete a role
   * @summary Delete Role
   * @param {string} role
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public deleteRoleAdminRolesRoleDelete(
    role: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .deleteRoleAdminRolesRoleDelete(role, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete a user  This only performs a soft delete, while the user is deleted from the app database, it still exists in the idp so they can still log in, the user will then be re-created with the default permissions.
   * @summary Delete User
   * @param {string} username
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public deleteUserAdminUsersUsernameDelete(
    username: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .deleteUserAdminUsersUsernameDelete(username, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Remove role from a user
   * @summary Delete User Role
   * @param {string} username
   * @param {string} role
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public deleteUserRoleAdminUsersUsernameRolesRoleDelete(
    username: string,
    role: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .deleteUserRoleAdminUsersUsernameRolesRoleDelete(username, role, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get all permissions of a role
   * @summary Get Role Permissions
   * @param {string} role
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public getRolePermissionsAdminRolesRolePermissionsGet(
    role: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .getRolePermissionsAdminRolesRolePermissionsGet(role, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get all roles
   * @summary Get Roles
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public getRolesAdminRolesGet(authorization?: string | null, options?: RawAxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .getRolesAdminRolesGet(authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a user
   * @summary Get User
   * @param {string} username
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public getUserAdminUsersUsernameGet(
    username: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .getUserAdminUsersUsernameGet(username, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Search users
   * @summary Get Users
   * @param {string | null} [username] filters username that starts with the value
   * @param {boolean | null} [isAdmin]
   * @param {number | null} [limit] defaults to 100
   * @param {number | null} [offset] defaults to 0
   * @param {string | null} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public getUsersAdminUsersGet(
    username?: string | null,
    isAdmin?: boolean | null,
    limit?: number | null,
    offset?: number | null,
    orderBy?: string | null,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .getUsersAdminUsersGet(username, isAdmin, limit, offset, orderBy, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Make or remove admin privilege from a user
   * @summary Make Admin
   * @param {string} username
   * @param {PostMakeAdmin} postMakeAdmin
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public makeAdminAdminUsersUsernameMakeAdminPost(
    username: string,
    postMakeAdmin: PostMakeAdmin,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .makeAdminAdminUsersUsernameMakeAdminPost(username, postMakeAdmin, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete a permission from a role
   * @summary Remove Role Permission
   * @param {string} role
   * @param {Permission} permission
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public removeRolePermissionAdminRolesRolePermissionsRemovePost(
    role: string,
    permission: Permission,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .removeRolePermissionAdminRolesRolePermissionsRemovePost(
        role,
        permission,
        authorization,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Set the roles of a user
   * @summary Set User Roles
   * @param {string} username
   * @param {Array<PostRoles>} postRoles
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public setUserRolesAdminUsersUsernameRolesPut(
    username: string,
    postRoles: Array<PostRoles>,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .setUserRolesAdminUsersUsernameRolesPut(username, postRoles, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * AlertsApi - axios parameter creator
 * @export
 */
export const AlertsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Acknowledge Alert
     * @param {string} alertId
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    acknowledgeAlertAlertsAlertIdPost: async (
      alertId: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'alertId' is not null or undefined
      assertParamExists('acknowledgeAlertAlertsAlertIdPost', 'alertId', alertId);
      const localVarPath = `/alerts/{alert_id}`.replace(
        `{${'alert_id'}}`,
        encodeURIComponent(String(alertId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create Alert
     * @param {string} alertId
     * @param {string} category
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAlertAlertsPost: async (
      alertId: string,
      category: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'alertId' is not null or undefined
      assertParamExists('createAlertAlertsPost', 'alertId', alertId);
      // verify required parameter 'category' is not null or undefined
      assertParamExists('createAlertAlertsPost', 'category', category);
      const localVarPath = `/alerts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (alertId !== undefined) {
        localVarQueryParameter['alert_id'] = alertId;
      }

      if (category !== undefined) {
        localVarQueryParameter['category'] = category;
      }

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Alert
     * @param {string} alertId
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAlertAlertsAlertIdGet: async (
      alertId: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'alertId' is not null or undefined
      assertParamExists('getAlertAlertsAlertIdGet', 'alertId', alertId);
      const localVarPath = `/alerts/{alert_id}`.replace(
        `{${'alert_id'}}`,
        encodeURIComponent(String(alertId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Alerts
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAlertsAlertsGet: async (
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/alerts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AlertsApi - functional programming interface
 * @export
 */
export const AlertsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AlertsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Acknowledge Alert
     * @param {string} alertId
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async acknowledgeAlertAlertsAlertIdPost(
      alertId: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<TortoiseContribPydanticCreatorApiServerModelsTortoiseModelsAlertsAlertLeaf>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.acknowledgeAlertAlertsAlertIdPost(
        alertId,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AlertsApi.acknowledgeAlertAlertsAlertIdPost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Create Alert
     * @param {string} alertId
     * @param {string} category
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createAlertAlertsPost(
      alertId: string,
      category: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<TortoiseContribPydanticCreatorApiServerModelsTortoiseModelsAlertsAlertLeaf>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createAlertAlertsPost(
        alertId,
        category,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AlertsApi.createAlertAlertsPost']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get Alert
     * @param {string} alertId
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAlertAlertsAlertIdGet(
      alertId: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<TortoiseContribPydanticCreatorApiServerModelsTortoiseModelsAlertsAlertLeaf>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAlertAlertsAlertIdGet(
        alertId,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AlertsApi.getAlertAlertsAlertIdGet']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get Alerts
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAlertsAlertsGet(
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<
        Array<TortoiseContribPydanticCreatorApiServerModelsTortoiseModelsAlertsAlertLeaf>
      >
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAlertsAlertsGet(
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AlertsApi.getAlertsAlertsGet']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * AlertsApi - factory interface
 * @export
 */
export const AlertsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AlertsApiFp(configuration);
  return {
    /**
     *
     * @summary Acknowledge Alert
     * @param {string} alertId
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    acknowledgeAlertAlertsAlertIdPost(
      alertId: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<TortoiseContribPydanticCreatorApiServerModelsTortoiseModelsAlertsAlertLeaf> {
      return localVarFp
        .acknowledgeAlertAlertsAlertIdPost(alertId, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create Alert
     * @param {string} alertId
     * @param {string} category
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAlertAlertsPost(
      alertId: string,
      category: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<TortoiseContribPydanticCreatorApiServerModelsTortoiseModelsAlertsAlertLeaf> {
      return localVarFp
        .createAlertAlertsPost(alertId, category, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Alert
     * @param {string} alertId
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAlertAlertsAlertIdGet(
      alertId: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<TortoiseContribPydanticCreatorApiServerModelsTortoiseModelsAlertsAlertLeaf> {
      return localVarFp
        .getAlertAlertsAlertIdGet(alertId, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Alerts
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAlertsAlertsGet(
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<
      Array<TortoiseContribPydanticCreatorApiServerModelsTortoiseModelsAlertsAlertLeaf>
    > {
      return localVarFp
        .getAlertsAlertsGet(authorization, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AlertsApi - object-oriented interface
 * @export
 * @class AlertsApi
 * @extends {BaseAPI}
 */
export class AlertsApi extends BaseAPI {
  /**
   *
   * @summary Acknowledge Alert
   * @param {string} alertId
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AlertsApi
   */
  public acknowledgeAlertAlertsAlertIdPost(
    alertId: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return AlertsApiFp(this.configuration)
      .acknowledgeAlertAlertsAlertIdPost(alertId, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create Alert
   * @param {string} alertId
   * @param {string} category
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AlertsApi
   */
  public createAlertAlertsPost(
    alertId: string,
    category: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return AlertsApiFp(this.configuration)
      .createAlertAlertsPost(alertId, category, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Alert
   * @param {string} alertId
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AlertsApi
   */
  public getAlertAlertsAlertIdGet(
    alertId: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return AlertsApiFp(this.configuration)
      .getAlertAlertsAlertIdGet(alertId, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Alerts
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AlertsApi
   */
  public getAlertsAlertsGet(authorization?: string | null, options?: RawAxiosRequestConfig) {
    return AlertsApiFp(this.configuration)
      .getAlertsAlertsGet(authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * BeaconsApi - axios parameter creator
 * @export
 */
export const BeaconsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get Beacon
     * @param {string} beaconId
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBeaconBeaconsBeaconIdGet: async (
      beaconId: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'beaconId' is not null or undefined
      assertParamExists('getBeaconBeaconsBeaconIdGet', 'beaconId', beaconId);
      const localVarPath = `/beacons/{beacon_id}`.replace(
        `{${'beacon_id'}}`,
        encodeURIComponent(String(beaconId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Beacons
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBeaconsBeaconsGet: async (
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/beacons`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Save Beacon State
     * @param {string} beaconId
     * @param {boolean} online
     * @param {string} category
     * @param {boolean} activated
     * @param {string} level
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveBeaconStateBeaconsPost: async (
      beaconId: string,
      online: boolean,
      category: string,
      activated: boolean,
      level: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'beaconId' is not null or undefined
      assertParamExists('saveBeaconStateBeaconsPost', 'beaconId', beaconId);
      // verify required parameter 'online' is not null or undefined
      assertParamExists('saveBeaconStateBeaconsPost', 'online', online);
      // verify required parameter 'category' is not null or undefined
      assertParamExists('saveBeaconStateBeaconsPost', 'category', category);
      // verify required parameter 'activated' is not null or undefined
      assertParamExists('saveBeaconStateBeaconsPost', 'activated', activated);
      // verify required parameter 'level' is not null or undefined
      assertParamExists('saveBeaconStateBeaconsPost', 'level', level);
      const localVarPath = `/beacons`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (beaconId !== undefined) {
        localVarQueryParameter['beacon_id'] = beaconId;
      }

      if (online !== undefined) {
        localVarQueryParameter['online'] = online;
      }

      if (category !== undefined) {
        localVarQueryParameter['category'] = category;
      }

      if (activated !== undefined) {
        localVarQueryParameter['activated'] = activated;
      }

      if (level !== undefined) {
        localVarQueryParameter['level'] = level;
      }

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * BeaconsApi - functional programming interface
 * @export
 */
export const BeaconsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = BeaconsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Get Beacon
     * @param {string} beaconId
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBeaconBeaconsBeaconIdGet(
      beaconId: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<TortoiseContribPydanticCreatorApiServerModelsTortoiseModelsBeaconsBeaconStateLeaf>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBeaconBeaconsBeaconIdGet(
        beaconId,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BeaconsApi.getBeaconBeaconsBeaconIdGet']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get Beacons
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBeaconsBeaconsGet(
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<
        Array<TortoiseContribPydanticCreatorApiServerModelsTortoiseModelsBeaconsBeaconStateLeaf>
      >
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBeaconsBeaconsGet(
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BeaconsApi.getBeaconsBeaconsGet']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Save Beacon State
     * @param {string} beaconId
     * @param {boolean} online
     * @param {string} category
     * @param {boolean} activated
     * @param {string} level
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async saveBeaconStateBeaconsPost(
      beaconId: string,
      online: boolean,
      category: string,
      activated: boolean,
      level: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<TortoiseContribPydanticCreatorApiServerModelsTortoiseModelsBeaconsBeaconStateLeaf>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.saveBeaconStateBeaconsPost(
        beaconId,
        online,
        category,
        activated,
        level,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BeaconsApi.saveBeaconStateBeaconsPost']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * BeaconsApi - factory interface
 * @export
 */
export const BeaconsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = BeaconsApiFp(configuration);
  return {
    /**
     *
     * @summary Get Beacon
     * @param {string} beaconId
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBeaconBeaconsBeaconIdGet(
      beaconId: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<TortoiseContribPydanticCreatorApiServerModelsTortoiseModelsBeaconsBeaconStateLeaf> {
      return localVarFp
        .getBeaconBeaconsBeaconIdGet(beaconId, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Beacons
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBeaconsBeaconsGet(
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<
      Array<TortoiseContribPydanticCreatorApiServerModelsTortoiseModelsBeaconsBeaconStateLeaf>
    > {
      return localVarFp
        .getBeaconsBeaconsGet(authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Save Beacon State
     * @param {string} beaconId
     * @param {boolean} online
     * @param {string} category
     * @param {boolean} activated
     * @param {string} level
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveBeaconStateBeaconsPost(
      beaconId: string,
      online: boolean,
      category: string,
      activated: boolean,
      level: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<TortoiseContribPydanticCreatorApiServerModelsTortoiseModelsBeaconsBeaconStateLeaf> {
      return localVarFp
        .saveBeaconStateBeaconsPost(
          beaconId,
          online,
          category,
          activated,
          level,
          authorization,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * BeaconsApi - object-oriented interface
 * @export
 * @class BeaconsApi
 * @extends {BaseAPI}
 */
export class BeaconsApi extends BaseAPI {
  /**
   *
   * @summary Get Beacon
   * @param {string} beaconId
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconsApi
   */
  public getBeaconBeaconsBeaconIdGet(
    beaconId: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return BeaconsApiFp(this.configuration)
      .getBeaconBeaconsBeaconIdGet(beaconId, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Beacons
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconsApi
   */
  public getBeaconsBeaconsGet(authorization?: string | null, options?: RawAxiosRequestConfig) {
    return BeaconsApiFp(this.configuration)
      .getBeaconsBeaconsGet(authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Save Beacon State
   * @param {string} beaconId
   * @param {boolean} online
   * @param {string} category
   * @param {boolean} activated
   * @param {string} level
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BeaconsApi
   */
  public saveBeaconStateBeaconsPost(
    beaconId: string,
    online: boolean,
    category: string,
    activated: boolean,
    level: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return BeaconsApiFp(this.configuration)
      .saveBeaconStateBeaconsPost(
        beaconId,
        online,
        category,
        activated,
        level,
        authorization,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * BuildingApi - axios parameter creator
 * @export
 */
export const BuildingApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Available in socket.io
     * @summary Get Building Map
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildingMapBuildingMapGet: async (
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/building_map`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * BuildingApi - functional programming interface
 * @export
 */
export const BuildingApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = BuildingApiAxiosParamCreator(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Building Map
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBuildingMapBuildingMapGet(
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BuildingMap>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBuildingMapBuildingMapGet(
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildingApi.getBuildingMapBuildingMapGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * BuildingApi - factory interface
 * @export
 */
export const BuildingApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = BuildingApiFp(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Building Map
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildingMapBuildingMapGet(
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<BuildingMap> {
      return localVarFp
        .getBuildingMapBuildingMapGet(authorization, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * BuildingApi - object-oriented interface
 * @export
 * @class BuildingApi
 * @extends {BaseAPI}
 */
export class BuildingApi extends BaseAPI {
  /**
   * Available in socket.io
   * @summary Get Building Map
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildingApi
   */
  public getBuildingMapBuildingMapGet(
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return BuildingApiFp(this.configuration)
      .getBuildingMapBuildingMapGet(authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Get the effective permissions of the current user
     * @summary Get Effective Permissions
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEffectivePermissionsPermissionsGet: async (
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/permissions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the current rmf time in unix milliseconds
     * @summary Get Time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTimeTimeGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/time`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the currently logged in user
     * @summary Get User
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserUserGet: async (
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/user`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * # NOTE: This endpoint is here for documentation purposes only, this is _not_ a REST endpoint.  ## About This exposes a minimal pubsub system built on top of socket.io. It works similar to a normal socket.io endpoint, except that are 2 special rooms which control subscriptions.  ## Rooms ### subscribe Clients must send a message to this room to start receiving messages on other rooms. The message must be of the form:  ``` {     \"room\": \"<room_name>\" } ```  ### unsubscribe Clients can send a message to this room to stop receiving messages on other rooms. The message must be of the form:  ``` {     \"room\": \"<room_name>\" } ``` ### /alerts   ``` {   \"additionalProperties\": false,   \"description\": \"General alert that can be triggered by events.\",   \"properties\": {     \"id\": {       \"maxLength\": 255,       \"title\": \"Id\",       \"type\": \"string\"     },     \"original_id\": {       \"maxLength\": 255,       \"title\": \"Original Id\",       \"type\": \"string\"     },     \"category\": {       \"description\": \"Default: default<br/>Task: task<br/>Fleet: fleet<br/>Robot: robot\",       \"maxLength\": 7,       \"title\": \"Category\",       \"type\": \"string\"     },     \"unix_millis_created_time\": {       \"maximum\": 9223372036854775807,       \"minimum\": -9223372036854775808,       \"title\": \"Unix Millis Created Time\",       \"type\": \"integer\"     },     \"acknowledged_by\": {       \"anyOf\": [         {           \"maxLength\": 255,           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"nullable\": true,       \"title\": \"Acknowledged By\"     },     \"unix_millis_acknowledged_time\": {       \"anyOf\": [         {           \"maximum\": 9223372036854775807,           \"minimum\": -9223372036854775808,           \"type\": \"integer\"         },         {           \"type\": \"null\"         }       ],       \"nullable\": true,       \"title\": \"Unix Millis Acknowledged Time\"     }   },   \"required\": [     \"id\",     \"original_id\",     \"category\",     \"unix_millis_created_time\",     \"acknowledged_by\",     \"unix_millis_acknowledged_time\"   ],   \"title\": \"Alert\",   \"type\": \"object\" } ```   ### /beacons   ``` {   \"additionalProperties\": false,   \"properties\": {     \"id\": {       \"maxLength\": 255,       \"title\": \"Id\",       \"type\": \"string\"     },     \"online\": {       \"title\": \"Online\",       \"type\": \"boolean\"     },     \"category\": {       \"anyOf\": [         {           \"maxLength\": 255,           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"nullable\": true,       \"title\": \"Category\"     },     \"activated\": {       \"title\": \"Activated\",       \"type\": \"boolean\"     },     \"level\": {       \"anyOf\": [         {           \"maxLength\": 255,           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"nullable\": true,       \"title\": \"Level\"     }   },   \"required\": [     \"id\",     \"online\",     \"category\",     \"activated\",     \"level\"   ],   \"title\": \"BeaconState\",   \"type\": \"object\" } ```   ### /building_map   ``` {   \"$defs\": {     \"AffineImage\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"x_offset\": {           \"title\": \"X Offset\",           \"type\": \"number\"         },         \"y_offset\": {           \"title\": \"Y Offset\",           \"type\": \"number\"         },         \"yaw\": {           \"title\": \"Yaw\",           \"type\": \"number\"         },         \"scale\": {           \"title\": \"Scale\",           \"type\": \"number\"         },         \"encoding\": {           \"title\": \"Encoding\",           \"type\": \"string\"         },         \"data\": {           \"title\": \"Data\",           \"type\": \"string\"         }       },       \"required\": [         \"name\",         \"x_offset\",         \"y_offset\",         \"yaw\",         \"scale\",         \"encoding\",         \"data\"       ],       \"title\": \"AffineImage\",       \"type\": \"object\"     },     \"Door\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"v1_x\": {           \"title\": \"V1 X\",           \"type\": \"number\"         },         \"v1_y\": {           \"title\": \"V1 Y\",           \"type\": \"number\"         },         \"v2_x\": {           \"title\": \"V2 X\",           \"type\": \"number\"         },         \"v2_y\": {           \"title\": \"V2 Y\",           \"type\": \"number\"         },         \"door_type\": {           \"maximum\": 255,           \"minimum\": 0,           \"title\": \"Door Type\",           \"type\": \"integer\"         },         \"motion_range\": {           \"title\": \"Motion Range\",           \"type\": \"number\"         },         \"motion_direction\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Motion Direction\",           \"type\": \"integer\"         }       },       \"required\": [         \"name\",         \"v1_x\",         \"v1_y\",         \"v2_x\",         \"v2_y\",         \"door_type\",         \"motion_range\",         \"motion_direction\"       ],       \"title\": \"Door\",       \"type\": \"object\"     },     \"Graph\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"vertices\": {           \"items\": {             \"$ref\": \"#/$defs/GraphNode\"           },           \"title\": \"Vertices\",           \"type\": \"array\"         },         \"edges\": {           \"items\": {             \"$ref\": \"#/$defs/GraphEdge\"           },           \"title\": \"Edges\",           \"type\": \"array\"         },         \"params\": {           \"items\": {             \"$ref\": \"#/$defs/Param\"           },           \"title\": \"Params\",           \"type\": \"array\"         }       },       \"required\": [         \"name\",         \"vertices\",         \"edges\",         \"params\"       ],       \"title\": \"Graph\",       \"type\": \"object\"     },     \"GraphEdge\": {       \"properties\": {         \"v1_idx\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"V1 Idx\",           \"type\": \"integer\"         },         \"v2_idx\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"V2 Idx\",           \"type\": \"integer\"         },         \"params\": {           \"items\": {             \"$ref\": \"#/$defs/Param\"           },           \"title\": \"Params\",           \"type\": \"array\"         },         \"edge_type\": {           \"maximum\": 255,           \"minimum\": 0,           \"title\": \"Edge Type\",           \"type\": \"integer\"         }       },       \"required\": [         \"v1_idx\",         \"v2_idx\",         \"params\",         \"edge_type\"       ],       \"title\": \"GraphEdge\",       \"type\": \"object\"     },     \"GraphNode\": {       \"properties\": {         \"x\": {           \"title\": \"X\",           \"type\": \"number\"         },         \"y\": {           \"title\": \"Y\",           \"type\": \"number\"         },         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"params\": {           \"items\": {             \"$ref\": \"#/$defs/Param\"           },           \"title\": \"Params\",           \"type\": \"array\"         }       },       \"required\": [         \"x\",         \"y\",         \"name\",         \"params\"       ],       \"title\": \"GraphNode\",       \"type\": \"object\"     },     \"Level\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"elevation\": {           \"title\": \"Elevation\",           \"type\": \"number\"         },         \"images\": {           \"items\": {             \"$ref\": \"#/$defs/AffineImage\"           },           \"title\": \"Images\",           \"type\": \"array\"         },         \"places\": {           \"items\": {             \"$ref\": \"#/$defs/Place\"           },           \"title\": \"Places\",           \"type\": \"array\"         },         \"doors\": {           \"items\": {             \"$ref\": \"#/$defs/Door\"           },           \"title\": \"Doors\",           \"type\": \"array\"         },         \"nav_graphs\": {           \"items\": {             \"$ref\": \"#/$defs/Graph\"           },           \"title\": \"Nav Graphs\",           \"type\": \"array\"         },         \"wall_graph\": {           \"$ref\": \"#/$defs/Graph\"         }       },       \"required\": [         \"name\",         \"elevation\",         \"images\",         \"places\",         \"doors\",         \"nav_graphs\",         \"wall_graph\"       ],       \"title\": \"Level\",       \"type\": \"object\"     },     \"Lift\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"levels\": {           \"items\": {             \"type\": \"string\"           },           \"title\": \"Levels\",           \"type\": \"array\"         },         \"doors\": {           \"items\": {             \"$ref\": \"#/$defs/Door\"           },           \"title\": \"Doors\",           \"type\": \"array\"         },         \"wall_graph\": {           \"$ref\": \"#/$defs/Graph\"         },         \"ref_x\": {           \"title\": \"Ref X\",           \"type\": \"number\"         },         \"ref_y\": {           \"title\": \"Ref Y\",           \"type\": \"number\"         },         \"ref_yaw\": {           \"title\": \"Ref Yaw\",           \"type\": \"number\"         },         \"width\": {           \"title\": \"Width\",           \"type\": \"number\"         },         \"depth\": {           \"title\": \"Depth\",           \"type\": \"number\"         }       },       \"required\": [         \"name\",         \"levels\",         \"doors\",         \"wall_graph\",         \"ref_x\",         \"ref_y\",         \"ref_yaw\",         \"width\",         \"depth\"       ],       \"title\": \"Lift\",       \"type\": \"object\"     },     \"Param\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"type\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Type\",           \"type\": \"integer\"         },         \"value_int\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Value Int\",           \"type\": \"integer\"         },         \"value_float\": {           \"title\": \"Value Float\",           \"type\": \"number\"         },         \"value_string\": {           \"title\": \"Value String\",           \"type\": \"string\"         },         \"value_bool\": {           \"title\": \"Value Bool\",           \"type\": \"boolean\"         }       },       \"required\": [         \"name\",         \"type\",         \"value_int\",         \"value_float\",         \"value_string\",         \"value_bool\"       ],       \"title\": \"Param\",       \"type\": \"object\"     },     \"Place\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"x\": {           \"title\": \"X\",           \"type\": \"number\"         },         \"y\": {           \"title\": \"Y\",           \"type\": \"number\"         },         \"yaw\": {           \"title\": \"Yaw\",           \"type\": \"number\"         },         \"position_tolerance\": {           \"title\": \"Position Tolerance\",           \"type\": \"number\"         },         \"yaw_tolerance\": {           \"title\": \"Yaw Tolerance\",           \"type\": \"number\"         }       },       \"required\": [         \"name\",         \"x\",         \"y\",         \"yaw\",         \"position_tolerance\",         \"yaw_tolerance\"       ],       \"title\": \"Place\",       \"type\": \"object\"     }   },   \"properties\": {     \"name\": {       \"title\": \"Name\",       \"type\": \"string\"     },     \"levels\": {       \"items\": {         \"$ref\": \"#/$defs/Level\"       },       \"title\": \"Levels\",       \"type\": \"array\"     },     \"lifts\": {       \"items\": {         \"$ref\": \"#/$defs/Lift\"       },       \"title\": \"Lifts\",       \"type\": \"array\"     }   },   \"required\": [     \"name\",     \"levels\",     \"lifts\"   ],   \"title\": \"BuildingMap\",   \"type\": \"object\" } ```   ### /doors/{door_name}/state   ``` {   \"$defs\": {     \"DoorMode\": {       \"properties\": {         \"value\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Value\",           \"type\": \"integer\"         }       },       \"required\": [         \"value\"       ],       \"title\": \"DoorMode\",       \"type\": \"object\"     },     \"Time\": {       \"properties\": {         \"sec\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Sec\",           \"type\": \"integer\"         },         \"nanosec\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Nanosec\",           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ],       \"title\": \"Time\",       \"type\": \"object\"     }   },   \"properties\": {     \"door_time\": {       \"$ref\": \"#/$defs/Time\"     },     \"door_name\": {       \"title\": \"Door Name\",       \"type\": \"string\"     },     \"current_mode\": {       \"$ref\": \"#/$defs/DoorMode\"     }   },   \"required\": [     \"door_time\",     \"door_name\",     \"current_mode\"   ],   \"title\": \"DoorState\",   \"type\": \"object\" } ```   ### /doors/{door_name}/health   ``` {   \"$defs\": {     \"HealthStatus\": {       \"enum\": [         \"Healthy\",         \"Unhealthy\",         \"Dead\"       ],       \"title\": \"HealthStatus\",       \"type\": \"string\"     }   },   \"properties\": {     \"id_\": {       \"title\": \"Id \",       \"type\": \"string\"     },     \"health_status\": {       \"$ref\": \"#/$defs/HealthStatus\"     },     \"health_message\": {       \"anyOf\": [         {           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"title\": \"Health Message\"     }   },   \"required\": [     \"id_\",     \"health_status\",     \"health_message\"   ],   \"title\": \"DoorHealth\",   \"type\": \"object\" } ```   ### /lifts/{lift_name}/state   ``` {   \"$defs\": {     \"Time\": {       \"properties\": {         \"sec\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Sec\",           \"type\": \"integer\"         },         \"nanosec\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Nanosec\",           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ],       \"title\": \"Time\",       \"type\": \"object\"     }   },   \"properties\": {     \"lift_time\": {       \"$ref\": \"#/$defs/Time\"     },     \"lift_name\": {       \"title\": \"Lift Name\",       \"type\": \"string\"     },     \"available_floors\": {       \"items\": {         \"type\": \"string\"       },       \"title\": \"Available Floors\",       \"type\": \"array\"     },     \"current_floor\": {       \"title\": \"Current Floor\",       \"type\": \"string\"     },     \"destination_floor\": {       \"title\": \"Destination Floor\",       \"type\": \"string\"     },     \"door_state\": {       \"maximum\": 255,       \"minimum\": 0,       \"title\": \"Door State\",       \"type\": \"integer\"     },     \"motion_state\": {       \"maximum\": 255,       \"minimum\": 0,       \"title\": \"Motion State\",       \"type\": \"integer\"     },     \"available_modes\": {       \"items\": {         \"type\": \"integer\"       },       \"title\": \"Available Modes\",       \"type\": \"array\"     },     \"current_mode\": {       \"maximum\": 255,       \"minimum\": 0,       \"title\": \"Current Mode\",       \"type\": \"integer\"     },     \"session_id\": {       \"title\": \"Session Id\",       \"type\": \"string\"     }   },   \"required\": [     \"lift_time\",     \"lift_name\",     \"available_floors\",     \"current_floor\",     \"destination_floor\",     \"door_state\",     \"motion_state\",     \"available_modes\",     \"current_mode\",     \"session_id\"   ],   \"title\": \"LiftState\",   \"type\": \"object\" } ```   ### /lifts/{lift_name}/health   ``` {   \"$defs\": {     \"HealthStatus\": {       \"enum\": [         \"Healthy\",         \"Unhealthy\",         \"Dead\"       ],       \"title\": \"HealthStatus\",       \"type\": \"string\"     }   },   \"properties\": {     \"id_\": {       \"title\": \"Id \",       \"type\": \"string\"     },     \"health_status\": {       \"$ref\": \"#/$defs/HealthStatus\"     },     \"health_message\": {       \"anyOf\": [         {           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"title\": \"Health Message\"     }   },   \"required\": [     \"id_\",     \"health_status\",     \"health_message\"   ],   \"title\": \"LiftHealth\",   \"type\": \"object\" } ```   ### /tasks/{task_id}/state   ``` {   \"$defs\": {     \"AssignedTo\": {       \"properties\": {         \"group\": {           \"title\": \"Group\",           \"type\": \"string\"         },         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         }       },       \"required\": [         \"group\",         \"name\"       ],       \"title\": \"AssignedTo\",       \"type\": \"object\"     },     \"Assignment\": {       \"properties\": {         \"fleet_name\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Fleet Name\"         },         \"expected_robot_name\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Expected Robot Name\"         }       },       \"title\": \"Assignment\",       \"type\": \"object\"     },     \"Booking\": {       \"properties\": {         \"id\": {           \"description\": \"The unique identifier for this task\",           \"title\": \"Id\",           \"type\": \"string\"         },         \"unix_millis_earliest_start_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Unix Millis Earliest Start Time\"         },         \"unix_millis_request_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Unix Millis Request Time\"         },         \"priority\": {           \"anyOf\": [             {               \"type\": \"object\"             },             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Priority information about this task\",           \"title\": \"Priority\"         },         \"labels\": {           \"anyOf\": [             {               \"items\": {                 \"type\": \"string\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Information about how and why this task was booked\",           \"title\": \"Labels\"         },         \"requester\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"(Optional) An identifier for the entity that requested this task\",           \"title\": \"Requester\"         }       },       \"required\": [         \"id\"       ],       \"title\": \"Booking\",       \"type\": \"object\"     },     \"Cancellation\": {       \"properties\": {         \"unix_millis_request_time\": {           \"description\": \"The time that the cancellation request arrived\",           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"labels\": {           \"description\": \"Labels to describe the cancel request\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ],       \"title\": \"Cancellation\",       \"type\": \"object\"     },     \"Category\": {       \"title\": \"Category\",       \"type\": \"string\"     },     \"Detail\": {       \"anyOf\": [         {           \"type\": \"object\"         },         {           \"items\": {},           \"type\": \"array\"         },         {           \"type\": \"string\"         }       ],       \"title\": \"Detail\"     },     \"Dispatch\": {       \"properties\": {         \"status\": {           \"$ref\": \"#/$defs/Status2\"         },         \"assignment\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Assignment\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"errors\": {           \"anyOf\": [             {               \"items\": {                 \"$ref\": \"#/$defs/Error\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Errors\"         }       },       \"required\": [         \"status\"       ],       \"title\": \"Dispatch\",       \"type\": \"object\"     },     \"Error\": {       \"properties\": {         \"code\": {           \"anyOf\": [             {               \"minimum\": 0,               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A standard code for the kind of error that has occurred\",           \"title\": \"Code\"         },         \"category\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"The category of the error\",           \"title\": \"Category\"         },         \"detail\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Details about the error\",           \"title\": \"Detail\"         }       },       \"title\": \"Error\",       \"type\": \"object\"     },     \"EstimateMillis\": {       \"minimum\": 0,       \"title\": \"EstimateMillis\",       \"type\": \"integer\"     },     \"EventState\": {       \"properties\": {         \"id\": {           \"$ref\": \"#/$defs/Id\"         },         \"status\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Status\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"name\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"The brief name of the event\",           \"title\": \"Name\"         },         \"detail\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Detail\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Detailed information about the event\"         },         \"deps\": {           \"anyOf\": [             {               \"items\": {                 \"minimum\": 0,                 \"type\": \"integer\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"This event may depend on other events. This array contains the IDs of those other event dependencies.\",           \"title\": \"Deps\"         }       },       \"required\": [         \"id\"       ],       \"title\": \"EventState\",       \"type\": \"object\"     },     \"Id\": {       \"minimum\": 0,       \"title\": \"Id\",       \"type\": \"integer\"     },     \"Interruption\": {       \"properties\": {         \"unix_millis_request_time\": {           \"description\": \"The time that the interruption request arrived\",           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"labels\": {           \"description\": \"Labels to describe the purpose of the interruption\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         },         \"resumed_by\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/ResumedBy\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Information about the resume request that ended this interruption. This field will be missing if the interruption is still active.\"         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ],       \"title\": \"Interruption\",       \"type\": \"object\"     },     \"Killed\": {       \"properties\": {         \"unix_millis_request_time\": {           \"description\": \"The time that the cancellation request arrived\",           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"labels\": {           \"description\": \"Labels to describe the kill request\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ],       \"title\": \"Killed\",       \"type\": \"object\"     },     \"Phase\": {       \"properties\": {         \"id\": {           \"$ref\": \"#/$defs/Id\"         },         \"category\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Category\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"detail\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Detail\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"unix_millis_start_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Unix Millis Start Time\"         },         \"unix_millis_finish_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Unix Millis Finish Time\"         },         \"original_estimate_millis\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/EstimateMillis\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"estimate_millis\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/EstimateMillis\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"final_event_id\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Id\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"events\": {           \"anyOf\": [             {               \"additionalProperties\": {                 \"$ref\": \"#/$defs/EventState\"               },               \"type\": \"object\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A dictionary of events for this phase. The keys (property names) are the event IDs, which are integers.\",           \"title\": \"Events\"         },         \"skip_requests\": {           \"anyOf\": [             {               \"additionalProperties\": {                 \"$ref\": \"#/$defs/SkipPhaseRequest\"               },               \"type\": \"object\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Information about any skip requests that have been received\",           \"title\": \"Skip Requests\"         }       },       \"required\": [         \"id\"       ],       \"title\": \"Phase\",       \"type\": \"object\"     },     \"ResumedBy\": {       \"properties\": {         \"unix_millis_request_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"The time that the resume request arrived\",           \"title\": \"Unix Millis Request Time\"         },         \"labels\": {           \"description\": \"Labels to describe the resume request\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         }       },       \"required\": [         \"labels\"       ],       \"title\": \"ResumedBy\",       \"type\": \"object\"     },     \"SkipPhaseRequest\": {       \"properties\": {         \"unix_millis_request_time\": {           \"description\": \"The time that the skip request arrived\",           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"labels\": {           \"description\": \"Labels to describe the purpose of the skip request\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         },         \"undo\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Undo\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Information about an undo skip request that applied to this request\"         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ],       \"title\": \"SkipPhaseRequest\",       \"type\": \"object\"     },     \"Status\": {       \"enum\": [         \"uninitialized\",         \"blocked\",         \"error\",         \"failed\",         \"queued\",         \"standby\",         \"underway\",         \"delayed\",         \"skipped\",         \"canceled\",         \"killed\",         \"completed\"       ],       \"title\": \"Status\",       \"type\": \"string\"     },     \"Status2\": {       \"enum\": [         \"queued\",         \"selected\",         \"dispatched\",         \"failed_to_assign\",         \"canceled_in_flight\"       ],       \"title\": \"Status2\",       \"type\": \"string\"     },     \"Undo\": {       \"properties\": {         \"unix_millis_request_time\": {           \"description\": \"The time that the undo skip request arrived\",           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"labels\": {           \"description\": \"Labels to describe the undo skip request\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ],       \"title\": \"Undo\",       \"type\": \"object\"     }   },   \"properties\": {     \"booking\": {       \"$ref\": \"#/$defs/Booking\"     },     \"category\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Category\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"detail\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Detail\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"unix_millis_start_time\": {       \"anyOf\": [         {           \"type\": \"integer\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"title\": \"Unix Millis Start Time\"     },     \"unix_millis_finish_time\": {       \"anyOf\": [         {           \"type\": \"integer\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"title\": \"Unix Millis Finish Time\"     },     \"original_estimate_millis\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/EstimateMillis\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"estimate_millis\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/EstimateMillis\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"assigned_to\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/AssignedTo\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"Which agent (robot) is the task assigned to\"     },     \"status\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Status\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"dispatch\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Dispatch\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"phases\": {       \"anyOf\": [         {           \"additionalProperties\": {             \"$ref\": \"#/$defs/Phase\"           },           \"type\": \"object\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"A dictionary of the states of the phases of the task. The keys (property names) are phase IDs, which are integers.\",       \"title\": \"Phases\"     },     \"completed\": {       \"anyOf\": [         {           \"items\": {             \"$ref\": \"#/$defs/Id\"           },           \"type\": \"array\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"An array of the IDs of completed phases of this task\",       \"title\": \"Completed\"     },     \"active\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Id\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"The ID of the active phase for this task\"     },     \"pending\": {       \"anyOf\": [         {           \"items\": {             \"$ref\": \"#/$defs/Id\"           },           \"type\": \"array\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"An array of the pending phases of this task\",       \"title\": \"Pending\"     },     \"interruptions\": {       \"anyOf\": [         {           \"additionalProperties\": {             \"$ref\": \"#/$defs/Interruption\"           },           \"type\": \"object\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"A dictionary of interruptions that have been applied to this task. The keys (property names) are the unique token of the interruption request.\",       \"title\": \"Interruptions\"     },     \"cancellation\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Cancellation\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"If the task was cancelled, this will describe information about the request.\"     },     \"killed\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Killed\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"If the task was killed, this will describe information about the request.\"     }   },   \"required\": [     \"booking\"   ],   \"title\": \"TaskState\",   \"type\": \"object\" } ```   ### /tasks/{task_id}/log   ``` {   \"$defs\": {     \"LogEntry\": {       \"properties\": {         \"seq\": {           \"description\": \"Sequence number for this entry. Each entry has a unique sequence number which monotonically increase, until integer overflow causes a wrap around.\",           \"exclusiveMaximum\": 4294967296,           \"minimum\": 0,           \"title\": \"Seq\",           \"type\": \"integer\"         },         \"tier\": {           \"allOf\": [             {               \"$ref\": \"#/$defs/Tier\"             }           ],           \"description\": \"The importance level of the log entry\"         },         \"unix_millis_time\": {           \"title\": \"Unix Millis Time\",           \"type\": \"integer\"         },         \"text\": {           \"description\": \"The text of the log entry\",           \"title\": \"Text\",           \"type\": \"string\"         }       },       \"required\": [         \"seq\",         \"tier\",         \"unix_millis_time\",         \"text\"       ],       \"title\": \"LogEntry\",       \"type\": \"object\"     },     \"Phases\": {       \"additionalProperties\": false,       \"properties\": {         \"log\": {           \"anyOf\": [             {               \"items\": {                 \"$ref\": \"#/$defs/LogEntry\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Log entries related to the overall phase\",           \"title\": \"Log\"         },         \"events\": {           \"anyOf\": [             {               \"additionalProperties\": {                 \"items\": {                   \"$ref\": \"#/$defs/LogEntry\"                 },                 \"type\": \"array\"               },               \"type\": \"object\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A dictionary whose keys (property names) are the indices of an event in the phase\",           \"title\": \"Events\"         }       },       \"title\": \"Phases\",       \"type\": \"object\"     },     \"Tier\": {       \"enum\": [         \"uninitialized\",         \"info\",         \"warning\",         \"error\"       ],       \"title\": \"Tier\",       \"type\": \"string\"     }   },   \"additionalProperties\": false,   \"properties\": {     \"task_id\": {       \"title\": \"Task Id\",       \"type\": \"string\"     },     \"log\": {       \"anyOf\": [         {           \"items\": {             \"$ref\": \"#/$defs/LogEntry\"           },           \"type\": \"array\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"Log entries related to the overall task\",       \"title\": \"Log\"     },     \"phases\": {       \"anyOf\": [         {           \"additionalProperties\": {             \"$ref\": \"#/$defs/Phases\"           },           \"type\": \"object\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"A dictionary whose keys (property names) are the indices of a phase\",       \"title\": \"Phases\"     }   },   \"required\": [     \"task_id\"   ],   \"title\": \"TaskEventLog\",   \"type\": \"object\" } ```   ### /dispensers/{guid}/state   ``` {   \"$defs\": {     \"Time\": {       \"properties\": {         \"sec\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Sec\",           \"type\": \"integer\"         },         \"nanosec\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Nanosec\",           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ],       \"title\": \"Time\",       \"type\": \"object\"     }   },   \"properties\": {     \"time\": {       \"$ref\": \"#/$defs/Time\"     },     \"guid\": {       \"title\": \"Guid\",       \"type\": \"string\"     },     \"mode\": {       \"maximum\": 2147483647,       \"minimum\": -2147483648,       \"title\": \"Mode\",       \"type\": \"integer\"     },     \"request_guid_queue\": {       \"items\": {         \"type\": \"string\"       },       \"title\": \"Request Guid Queue\",       \"type\": \"array\"     },     \"seconds_remaining\": {       \"title\": \"Seconds Remaining\",       \"type\": \"number\"     }   },   \"required\": [     \"time\",     \"guid\",     \"mode\",     \"request_guid_queue\",     \"seconds_remaining\"   ],   \"title\": \"DispenserState\",   \"type\": \"object\" } ```   ### /dispensers/{guid}/health   ``` {   \"$defs\": {     \"HealthStatus\": {       \"enum\": [         \"Healthy\",         \"Unhealthy\",         \"Dead\"       ],       \"title\": \"HealthStatus\",       \"type\": \"string\"     }   },   \"properties\": {     \"id_\": {       \"title\": \"Id \",       \"type\": \"string\"     },     \"health_status\": {       \"$ref\": \"#/$defs/HealthStatus\"     },     \"health_message\": {       \"anyOf\": [         {           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"title\": \"Health Message\"     }   },   \"required\": [     \"id_\",     \"health_status\",     \"health_message\"   ],   \"title\": \"DispenserHealth\",   \"type\": \"object\" } ```   ### /ingestors/{guid}/state   ``` {   \"$defs\": {     \"Time\": {       \"properties\": {         \"sec\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Sec\",           \"type\": \"integer\"         },         \"nanosec\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Nanosec\",           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ],       \"title\": \"Time\",       \"type\": \"object\"     }   },   \"properties\": {     \"time\": {       \"$ref\": \"#/$defs/Time\"     },     \"guid\": {       \"title\": \"Guid\",       \"type\": \"string\"     },     \"mode\": {       \"maximum\": 2147483647,       \"minimum\": -2147483648,       \"title\": \"Mode\",       \"type\": \"integer\"     },     \"request_guid_queue\": {       \"items\": {         \"type\": \"string\"       },       \"title\": \"Request Guid Queue\",       \"type\": \"array\"     },     \"seconds_remaining\": {       \"title\": \"Seconds Remaining\",       \"type\": \"number\"     }   },   \"required\": [     \"time\",     \"guid\",     \"mode\",     \"request_guid_queue\",     \"seconds_remaining\"   ],   \"title\": \"IngestorState\",   \"type\": \"object\" } ```   ### /ingestors/{guid}/health   ``` {   \"$defs\": {     \"HealthStatus\": {       \"enum\": [         \"Healthy\",         \"Unhealthy\",         \"Dead\"       ],       \"title\": \"HealthStatus\",       \"type\": \"string\"     }   },   \"properties\": {     \"id_\": {       \"title\": \"Id \",       \"type\": \"string\"     },     \"health_status\": {       \"$ref\": \"#/$defs/HealthStatus\"     },     \"health_message\": {       \"anyOf\": [         {           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"title\": \"Health Message\"     }   },   \"required\": [     \"id_\",     \"health_status\",     \"health_message\"   ],   \"title\": \"IngestorHealth\",   \"type\": \"object\" } ```   ### /fleets/{name}/state   ``` {   \"$defs\": {     \"Issue\": {       \"properties\": {         \"category\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Category of the robot\'s issue\",           \"title\": \"Category\"         },         \"detail\": {           \"anyOf\": [             {               \"type\": \"object\"             },             {               \"items\": {},               \"type\": \"array\"             },             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Detailed information about the issue\",           \"title\": \"Detail\"         }       },       \"title\": \"Issue\",       \"type\": \"object\"     },     \"Location2D\": {       \"properties\": {         \"map\": {           \"title\": \"Map\",           \"type\": \"string\"         },         \"x\": {           \"title\": \"X\",           \"type\": \"number\"         },         \"y\": {           \"title\": \"Y\",           \"type\": \"number\"         },         \"yaw\": {           \"title\": \"Yaw\",           \"type\": \"number\"         }       },       \"required\": [         \"map\",         \"x\",         \"y\",         \"yaw\"       ],       \"title\": \"Location2D\",       \"type\": \"object\"     },     \"RobotState\": {       \"properties\": {         \"name\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Name\"         },         \"status\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Status\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A simple token representing the status of the robot\"         },         \"task_id\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"The ID of the task this robot is currently working on. Empty string if the robot is not working on a task.\",           \"title\": \"Task Id\"         },         \"unix_millis_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Unix Millis Time\"         },         \"location\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Location2D\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"battery\": {           \"anyOf\": [             {               \"maximum\": 1.0,               \"minimum\": 0.0,               \"type\": \"number\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"State of charge of the battery. Values range from 0.0 (depleted) to 1.0 (fully charged)\",           \"title\": \"Battery\"         },         \"issues\": {           \"anyOf\": [             {               \"items\": {                 \"$ref\": \"#/$defs/Issue\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A list of issues with the robot that operators need to address\",           \"title\": \"Issues\"         }       },       \"title\": \"RobotState\",       \"type\": \"object\"     },     \"Status\": {       \"enum\": [         \"uninitialized\",         \"offline\",         \"shutdown\",         \"idle\",         \"charging\",         \"working\",         \"error\"       ],       \"title\": \"Status\",       \"type\": \"string\"     }   },   \"properties\": {     \"name\": {       \"anyOf\": [         {           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"title\": \"Name\"     },     \"robots\": {       \"anyOf\": [         {           \"additionalProperties\": {             \"$ref\": \"#/$defs/RobotState\"           },           \"type\": \"object\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"A dictionary of the states of the robots that belong to this fleet\",       \"title\": \"Robots\"     }   },   \"title\": \"FleetState\",   \"type\": \"object\" } ```   ### /fleets/{name}/log   ``` {   \"$defs\": {     \"LogEntry\": {       \"properties\": {         \"seq\": {           \"description\": \"Sequence number for this entry. Each entry has a unique sequence number which monotonically increase, until integer overflow causes a wrap around.\",           \"exclusiveMaximum\": 4294967296,           \"minimum\": 0,           \"title\": \"Seq\",           \"type\": \"integer\"         },         \"tier\": {           \"allOf\": [             {               \"$ref\": \"#/$defs/Tier\"             }           ],           \"description\": \"The importance level of the log entry\"         },         \"unix_millis_time\": {           \"title\": \"Unix Millis Time\",           \"type\": \"integer\"         },         \"text\": {           \"description\": \"The text of the log entry\",           \"title\": \"Text\",           \"type\": \"string\"         }       },       \"required\": [         \"seq\",         \"tier\",         \"unix_millis_time\",         \"text\"       ],       \"title\": \"LogEntry\",       \"type\": \"object\"     },     \"Tier\": {       \"enum\": [         \"uninitialized\",         \"info\",         \"warning\",         \"error\"       ],       \"title\": \"Tier\",       \"type\": \"string\"     }   },   \"properties\": {     \"name\": {       \"anyOf\": [         {           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"title\": \"Name\"     },     \"log\": {       \"anyOf\": [         {           \"items\": {             \"$ref\": \"#/$defs/LogEntry\"           },           \"type\": \"array\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"Log for the overall fleet\",       \"title\": \"Log\"     },     \"robots\": {       \"anyOf\": [         {           \"additionalProperties\": {             \"items\": {               \"$ref\": \"#/$defs/LogEntry\"             },             \"type\": \"array\"           },           \"type\": \"object\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"Dictionary of logs for the individual robots. The keys (property names) are the robot names.\",       \"title\": \"Robots\"     }   },   \"title\": \"FleetLog\",   \"type\": \"object\" } ```
     * @summary Socket.io endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lambdaSocketIoGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/socket.io`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration);
  return {
    /**
     * Get the effective permissions of the current user
     * @summary Get Effective Permissions
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEffectivePermissionsPermissionsGet(
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Permission>>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getEffectivePermissionsPermissionsGet(
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.getEffectivePermissionsPermissionsGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get the current rmf time in unix milliseconds
     * @summary Get Time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTimeTimeGet(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTimeTimeGet(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.getTimeTimeGet']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get the currently logged in user
     * @summary Get User
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserUserGet(
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserUserGet(
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.getUserUserGet']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * # NOTE: This endpoint is here for documentation purposes only, this is _not_ a REST endpoint.  ## About This exposes a minimal pubsub system built on top of socket.io. It works similar to a normal socket.io endpoint, except that are 2 special rooms which control subscriptions.  ## Rooms ### subscribe Clients must send a message to this room to start receiving messages on other rooms. The message must be of the form:  ``` {     \"room\": \"<room_name>\" } ```  ### unsubscribe Clients can send a message to this room to stop receiving messages on other rooms. The message must be of the form:  ``` {     \"room\": \"<room_name>\" } ``` ### /alerts   ``` {   \"additionalProperties\": false,   \"description\": \"General alert that can be triggered by events.\",   \"properties\": {     \"id\": {       \"maxLength\": 255,       \"title\": \"Id\",       \"type\": \"string\"     },     \"original_id\": {       \"maxLength\": 255,       \"title\": \"Original Id\",       \"type\": \"string\"     },     \"category\": {       \"description\": \"Default: default<br/>Task: task<br/>Fleet: fleet<br/>Robot: robot\",       \"maxLength\": 7,       \"title\": \"Category\",       \"type\": \"string\"     },     \"unix_millis_created_time\": {       \"maximum\": 9223372036854775807,       \"minimum\": -9223372036854775808,       \"title\": \"Unix Millis Created Time\",       \"type\": \"integer\"     },     \"acknowledged_by\": {       \"anyOf\": [         {           \"maxLength\": 255,           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"nullable\": true,       \"title\": \"Acknowledged By\"     },     \"unix_millis_acknowledged_time\": {       \"anyOf\": [         {           \"maximum\": 9223372036854775807,           \"minimum\": -9223372036854775808,           \"type\": \"integer\"         },         {           \"type\": \"null\"         }       ],       \"nullable\": true,       \"title\": \"Unix Millis Acknowledged Time\"     }   },   \"required\": [     \"id\",     \"original_id\",     \"category\",     \"unix_millis_created_time\",     \"acknowledged_by\",     \"unix_millis_acknowledged_time\"   ],   \"title\": \"Alert\",   \"type\": \"object\" } ```   ### /beacons   ``` {   \"additionalProperties\": false,   \"properties\": {     \"id\": {       \"maxLength\": 255,       \"title\": \"Id\",       \"type\": \"string\"     },     \"online\": {       \"title\": \"Online\",       \"type\": \"boolean\"     },     \"category\": {       \"anyOf\": [         {           \"maxLength\": 255,           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"nullable\": true,       \"title\": \"Category\"     },     \"activated\": {       \"title\": \"Activated\",       \"type\": \"boolean\"     },     \"level\": {       \"anyOf\": [         {           \"maxLength\": 255,           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"nullable\": true,       \"title\": \"Level\"     }   },   \"required\": [     \"id\",     \"online\",     \"category\",     \"activated\",     \"level\"   ],   \"title\": \"BeaconState\",   \"type\": \"object\" } ```   ### /building_map   ``` {   \"$defs\": {     \"AffineImage\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"x_offset\": {           \"title\": \"X Offset\",           \"type\": \"number\"         },         \"y_offset\": {           \"title\": \"Y Offset\",           \"type\": \"number\"         },         \"yaw\": {           \"title\": \"Yaw\",           \"type\": \"number\"         },         \"scale\": {           \"title\": \"Scale\",           \"type\": \"number\"         },         \"encoding\": {           \"title\": \"Encoding\",           \"type\": \"string\"         },         \"data\": {           \"title\": \"Data\",           \"type\": \"string\"         }       },       \"required\": [         \"name\",         \"x_offset\",         \"y_offset\",         \"yaw\",         \"scale\",         \"encoding\",         \"data\"       ],       \"title\": \"AffineImage\",       \"type\": \"object\"     },     \"Door\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"v1_x\": {           \"title\": \"V1 X\",           \"type\": \"number\"         },         \"v1_y\": {           \"title\": \"V1 Y\",           \"type\": \"number\"         },         \"v2_x\": {           \"title\": \"V2 X\",           \"type\": \"number\"         },         \"v2_y\": {           \"title\": \"V2 Y\",           \"type\": \"number\"         },         \"door_type\": {           \"maximum\": 255,           \"minimum\": 0,           \"title\": \"Door Type\",           \"type\": \"integer\"         },         \"motion_range\": {           \"title\": \"Motion Range\",           \"type\": \"number\"         },         \"motion_direction\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Motion Direction\",           \"type\": \"integer\"         }       },       \"required\": [         \"name\",         \"v1_x\",         \"v1_y\",         \"v2_x\",         \"v2_y\",         \"door_type\",         \"motion_range\",         \"motion_direction\"       ],       \"title\": \"Door\",       \"type\": \"object\"     },     \"Graph\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"vertices\": {           \"items\": {             \"$ref\": \"#/$defs/GraphNode\"           },           \"title\": \"Vertices\",           \"type\": \"array\"         },         \"edges\": {           \"items\": {             \"$ref\": \"#/$defs/GraphEdge\"           },           \"title\": \"Edges\",           \"type\": \"array\"         },         \"params\": {           \"items\": {             \"$ref\": \"#/$defs/Param\"           },           \"title\": \"Params\",           \"type\": \"array\"         }       },       \"required\": [         \"name\",         \"vertices\",         \"edges\",         \"params\"       ],       \"title\": \"Graph\",       \"type\": \"object\"     },     \"GraphEdge\": {       \"properties\": {         \"v1_idx\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"V1 Idx\",           \"type\": \"integer\"         },         \"v2_idx\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"V2 Idx\",           \"type\": \"integer\"         },         \"params\": {           \"items\": {             \"$ref\": \"#/$defs/Param\"           },           \"title\": \"Params\",           \"type\": \"array\"         },         \"edge_type\": {           \"maximum\": 255,           \"minimum\": 0,           \"title\": \"Edge Type\",           \"type\": \"integer\"         }       },       \"required\": [         \"v1_idx\",         \"v2_idx\",         \"params\",         \"edge_type\"       ],       \"title\": \"GraphEdge\",       \"type\": \"object\"     },     \"GraphNode\": {       \"properties\": {         \"x\": {           \"title\": \"X\",           \"type\": \"number\"         },         \"y\": {           \"title\": \"Y\",           \"type\": \"number\"         },         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"params\": {           \"items\": {             \"$ref\": \"#/$defs/Param\"           },           \"title\": \"Params\",           \"type\": \"array\"         }       },       \"required\": [         \"x\",         \"y\",         \"name\",         \"params\"       ],       \"title\": \"GraphNode\",       \"type\": \"object\"     },     \"Level\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"elevation\": {           \"title\": \"Elevation\",           \"type\": \"number\"         },         \"images\": {           \"items\": {             \"$ref\": \"#/$defs/AffineImage\"           },           \"title\": \"Images\",           \"type\": \"array\"         },         \"places\": {           \"items\": {             \"$ref\": \"#/$defs/Place\"           },           \"title\": \"Places\",           \"type\": \"array\"         },         \"doors\": {           \"items\": {             \"$ref\": \"#/$defs/Door\"           },           \"title\": \"Doors\",           \"type\": \"array\"         },         \"nav_graphs\": {           \"items\": {             \"$ref\": \"#/$defs/Graph\"           },           \"title\": \"Nav Graphs\",           \"type\": \"array\"         },         \"wall_graph\": {           \"$ref\": \"#/$defs/Graph\"         }       },       \"required\": [         \"name\",         \"elevation\",         \"images\",         \"places\",         \"doors\",         \"nav_graphs\",         \"wall_graph\"       ],       \"title\": \"Level\",       \"type\": \"object\"     },     \"Lift\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"levels\": {           \"items\": {             \"type\": \"string\"           },           \"title\": \"Levels\",           \"type\": \"array\"         },         \"doors\": {           \"items\": {             \"$ref\": \"#/$defs/Door\"           },           \"title\": \"Doors\",           \"type\": \"array\"         },         \"wall_graph\": {           \"$ref\": \"#/$defs/Graph\"         },         \"ref_x\": {           \"title\": \"Ref X\",           \"type\": \"number\"         },         \"ref_y\": {           \"title\": \"Ref Y\",           \"type\": \"number\"         },         \"ref_yaw\": {           \"title\": \"Ref Yaw\",           \"type\": \"number\"         },         \"width\": {           \"title\": \"Width\",           \"type\": \"number\"         },         \"depth\": {           \"title\": \"Depth\",           \"type\": \"number\"         }       },       \"required\": [         \"name\",         \"levels\",         \"doors\",         \"wall_graph\",         \"ref_x\",         \"ref_y\",         \"ref_yaw\",         \"width\",         \"depth\"       ],       \"title\": \"Lift\",       \"type\": \"object\"     },     \"Param\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"type\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Type\",           \"type\": \"integer\"         },         \"value_int\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Value Int\",           \"type\": \"integer\"         },         \"value_float\": {           \"title\": \"Value Float\",           \"type\": \"number\"         },         \"value_string\": {           \"title\": \"Value String\",           \"type\": \"string\"         },         \"value_bool\": {           \"title\": \"Value Bool\",           \"type\": \"boolean\"         }       },       \"required\": [         \"name\",         \"type\",         \"value_int\",         \"value_float\",         \"value_string\",         \"value_bool\"       ],       \"title\": \"Param\",       \"type\": \"object\"     },     \"Place\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"x\": {           \"title\": \"X\",           \"type\": \"number\"         },         \"y\": {           \"title\": \"Y\",           \"type\": \"number\"         },         \"yaw\": {           \"title\": \"Yaw\",           \"type\": \"number\"         },         \"position_tolerance\": {           \"title\": \"Position Tolerance\",           \"type\": \"number\"         },         \"yaw_tolerance\": {           \"title\": \"Yaw Tolerance\",           \"type\": \"number\"         }       },       \"required\": [         \"name\",         \"x\",         \"y\",         \"yaw\",         \"position_tolerance\",         \"yaw_tolerance\"       ],       \"title\": \"Place\",       \"type\": \"object\"     }   },   \"properties\": {     \"name\": {       \"title\": \"Name\",       \"type\": \"string\"     },     \"levels\": {       \"items\": {         \"$ref\": \"#/$defs/Level\"       },       \"title\": \"Levels\",       \"type\": \"array\"     },     \"lifts\": {       \"items\": {         \"$ref\": \"#/$defs/Lift\"       },       \"title\": \"Lifts\",       \"type\": \"array\"     }   },   \"required\": [     \"name\",     \"levels\",     \"lifts\"   ],   \"title\": \"BuildingMap\",   \"type\": \"object\" } ```   ### /doors/{door_name}/state   ``` {   \"$defs\": {     \"DoorMode\": {       \"properties\": {         \"value\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Value\",           \"type\": \"integer\"         }       },       \"required\": [         \"value\"       ],       \"title\": \"DoorMode\",       \"type\": \"object\"     },     \"Time\": {       \"properties\": {         \"sec\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Sec\",           \"type\": \"integer\"         },         \"nanosec\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Nanosec\",           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ],       \"title\": \"Time\",       \"type\": \"object\"     }   },   \"properties\": {     \"door_time\": {       \"$ref\": \"#/$defs/Time\"     },     \"door_name\": {       \"title\": \"Door Name\",       \"type\": \"string\"     },     \"current_mode\": {       \"$ref\": \"#/$defs/DoorMode\"     }   },   \"required\": [     \"door_time\",     \"door_name\",     \"current_mode\"   ],   \"title\": \"DoorState\",   \"type\": \"object\" } ```   ### /doors/{door_name}/health   ``` {   \"$defs\": {     \"HealthStatus\": {       \"enum\": [         \"Healthy\",         \"Unhealthy\",         \"Dead\"       ],       \"title\": \"HealthStatus\",       \"type\": \"string\"     }   },   \"properties\": {     \"id_\": {       \"title\": \"Id \",       \"type\": \"string\"     },     \"health_status\": {       \"$ref\": \"#/$defs/HealthStatus\"     },     \"health_message\": {       \"anyOf\": [         {           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"title\": \"Health Message\"     }   },   \"required\": [     \"id_\",     \"health_status\",     \"health_message\"   ],   \"title\": \"DoorHealth\",   \"type\": \"object\" } ```   ### /lifts/{lift_name}/state   ``` {   \"$defs\": {     \"Time\": {       \"properties\": {         \"sec\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Sec\",           \"type\": \"integer\"         },         \"nanosec\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Nanosec\",           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ],       \"title\": \"Time\",       \"type\": \"object\"     }   },   \"properties\": {     \"lift_time\": {       \"$ref\": \"#/$defs/Time\"     },     \"lift_name\": {       \"title\": \"Lift Name\",       \"type\": \"string\"     },     \"available_floors\": {       \"items\": {         \"type\": \"string\"       },       \"title\": \"Available Floors\",       \"type\": \"array\"     },     \"current_floor\": {       \"title\": \"Current Floor\",       \"type\": \"string\"     },     \"destination_floor\": {       \"title\": \"Destination Floor\",       \"type\": \"string\"     },     \"door_state\": {       \"maximum\": 255,       \"minimum\": 0,       \"title\": \"Door State\",       \"type\": \"integer\"     },     \"motion_state\": {       \"maximum\": 255,       \"minimum\": 0,       \"title\": \"Motion State\",       \"type\": \"integer\"     },     \"available_modes\": {       \"items\": {         \"type\": \"integer\"       },       \"title\": \"Available Modes\",       \"type\": \"array\"     },     \"current_mode\": {       \"maximum\": 255,       \"minimum\": 0,       \"title\": \"Current Mode\",       \"type\": \"integer\"     },     \"session_id\": {       \"title\": \"Session Id\",       \"type\": \"string\"     }   },   \"required\": [     \"lift_time\",     \"lift_name\",     \"available_floors\",     \"current_floor\",     \"destination_floor\",     \"door_state\",     \"motion_state\",     \"available_modes\",     \"current_mode\",     \"session_id\"   ],   \"title\": \"LiftState\",   \"type\": \"object\" } ```   ### /lifts/{lift_name}/health   ``` {   \"$defs\": {     \"HealthStatus\": {       \"enum\": [         \"Healthy\",         \"Unhealthy\",         \"Dead\"       ],       \"title\": \"HealthStatus\",       \"type\": \"string\"     }   },   \"properties\": {     \"id_\": {       \"title\": \"Id \",       \"type\": \"string\"     },     \"health_status\": {       \"$ref\": \"#/$defs/HealthStatus\"     },     \"health_message\": {       \"anyOf\": [         {           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"title\": \"Health Message\"     }   },   \"required\": [     \"id_\",     \"health_status\",     \"health_message\"   ],   \"title\": \"LiftHealth\",   \"type\": \"object\" } ```   ### /tasks/{task_id}/state   ``` {   \"$defs\": {     \"AssignedTo\": {       \"properties\": {         \"group\": {           \"title\": \"Group\",           \"type\": \"string\"         },         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         }       },       \"required\": [         \"group\",         \"name\"       ],       \"title\": \"AssignedTo\",       \"type\": \"object\"     },     \"Assignment\": {       \"properties\": {         \"fleet_name\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Fleet Name\"         },         \"expected_robot_name\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Expected Robot Name\"         }       },       \"title\": \"Assignment\",       \"type\": \"object\"     },     \"Booking\": {       \"properties\": {         \"id\": {           \"description\": \"The unique identifier for this task\",           \"title\": \"Id\",           \"type\": \"string\"         },         \"unix_millis_earliest_start_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Unix Millis Earliest Start Time\"         },         \"unix_millis_request_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Unix Millis Request Time\"         },         \"priority\": {           \"anyOf\": [             {               \"type\": \"object\"             },             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Priority information about this task\",           \"title\": \"Priority\"         },         \"labels\": {           \"anyOf\": [             {               \"items\": {                 \"type\": \"string\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Information about how and why this task was booked\",           \"title\": \"Labels\"         },         \"requester\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"(Optional) An identifier for the entity that requested this task\",           \"title\": \"Requester\"         }       },       \"required\": [         \"id\"       ],       \"title\": \"Booking\",       \"type\": \"object\"     },     \"Cancellation\": {       \"properties\": {         \"unix_millis_request_time\": {           \"description\": \"The time that the cancellation request arrived\",           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"labels\": {           \"description\": \"Labels to describe the cancel request\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ],       \"title\": \"Cancellation\",       \"type\": \"object\"     },     \"Category\": {       \"title\": \"Category\",       \"type\": \"string\"     },     \"Detail\": {       \"anyOf\": [         {           \"type\": \"object\"         },         {           \"items\": {},           \"type\": \"array\"         },         {           \"type\": \"string\"         }       ],       \"title\": \"Detail\"     },     \"Dispatch\": {       \"properties\": {         \"status\": {           \"$ref\": \"#/$defs/Status2\"         },         \"assignment\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Assignment\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"errors\": {           \"anyOf\": [             {               \"items\": {                 \"$ref\": \"#/$defs/Error\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Errors\"         }       },       \"required\": [         \"status\"       ],       \"title\": \"Dispatch\",       \"type\": \"object\"     },     \"Error\": {       \"properties\": {         \"code\": {           \"anyOf\": [             {               \"minimum\": 0,               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A standard code for the kind of error that has occurred\",           \"title\": \"Code\"         },         \"category\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"The category of the error\",           \"title\": \"Category\"         },         \"detail\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Details about the error\",           \"title\": \"Detail\"         }       },       \"title\": \"Error\",       \"type\": \"object\"     },     \"EstimateMillis\": {       \"minimum\": 0,       \"title\": \"EstimateMillis\",       \"type\": \"integer\"     },     \"EventState\": {       \"properties\": {         \"id\": {           \"$ref\": \"#/$defs/Id\"         },         \"status\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Status\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"name\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"The brief name of the event\",           \"title\": \"Name\"         },         \"detail\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Detail\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Detailed information about the event\"         },         \"deps\": {           \"anyOf\": [             {               \"items\": {                 \"minimum\": 0,                 \"type\": \"integer\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"This event may depend on other events. This array contains the IDs of those other event dependencies.\",           \"title\": \"Deps\"         }       },       \"required\": [         \"id\"       ],       \"title\": \"EventState\",       \"type\": \"object\"     },     \"Id\": {       \"minimum\": 0,       \"title\": \"Id\",       \"type\": \"integer\"     },     \"Interruption\": {       \"properties\": {         \"unix_millis_request_time\": {           \"description\": \"The time that the interruption request arrived\",           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"labels\": {           \"description\": \"Labels to describe the purpose of the interruption\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         },         \"resumed_by\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/ResumedBy\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Information about the resume request that ended this interruption. This field will be missing if the interruption is still active.\"         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ],       \"title\": \"Interruption\",       \"type\": \"object\"     },     \"Killed\": {       \"properties\": {         \"unix_millis_request_time\": {           \"description\": \"The time that the cancellation request arrived\",           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"labels\": {           \"description\": \"Labels to describe the kill request\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ],       \"title\": \"Killed\",       \"type\": \"object\"     },     \"Phase\": {       \"properties\": {         \"id\": {           \"$ref\": \"#/$defs/Id\"         },         \"category\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Category\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"detail\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Detail\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"unix_millis_start_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Unix Millis Start Time\"         },         \"unix_millis_finish_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Unix Millis Finish Time\"         },         \"original_estimate_millis\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/EstimateMillis\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"estimate_millis\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/EstimateMillis\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"final_event_id\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Id\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"events\": {           \"anyOf\": [             {               \"additionalProperties\": {                 \"$ref\": \"#/$defs/EventState\"               },               \"type\": \"object\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A dictionary of events for this phase. The keys (property names) are the event IDs, which are integers.\",           \"title\": \"Events\"         },         \"skip_requests\": {           \"anyOf\": [             {               \"additionalProperties\": {                 \"$ref\": \"#/$defs/SkipPhaseRequest\"               },               \"type\": \"object\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Information about any skip requests that have been received\",           \"title\": \"Skip Requests\"         }       },       \"required\": [         \"id\"       ],       \"title\": \"Phase\",       \"type\": \"object\"     },     \"ResumedBy\": {       \"properties\": {         \"unix_millis_request_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"The time that the resume request arrived\",           \"title\": \"Unix Millis Request Time\"         },         \"labels\": {           \"description\": \"Labels to describe the resume request\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         }       },       \"required\": [         \"labels\"       ],       \"title\": \"ResumedBy\",       \"type\": \"object\"     },     \"SkipPhaseRequest\": {       \"properties\": {         \"unix_millis_request_time\": {           \"description\": \"The time that the skip request arrived\",           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"labels\": {           \"description\": \"Labels to describe the purpose of the skip request\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         },         \"undo\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Undo\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Information about an undo skip request that applied to this request\"         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ],       \"title\": \"SkipPhaseRequest\",       \"type\": \"object\"     },     \"Status\": {       \"enum\": [         \"uninitialized\",         \"blocked\",         \"error\",         \"failed\",         \"queued\",         \"standby\",         \"underway\",         \"delayed\",         \"skipped\",         \"canceled\",         \"killed\",         \"completed\"       ],       \"title\": \"Status\",       \"type\": \"string\"     },     \"Status2\": {       \"enum\": [         \"queued\",         \"selected\",         \"dispatched\",         \"failed_to_assign\",         \"canceled_in_flight\"       ],       \"title\": \"Status2\",       \"type\": \"string\"     },     \"Undo\": {       \"properties\": {         \"unix_millis_request_time\": {           \"description\": \"The time that the undo skip request arrived\",           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"labels\": {           \"description\": \"Labels to describe the undo skip request\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ],       \"title\": \"Undo\",       \"type\": \"object\"     }   },   \"properties\": {     \"booking\": {       \"$ref\": \"#/$defs/Booking\"     },     \"category\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Category\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"detail\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Detail\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"unix_millis_start_time\": {       \"anyOf\": [         {           \"type\": \"integer\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"title\": \"Unix Millis Start Time\"     },     \"unix_millis_finish_time\": {       \"anyOf\": [         {           \"type\": \"integer\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"title\": \"Unix Millis Finish Time\"     },     \"original_estimate_millis\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/EstimateMillis\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"estimate_millis\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/EstimateMillis\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"assigned_to\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/AssignedTo\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"Which agent (robot) is the task assigned to\"     },     \"status\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Status\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"dispatch\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Dispatch\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"phases\": {       \"anyOf\": [         {           \"additionalProperties\": {             \"$ref\": \"#/$defs/Phase\"           },           \"type\": \"object\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"A dictionary of the states of the phases of the task. The keys (property names) are phase IDs, which are integers.\",       \"title\": \"Phases\"     },     \"completed\": {       \"anyOf\": [         {           \"items\": {             \"$ref\": \"#/$defs/Id\"           },           \"type\": \"array\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"An array of the IDs of completed phases of this task\",       \"title\": \"Completed\"     },     \"active\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Id\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"The ID of the active phase for this task\"     },     \"pending\": {       \"anyOf\": [         {           \"items\": {             \"$ref\": \"#/$defs/Id\"           },           \"type\": \"array\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"An array of the pending phases of this task\",       \"title\": \"Pending\"     },     \"interruptions\": {       \"anyOf\": [         {           \"additionalProperties\": {             \"$ref\": \"#/$defs/Interruption\"           },           \"type\": \"object\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"A dictionary of interruptions that have been applied to this task. The keys (property names) are the unique token of the interruption request.\",       \"title\": \"Interruptions\"     },     \"cancellation\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Cancellation\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"If the task was cancelled, this will describe information about the request.\"     },     \"killed\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Killed\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"If the task was killed, this will describe information about the request.\"     }   },   \"required\": [     \"booking\"   ],   \"title\": \"TaskState\",   \"type\": \"object\" } ```   ### /tasks/{task_id}/log   ``` {   \"$defs\": {     \"LogEntry\": {       \"properties\": {         \"seq\": {           \"description\": \"Sequence number for this entry. Each entry has a unique sequence number which monotonically increase, until integer overflow causes a wrap around.\",           \"exclusiveMaximum\": 4294967296,           \"minimum\": 0,           \"title\": \"Seq\",           \"type\": \"integer\"         },         \"tier\": {           \"allOf\": [             {               \"$ref\": \"#/$defs/Tier\"             }           ],           \"description\": \"The importance level of the log entry\"         },         \"unix_millis_time\": {           \"title\": \"Unix Millis Time\",           \"type\": \"integer\"         },         \"text\": {           \"description\": \"The text of the log entry\",           \"title\": \"Text\",           \"type\": \"string\"         }       },       \"required\": [         \"seq\",         \"tier\",         \"unix_millis_time\",         \"text\"       ],       \"title\": \"LogEntry\",       \"type\": \"object\"     },     \"Phases\": {       \"additionalProperties\": false,       \"properties\": {         \"log\": {           \"anyOf\": [             {               \"items\": {                 \"$ref\": \"#/$defs/LogEntry\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Log entries related to the overall phase\",           \"title\": \"Log\"         },         \"events\": {           \"anyOf\": [             {               \"additionalProperties\": {                 \"items\": {                   \"$ref\": \"#/$defs/LogEntry\"                 },                 \"type\": \"array\"               },               \"type\": \"object\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A dictionary whose keys (property names) are the indices of an event in the phase\",           \"title\": \"Events\"         }       },       \"title\": \"Phases\",       \"type\": \"object\"     },     \"Tier\": {       \"enum\": [         \"uninitialized\",         \"info\",         \"warning\",         \"error\"       ],       \"title\": \"Tier\",       \"type\": \"string\"     }   },   \"additionalProperties\": false,   \"properties\": {     \"task_id\": {       \"title\": \"Task Id\",       \"type\": \"string\"     },     \"log\": {       \"anyOf\": [         {           \"items\": {             \"$ref\": \"#/$defs/LogEntry\"           },           \"type\": \"array\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"Log entries related to the overall task\",       \"title\": \"Log\"     },     \"phases\": {       \"anyOf\": [         {           \"additionalProperties\": {             \"$ref\": \"#/$defs/Phases\"           },           \"type\": \"object\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"A dictionary whose keys (property names) are the indices of a phase\",       \"title\": \"Phases\"     }   },   \"required\": [     \"task_id\"   ],   \"title\": \"TaskEventLog\",   \"type\": \"object\" } ```   ### /dispensers/{guid}/state   ``` {   \"$defs\": {     \"Time\": {       \"properties\": {         \"sec\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Sec\",           \"type\": \"integer\"         },         \"nanosec\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Nanosec\",           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ],       \"title\": \"Time\",       \"type\": \"object\"     }   },   \"properties\": {     \"time\": {       \"$ref\": \"#/$defs/Time\"     },     \"guid\": {       \"title\": \"Guid\",       \"type\": \"string\"     },     \"mode\": {       \"maximum\": 2147483647,       \"minimum\": -2147483648,       \"title\": \"Mode\",       \"type\": \"integer\"     },     \"request_guid_queue\": {       \"items\": {         \"type\": \"string\"       },       \"title\": \"Request Guid Queue\",       \"type\": \"array\"     },     \"seconds_remaining\": {       \"title\": \"Seconds Remaining\",       \"type\": \"number\"     }   },   \"required\": [     \"time\",     \"guid\",     \"mode\",     \"request_guid_queue\",     \"seconds_remaining\"   ],   \"title\": \"DispenserState\",   \"type\": \"object\" } ```   ### /dispensers/{guid}/health   ``` {   \"$defs\": {     \"HealthStatus\": {       \"enum\": [         \"Healthy\",         \"Unhealthy\",         \"Dead\"       ],       \"title\": \"HealthStatus\",       \"type\": \"string\"     }   },   \"properties\": {     \"id_\": {       \"title\": \"Id \",       \"type\": \"string\"     },     \"health_status\": {       \"$ref\": \"#/$defs/HealthStatus\"     },     \"health_message\": {       \"anyOf\": [         {           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"title\": \"Health Message\"     }   },   \"required\": [     \"id_\",     \"health_status\",     \"health_message\"   ],   \"title\": \"DispenserHealth\",   \"type\": \"object\" } ```   ### /ingestors/{guid}/state   ``` {   \"$defs\": {     \"Time\": {       \"properties\": {         \"sec\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Sec\",           \"type\": \"integer\"         },         \"nanosec\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Nanosec\",           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ],       \"title\": \"Time\",       \"type\": \"object\"     }   },   \"properties\": {     \"time\": {       \"$ref\": \"#/$defs/Time\"     },     \"guid\": {       \"title\": \"Guid\",       \"type\": \"string\"     },     \"mode\": {       \"maximum\": 2147483647,       \"minimum\": -2147483648,       \"title\": \"Mode\",       \"type\": \"integer\"     },     \"request_guid_queue\": {       \"items\": {         \"type\": \"string\"       },       \"title\": \"Request Guid Queue\",       \"type\": \"array\"     },     \"seconds_remaining\": {       \"title\": \"Seconds Remaining\",       \"type\": \"number\"     }   },   \"required\": [     \"time\",     \"guid\",     \"mode\",     \"request_guid_queue\",     \"seconds_remaining\"   ],   \"title\": \"IngestorState\",   \"type\": \"object\" } ```   ### /ingestors/{guid}/health   ``` {   \"$defs\": {     \"HealthStatus\": {       \"enum\": [         \"Healthy\",         \"Unhealthy\",         \"Dead\"       ],       \"title\": \"HealthStatus\",       \"type\": \"string\"     }   },   \"properties\": {     \"id_\": {       \"title\": \"Id \",       \"type\": \"string\"     },     \"health_status\": {       \"$ref\": \"#/$defs/HealthStatus\"     },     \"health_message\": {       \"anyOf\": [         {           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"title\": \"Health Message\"     }   },   \"required\": [     \"id_\",     \"health_status\",     \"health_message\"   ],   \"title\": \"IngestorHealth\",   \"type\": \"object\" } ```   ### /fleets/{name}/state   ``` {   \"$defs\": {     \"Issue\": {       \"properties\": {         \"category\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Category of the robot\'s issue\",           \"title\": \"Category\"         },         \"detail\": {           \"anyOf\": [             {               \"type\": \"object\"             },             {               \"items\": {},               \"type\": \"array\"             },             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Detailed information about the issue\",           \"title\": \"Detail\"         }       },       \"title\": \"Issue\",       \"type\": \"object\"     },     \"Location2D\": {       \"properties\": {         \"map\": {           \"title\": \"Map\",           \"type\": \"string\"         },         \"x\": {           \"title\": \"X\",           \"type\": \"number\"         },         \"y\": {           \"title\": \"Y\",           \"type\": \"number\"         },         \"yaw\": {           \"title\": \"Yaw\",           \"type\": \"number\"         }       },       \"required\": [         \"map\",         \"x\",         \"y\",         \"yaw\"       ],       \"title\": \"Location2D\",       \"type\": \"object\"     },     \"RobotState\": {       \"properties\": {         \"name\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Name\"         },         \"status\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Status\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A simple token representing the status of the robot\"         },         \"task_id\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"The ID of the task this robot is currently working on. Empty string if the robot is not working on a task.\",           \"title\": \"Task Id\"         },         \"unix_millis_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Unix Millis Time\"         },         \"location\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Location2D\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"battery\": {           \"anyOf\": [             {               \"maximum\": 1.0,               \"minimum\": 0.0,               \"type\": \"number\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"State of charge of the battery. Values range from 0.0 (depleted) to 1.0 (fully charged)\",           \"title\": \"Battery\"         },         \"issues\": {           \"anyOf\": [             {               \"items\": {                 \"$ref\": \"#/$defs/Issue\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A list of issues with the robot that operators need to address\",           \"title\": \"Issues\"         }       },       \"title\": \"RobotState\",       \"type\": \"object\"     },     \"Status\": {       \"enum\": [         \"uninitialized\",         \"offline\",         \"shutdown\",         \"idle\",         \"charging\",         \"working\",         \"error\"       ],       \"title\": \"Status\",       \"type\": \"string\"     }   },   \"properties\": {     \"name\": {       \"anyOf\": [         {           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"title\": \"Name\"     },     \"robots\": {       \"anyOf\": [         {           \"additionalProperties\": {             \"$ref\": \"#/$defs/RobotState\"           },           \"type\": \"object\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"A dictionary of the states of the robots that belong to this fleet\",       \"title\": \"Robots\"     }   },   \"title\": \"FleetState\",   \"type\": \"object\" } ```   ### /fleets/{name}/log   ``` {   \"$defs\": {     \"LogEntry\": {       \"properties\": {         \"seq\": {           \"description\": \"Sequence number for this entry. Each entry has a unique sequence number which monotonically increase, until integer overflow causes a wrap around.\",           \"exclusiveMaximum\": 4294967296,           \"minimum\": 0,           \"title\": \"Seq\",           \"type\": \"integer\"         },         \"tier\": {           \"allOf\": [             {               \"$ref\": \"#/$defs/Tier\"             }           ],           \"description\": \"The importance level of the log entry\"         },         \"unix_millis_time\": {           \"title\": \"Unix Millis Time\",           \"type\": \"integer\"         },         \"text\": {           \"description\": \"The text of the log entry\",           \"title\": \"Text\",           \"type\": \"string\"         }       },       \"required\": [         \"seq\",         \"tier\",         \"unix_millis_time\",         \"text\"       ],       \"title\": \"LogEntry\",       \"type\": \"object\"     },     \"Tier\": {       \"enum\": [         \"uninitialized\",         \"info\",         \"warning\",         \"error\"       ],       \"title\": \"Tier\",       \"type\": \"string\"     }   },   \"properties\": {     \"name\": {       \"anyOf\": [         {           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"title\": \"Name\"     },     \"log\": {       \"anyOf\": [         {           \"items\": {             \"$ref\": \"#/$defs/LogEntry\"           },           \"type\": \"array\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"Log for the overall fleet\",       \"title\": \"Log\"     },     \"robots\": {       \"anyOf\": [         {           \"additionalProperties\": {             \"items\": {               \"$ref\": \"#/$defs/LogEntry\"             },             \"type\": \"array\"           },           \"type\": \"object\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"Dictionary of logs for the individual robots. The keys (property names) are the robot names.\",       \"title\": \"Robots\"     }   },   \"title\": \"FleetLog\",   \"type\": \"object\" } ```
     * @summary Socket.io endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async lambdaSocketIoGet(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.lambdaSocketIoGet(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.lambdaSocketIoGet']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DefaultApiFp(configuration);
  return {
    /**
     * Get the effective permissions of the current user
     * @summary Get Effective Permissions
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEffectivePermissionsPermissionsGet(
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<Array<Permission>> {
      return localVarFp
        .getEffectivePermissionsPermissionsGet(authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get the current rmf time in unix milliseconds
     * @summary Get Time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTimeTimeGet(options?: any): AxiosPromise<number> {
      return localVarFp.getTimeTimeGet(options).then((request) => request(axios, basePath));
    },
    /**
     * Get the currently logged in user
     * @summary Get User
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserUserGet(authorization?: string | null, options?: any): AxiosPromise<User> {
      return localVarFp
        .getUserUserGet(authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * # NOTE: This endpoint is here for documentation purposes only, this is _not_ a REST endpoint.  ## About This exposes a minimal pubsub system built on top of socket.io. It works similar to a normal socket.io endpoint, except that are 2 special rooms which control subscriptions.  ## Rooms ### subscribe Clients must send a message to this room to start receiving messages on other rooms. The message must be of the form:  ``` {     \"room\": \"<room_name>\" } ```  ### unsubscribe Clients can send a message to this room to stop receiving messages on other rooms. The message must be of the form:  ``` {     \"room\": \"<room_name>\" } ``` ### /alerts   ``` {   \"additionalProperties\": false,   \"description\": \"General alert that can be triggered by events.\",   \"properties\": {     \"id\": {       \"maxLength\": 255,       \"title\": \"Id\",       \"type\": \"string\"     },     \"original_id\": {       \"maxLength\": 255,       \"title\": \"Original Id\",       \"type\": \"string\"     },     \"category\": {       \"description\": \"Default: default<br/>Task: task<br/>Fleet: fleet<br/>Robot: robot\",       \"maxLength\": 7,       \"title\": \"Category\",       \"type\": \"string\"     },     \"unix_millis_created_time\": {       \"maximum\": 9223372036854775807,       \"minimum\": -9223372036854775808,       \"title\": \"Unix Millis Created Time\",       \"type\": \"integer\"     },     \"acknowledged_by\": {       \"anyOf\": [         {           \"maxLength\": 255,           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"nullable\": true,       \"title\": \"Acknowledged By\"     },     \"unix_millis_acknowledged_time\": {       \"anyOf\": [         {           \"maximum\": 9223372036854775807,           \"minimum\": -9223372036854775808,           \"type\": \"integer\"         },         {           \"type\": \"null\"         }       ],       \"nullable\": true,       \"title\": \"Unix Millis Acknowledged Time\"     }   },   \"required\": [     \"id\",     \"original_id\",     \"category\",     \"unix_millis_created_time\",     \"acknowledged_by\",     \"unix_millis_acknowledged_time\"   ],   \"title\": \"Alert\",   \"type\": \"object\" } ```   ### /beacons   ``` {   \"additionalProperties\": false,   \"properties\": {     \"id\": {       \"maxLength\": 255,       \"title\": \"Id\",       \"type\": \"string\"     },     \"online\": {       \"title\": \"Online\",       \"type\": \"boolean\"     },     \"category\": {       \"anyOf\": [         {           \"maxLength\": 255,           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"nullable\": true,       \"title\": \"Category\"     },     \"activated\": {       \"title\": \"Activated\",       \"type\": \"boolean\"     },     \"level\": {       \"anyOf\": [         {           \"maxLength\": 255,           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"nullable\": true,       \"title\": \"Level\"     }   },   \"required\": [     \"id\",     \"online\",     \"category\",     \"activated\",     \"level\"   ],   \"title\": \"BeaconState\",   \"type\": \"object\" } ```   ### /building_map   ``` {   \"$defs\": {     \"AffineImage\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"x_offset\": {           \"title\": \"X Offset\",           \"type\": \"number\"         },         \"y_offset\": {           \"title\": \"Y Offset\",           \"type\": \"number\"         },         \"yaw\": {           \"title\": \"Yaw\",           \"type\": \"number\"         },         \"scale\": {           \"title\": \"Scale\",           \"type\": \"number\"         },         \"encoding\": {           \"title\": \"Encoding\",           \"type\": \"string\"         },         \"data\": {           \"title\": \"Data\",           \"type\": \"string\"         }       },       \"required\": [         \"name\",         \"x_offset\",         \"y_offset\",         \"yaw\",         \"scale\",         \"encoding\",         \"data\"       ],       \"title\": \"AffineImage\",       \"type\": \"object\"     },     \"Door\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"v1_x\": {           \"title\": \"V1 X\",           \"type\": \"number\"         },         \"v1_y\": {           \"title\": \"V1 Y\",           \"type\": \"number\"         },         \"v2_x\": {           \"title\": \"V2 X\",           \"type\": \"number\"         },         \"v2_y\": {           \"title\": \"V2 Y\",           \"type\": \"number\"         },         \"door_type\": {           \"maximum\": 255,           \"minimum\": 0,           \"title\": \"Door Type\",           \"type\": \"integer\"         },         \"motion_range\": {           \"title\": \"Motion Range\",           \"type\": \"number\"         },         \"motion_direction\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Motion Direction\",           \"type\": \"integer\"         }       },       \"required\": [         \"name\",         \"v1_x\",         \"v1_y\",         \"v2_x\",         \"v2_y\",         \"door_type\",         \"motion_range\",         \"motion_direction\"       ],       \"title\": \"Door\",       \"type\": \"object\"     },     \"Graph\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"vertices\": {           \"items\": {             \"$ref\": \"#/$defs/GraphNode\"           },           \"title\": \"Vertices\",           \"type\": \"array\"         },         \"edges\": {           \"items\": {             \"$ref\": \"#/$defs/GraphEdge\"           },           \"title\": \"Edges\",           \"type\": \"array\"         },         \"params\": {           \"items\": {             \"$ref\": \"#/$defs/Param\"           },           \"title\": \"Params\",           \"type\": \"array\"         }       },       \"required\": [         \"name\",         \"vertices\",         \"edges\",         \"params\"       ],       \"title\": \"Graph\",       \"type\": \"object\"     },     \"GraphEdge\": {       \"properties\": {         \"v1_idx\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"V1 Idx\",           \"type\": \"integer\"         },         \"v2_idx\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"V2 Idx\",           \"type\": \"integer\"         },         \"params\": {           \"items\": {             \"$ref\": \"#/$defs/Param\"           },           \"title\": \"Params\",           \"type\": \"array\"         },         \"edge_type\": {           \"maximum\": 255,           \"minimum\": 0,           \"title\": \"Edge Type\",           \"type\": \"integer\"         }       },       \"required\": [         \"v1_idx\",         \"v2_idx\",         \"params\",         \"edge_type\"       ],       \"title\": \"GraphEdge\",       \"type\": \"object\"     },     \"GraphNode\": {       \"properties\": {         \"x\": {           \"title\": \"X\",           \"type\": \"number\"         },         \"y\": {           \"title\": \"Y\",           \"type\": \"number\"         },         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"params\": {           \"items\": {             \"$ref\": \"#/$defs/Param\"           },           \"title\": \"Params\",           \"type\": \"array\"         }       },       \"required\": [         \"x\",         \"y\",         \"name\",         \"params\"       ],       \"title\": \"GraphNode\",       \"type\": \"object\"     },     \"Level\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"elevation\": {           \"title\": \"Elevation\",           \"type\": \"number\"         },         \"images\": {           \"items\": {             \"$ref\": \"#/$defs/AffineImage\"           },           \"title\": \"Images\",           \"type\": \"array\"         },         \"places\": {           \"items\": {             \"$ref\": \"#/$defs/Place\"           },           \"title\": \"Places\",           \"type\": \"array\"         },         \"doors\": {           \"items\": {             \"$ref\": \"#/$defs/Door\"           },           \"title\": \"Doors\",           \"type\": \"array\"         },         \"nav_graphs\": {           \"items\": {             \"$ref\": \"#/$defs/Graph\"           },           \"title\": \"Nav Graphs\",           \"type\": \"array\"         },         \"wall_graph\": {           \"$ref\": \"#/$defs/Graph\"         }       },       \"required\": [         \"name\",         \"elevation\",         \"images\",         \"places\",         \"doors\",         \"nav_graphs\",         \"wall_graph\"       ],       \"title\": \"Level\",       \"type\": \"object\"     },     \"Lift\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"levels\": {           \"items\": {             \"type\": \"string\"           },           \"title\": \"Levels\",           \"type\": \"array\"         },         \"doors\": {           \"items\": {             \"$ref\": \"#/$defs/Door\"           },           \"title\": \"Doors\",           \"type\": \"array\"         },         \"wall_graph\": {           \"$ref\": \"#/$defs/Graph\"         },         \"ref_x\": {           \"title\": \"Ref X\",           \"type\": \"number\"         },         \"ref_y\": {           \"title\": \"Ref Y\",           \"type\": \"number\"         },         \"ref_yaw\": {           \"title\": \"Ref Yaw\",           \"type\": \"number\"         },         \"width\": {           \"title\": \"Width\",           \"type\": \"number\"         },         \"depth\": {           \"title\": \"Depth\",           \"type\": \"number\"         }       },       \"required\": [         \"name\",         \"levels\",         \"doors\",         \"wall_graph\",         \"ref_x\",         \"ref_y\",         \"ref_yaw\",         \"width\",         \"depth\"       ],       \"title\": \"Lift\",       \"type\": \"object\"     },     \"Param\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"type\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Type\",           \"type\": \"integer\"         },         \"value_int\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Value Int\",           \"type\": \"integer\"         },         \"value_float\": {           \"title\": \"Value Float\",           \"type\": \"number\"         },         \"value_string\": {           \"title\": \"Value String\",           \"type\": \"string\"         },         \"value_bool\": {           \"title\": \"Value Bool\",           \"type\": \"boolean\"         }       },       \"required\": [         \"name\",         \"type\",         \"value_int\",         \"value_float\",         \"value_string\",         \"value_bool\"       ],       \"title\": \"Param\",       \"type\": \"object\"     },     \"Place\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"x\": {           \"title\": \"X\",           \"type\": \"number\"         },         \"y\": {           \"title\": \"Y\",           \"type\": \"number\"         },         \"yaw\": {           \"title\": \"Yaw\",           \"type\": \"number\"         },         \"position_tolerance\": {           \"title\": \"Position Tolerance\",           \"type\": \"number\"         },         \"yaw_tolerance\": {           \"title\": \"Yaw Tolerance\",           \"type\": \"number\"         }       },       \"required\": [         \"name\",         \"x\",         \"y\",         \"yaw\",         \"position_tolerance\",         \"yaw_tolerance\"       ],       \"title\": \"Place\",       \"type\": \"object\"     }   },   \"properties\": {     \"name\": {       \"title\": \"Name\",       \"type\": \"string\"     },     \"levels\": {       \"items\": {         \"$ref\": \"#/$defs/Level\"       },       \"title\": \"Levels\",       \"type\": \"array\"     },     \"lifts\": {       \"items\": {         \"$ref\": \"#/$defs/Lift\"       },       \"title\": \"Lifts\",       \"type\": \"array\"     }   },   \"required\": [     \"name\",     \"levels\",     \"lifts\"   ],   \"title\": \"BuildingMap\",   \"type\": \"object\" } ```   ### /doors/{door_name}/state   ``` {   \"$defs\": {     \"DoorMode\": {       \"properties\": {         \"value\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Value\",           \"type\": \"integer\"         }       },       \"required\": [         \"value\"       ],       \"title\": \"DoorMode\",       \"type\": \"object\"     },     \"Time\": {       \"properties\": {         \"sec\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Sec\",           \"type\": \"integer\"         },         \"nanosec\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Nanosec\",           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ],       \"title\": \"Time\",       \"type\": \"object\"     }   },   \"properties\": {     \"door_time\": {       \"$ref\": \"#/$defs/Time\"     },     \"door_name\": {       \"title\": \"Door Name\",       \"type\": \"string\"     },     \"current_mode\": {       \"$ref\": \"#/$defs/DoorMode\"     }   },   \"required\": [     \"door_time\",     \"door_name\",     \"current_mode\"   ],   \"title\": \"DoorState\",   \"type\": \"object\" } ```   ### /doors/{door_name}/health   ``` {   \"$defs\": {     \"HealthStatus\": {       \"enum\": [         \"Healthy\",         \"Unhealthy\",         \"Dead\"       ],       \"title\": \"HealthStatus\",       \"type\": \"string\"     }   },   \"properties\": {     \"id_\": {       \"title\": \"Id \",       \"type\": \"string\"     },     \"health_status\": {       \"$ref\": \"#/$defs/HealthStatus\"     },     \"health_message\": {       \"anyOf\": [         {           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"title\": \"Health Message\"     }   },   \"required\": [     \"id_\",     \"health_status\",     \"health_message\"   ],   \"title\": \"DoorHealth\",   \"type\": \"object\" } ```   ### /lifts/{lift_name}/state   ``` {   \"$defs\": {     \"Time\": {       \"properties\": {         \"sec\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Sec\",           \"type\": \"integer\"         },         \"nanosec\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Nanosec\",           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ],       \"title\": \"Time\",       \"type\": \"object\"     }   },   \"properties\": {     \"lift_time\": {       \"$ref\": \"#/$defs/Time\"     },     \"lift_name\": {       \"title\": \"Lift Name\",       \"type\": \"string\"     },     \"available_floors\": {       \"items\": {         \"type\": \"string\"       },       \"title\": \"Available Floors\",       \"type\": \"array\"     },     \"current_floor\": {       \"title\": \"Current Floor\",       \"type\": \"string\"     },     \"destination_floor\": {       \"title\": \"Destination Floor\",       \"type\": \"string\"     },     \"door_state\": {       \"maximum\": 255,       \"minimum\": 0,       \"title\": \"Door State\",       \"type\": \"integer\"     },     \"motion_state\": {       \"maximum\": 255,       \"minimum\": 0,       \"title\": \"Motion State\",       \"type\": \"integer\"     },     \"available_modes\": {       \"items\": {         \"type\": \"integer\"       },       \"title\": \"Available Modes\",       \"type\": \"array\"     },     \"current_mode\": {       \"maximum\": 255,       \"minimum\": 0,       \"title\": \"Current Mode\",       \"type\": \"integer\"     },     \"session_id\": {       \"title\": \"Session Id\",       \"type\": \"string\"     }   },   \"required\": [     \"lift_time\",     \"lift_name\",     \"available_floors\",     \"current_floor\",     \"destination_floor\",     \"door_state\",     \"motion_state\",     \"available_modes\",     \"current_mode\",     \"session_id\"   ],   \"title\": \"LiftState\",   \"type\": \"object\" } ```   ### /lifts/{lift_name}/health   ``` {   \"$defs\": {     \"HealthStatus\": {       \"enum\": [         \"Healthy\",         \"Unhealthy\",         \"Dead\"       ],       \"title\": \"HealthStatus\",       \"type\": \"string\"     }   },   \"properties\": {     \"id_\": {       \"title\": \"Id \",       \"type\": \"string\"     },     \"health_status\": {       \"$ref\": \"#/$defs/HealthStatus\"     },     \"health_message\": {       \"anyOf\": [         {           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"title\": \"Health Message\"     }   },   \"required\": [     \"id_\",     \"health_status\",     \"health_message\"   ],   \"title\": \"LiftHealth\",   \"type\": \"object\" } ```   ### /tasks/{task_id}/state   ``` {   \"$defs\": {     \"AssignedTo\": {       \"properties\": {         \"group\": {           \"title\": \"Group\",           \"type\": \"string\"         },         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         }       },       \"required\": [         \"group\",         \"name\"       ],       \"title\": \"AssignedTo\",       \"type\": \"object\"     },     \"Assignment\": {       \"properties\": {         \"fleet_name\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Fleet Name\"         },         \"expected_robot_name\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Expected Robot Name\"         }       },       \"title\": \"Assignment\",       \"type\": \"object\"     },     \"Booking\": {       \"properties\": {         \"id\": {           \"description\": \"The unique identifier for this task\",           \"title\": \"Id\",           \"type\": \"string\"         },         \"unix_millis_earliest_start_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Unix Millis Earliest Start Time\"         },         \"unix_millis_request_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Unix Millis Request Time\"         },         \"priority\": {           \"anyOf\": [             {               \"type\": \"object\"             },             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Priority information about this task\",           \"title\": \"Priority\"         },         \"labels\": {           \"anyOf\": [             {               \"items\": {                 \"type\": \"string\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Information about how and why this task was booked\",           \"title\": \"Labels\"         },         \"requester\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"(Optional) An identifier for the entity that requested this task\",           \"title\": \"Requester\"         }       },       \"required\": [         \"id\"       ],       \"title\": \"Booking\",       \"type\": \"object\"     },     \"Cancellation\": {       \"properties\": {         \"unix_millis_request_time\": {           \"description\": \"The time that the cancellation request arrived\",           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"labels\": {           \"description\": \"Labels to describe the cancel request\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ],       \"title\": \"Cancellation\",       \"type\": \"object\"     },     \"Category\": {       \"title\": \"Category\",       \"type\": \"string\"     },     \"Detail\": {       \"anyOf\": [         {           \"type\": \"object\"         },         {           \"items\": {},           \"type\": \"array\"         },         {           \"type\": \"string\"         }       ],       \"title\": \"Detail\"     },     \"Dispatch\": {       \"properties\": {         \"status\": {           \"$ref\": \"#/$defs/Status2\"         },         \"assignment\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Assignment\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"errors\": {           \"anyOf\": [             {               \"items\": {                 \"$ref\": \"#/$defs/Error\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Errors\"         }       },       \"required\": [         \"status\"       ],       \"title\": \"Dispatch\",       \"type\": \"object\"     },     \"Error\": {       \"properties\": {         \"code\": {           \"anyOf\": [             {               \"minimum\": 0,               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A standard code for the kind of error that has occurred\",           \"title\": \"Code\"         },         \"category\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"The category of the error\",           \"title\": \"Category\"         },         \"detail\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Details about the error\",           \"title\": \"Detail\"         }       },       \"title\": \"Error\",       \"type\": \"object\"     },     \"EstimateMillis\": {       \"minimum\": 0,       \"title\": \"EstimateMillis\",       \"type\": \"integer\"     },     \"EventState\": {       \"properties\": {         \"id\": {           \"$ref\": \"#/$defs/Id\"         },         \"status\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Status\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"name\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"The brief name of the event\",           \"title\": \"Name\"         },         \"detail\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Detail\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Detailed information about the event\"         },         \"deps\": {           \"anyOf\": [             {               \"items\": {                 \"minimum\": 0,                 \"type\": \"integer\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"This event may depend on other events. This array contains the IDs of those other event dependencies.\",           \"title\": \"Deps\"         }       },       \"required\": [         \"id\"       ],       \"title\": \"EventState\",       \"type\": \"object\"     },     \"Id\": {       \"minimum\": 0,       \"title\": \"Id\",       \"type\": \"integer\"     },     \"Interruption\": {       \"properties\": {         \"unix_millis_request_time\": {           \"description\": \"The time that the interruption request arrived\",           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"labels\": {           \"description\": \"Labels to describe the purpose of the interruption\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         },         \"resumed_by\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/ResumedBy\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Information about the resume request that ended this interruption. This field will be missing if the interruption is still active.\"         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ],       \"title\": \"Interruption\",       \"type\": \"object\"     },     \"Killed\": {       \"properties\": {         \"unix_millis_request_time\": {           \"description\": \"The time that the cancellation request arrived\",           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"labels\": {           \"description\": \"Labels to describe the kill request\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ],       \"title\": \"Killed\",       \"type\": \"object\"     },     \"Phase\": {       \"properties\": {         \"id\": {           \"$ref\": \"#/$defs/Id\"         },         \"category\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Category\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"detail\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Detail\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"unix_millis_start_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Unix Millis Start Time\"         },         \"unix_millis_finish_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Unix Millis Finish Time\"         },         \"original_estimate_millis\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/EstimateMillis\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"estimate_millis\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/EstimateMillis\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"final_event_id\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Id\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"events\": {           \"anyOf\": [             {               \"additionalProperties\": {                 \"$ref\": \"#/$defs/EventState\"               },               \"type\": \"object\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A dictionary of events for this phase. The keys (property names) are the event IDs, which are integers.\",           \"title\": \"Events\"         },         \"skip_requests\": {           \"anyOf\": [             {               \"additionalProperties\": {                 \"$ref\": \"#/$defs/SkipPhaseRequest\"               },               \"type\": \"object\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Information about any skip requests that have been received\",           \"title\": \"Skip Requests\"         }       },       \"required\": [         \"id\"       ],       \"title\": \"Phase\",       \"type\": \"object\"     },     \"ResumedBy\": {       \"properties\": {         \"unix_millis_request_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"The time that the resume request arrived\",           \"title\": \"Unix Millis Request Time\"         },         \"labels\": {           \"description\": \"Labels to describe the resume request\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         }       },       \"required\": [         \"labels\"       ],       \"title\": \"ResumedBy\",       \"type\": \"object\"     },     \"SkipPhaseRequest\": {       \"properties\": {         \"unix_millis_request_time\": {           \"description\": \"The time that the skip request arrived\",           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"labels\": {           \"description\": \"Labels to describe the purpose of the skip request\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         },         \"undo\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Undo\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Information about an undo skip request that applied to this request\"         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ],       \"title\": \"SkipPhaseRequest\",       \"type\": \"object\"     },     \"Status\": {       \"enum\": [         \"uninitialized\",         \"blocked\",         \"error\",         \"failed\",         \"queued\",         \"standby\",         \"underway\",         \"delayed\",         \"skipped\",         \"canceled\",         \"killed\",         \"completed\"       ],       \"title\": \"Status\",       \"type\": \"string\"     },     \"Status2\": {       \"enum\": [         \"queued\",         \"selected\",         \"dispatched\",         \"failed_to_assign\",         \"canceled_in_flight\"       ],       \"title\": \"Status2\",       \"type\": \"string\"     },     \"Undo\": {       \"properties\": {         \"unix_millis_request_time\": {           \"description\": \"The time that the undo skip request arrived\",           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"labels\": {           \"description\": \"Labels to describe the undo skip request\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ],       \"title\": \"Undo\",       \"type\": \"object\"     }   },   \"properties\": {     \"booking\": {       \"$ref\": \"#/$defs/Booking\"     },     \"category\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Category\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"detail\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Detail\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"unix_millis_start_time\": {       \"anyOf\": [         {           \"type\": \"integer\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"title\": \"Unix Millis Start Time\"     },     \"unix_millis_finish_time\": {       \"anyOf\": [         {           \"type\": \"integer\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"title\": \"Unix Millis Finish Time\"     },     \"original_estimate_millis\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/EstimateMillis\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"estimate_millis\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/EstimateMillis\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"assigned_to\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/AssignedTo\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"Which agent (robot) is the task assigned to\"     },     \"status\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Status\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"dispatch\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Dispatch\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"phases\": {       \"anyOf\": [         {           \"additionalProperties\": {             \"$ref\": \"#/$defs/Phase\"           },           \"type\": \"object\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"A dictionary of the states of the phases of the task. The keys (property names) are phase IDs, which are integers.\",       \"title\": \"Phases\"     },     \"completed\": {       \"anyOf\": [         {           \"items\": {             \"$ref\": \"#/$defs/Id\"           },           \"type\": \"array\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"An array of the IDs of completed phases of this task\",       \"title\": \"Completed\"     },     \"active\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Id\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"The ID of the active phase for this task\"     },     \"pending\": {       \"anyOf\": [         {           \"items\": {             \"$ref\": \"#/$defs/Id\"           },           \"type\": \"array\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"An array of the pending phases of this task\",       \"title\": \"Pending\"     },     \"interruptions\": {       \"anyOf\": [         {           \"additionalProperties\": {             \"$ref\": \"#/$defs/Interruption\"           },           \"type\": \"object\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"A dictionary of interruptions that have been applied to this task. The keys (property names) are the unique token of the interruption request.\",       \"title\": \"Interruptions\"     },     \"cancellation\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Cancellation\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"If the task was cancelled, this will describe information about the request.\"     },     \"killed\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Killed\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"If the task was killed, this will describe information about the request.\"     }   },   \"required\": [     \"booking\"   ],   \"title\": \"TaskState\",   \"type\": \"object\" } ```   ### /tasks/{task_id}/log   ``` {   \"$defs\": {     \"LogEntry\": {       \"properties\": {         \"seq\": {           \"description\": \"Sequence number for this entry. Each entry has a unique sequence number which monotonically increase, until integer overflow causes a wrap around.\",           \"exclusiveMaximum\": 4294967296,           \"minimum\": 0,           \"title\": \"Seq\",           \"type\": \"integer\"         },         \"tier\": {           \"allOf\": [             {               \"$ref\": \"#/$defs/Tier\"             }           ],           \"description\": \"The importance level of the log entry\"         },         \"unix_millis_time\": {           \"title\": \"Unix Millis Time\",           \"type\": \"integer\"         },         \"text\": {           \"description\": \"The text of the log entry\",           \"title\": \"Text\",           \"type\": \"string\"         }       },       \"required\": [         \"seq\",         \"tier\",         \"unix_millis_time\",         \"text\"       ],       \"title\": \"LogEntry\",       \"type\": \"object\"     },     \"Phases\": {       \"additionalProperties\": false,       \"properties\": {         \"log\": {           \"anyOf\": [             {               \"items\": {                 \"$ref\": \"#/$defs/LogEntry\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Log entries related to the overall phase\",           \"title\": \"Log\"         },         \"events\": {           \"anyOf\": [             {               \"additionalProperties\": {                 \"items\": {                   \"$ref\": \"#/$defs/LogEntry\"                 },                 \"type\": \"array\"               },               \"type\": \"object\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A dictionary whose keys (property names) are the indices of an event in the phase\",           \"title\": \"Events\"         }       },       \"title\": \"Phases\",       \"type\": \"object\"     },     \"Tier\": {       \"enum\": [         \"uninitialized\",         \"info\",         \"warning\",         \"error\"       ],       \"title\": \"Tier\",       \"type\": \"string\"     }   },   \"additionalProperties\": false,   \"properties\": {     \"task_id\": {       \"title\": \"Task Id\",       \"type\": \"string\"     },     \"log\": {       \"anyOf\": [         {           \"items\": {             \"$ref\": \"#/$defs/LogEntry\"           },           \"type\": \"array\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"Log entries related to the overall task\",       \"title\": \"Log\"     },     \"phases\": {       \"anyOf\": [         {           \"additionalProperties\": {             \"$ref\": \"#/$defs/Phases\"           },           \"type\": \"object\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"A dictionary whose keys (property names) are the indices of a phase\",       \"title\": \"Phases\"     }   },   \"required\": [     \"task_id\"   ],   \"title\": \"TaskEventLog\",   \"type\": \"object\" } ```   ### /dispensers/{guid}/state   ``` {   \"$defs\": {     \"Time\": {       \"properties\": {         \"sec\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Sec\",           \"type\": \"integer\"         },         \"nanosec\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Nanosec\",           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ],       \"title\": \"Time\",       \"type\": \"object\"     }   },   \"properties\": {     \"time\": {       \"$ref\": \"#/$defs/Time\"     },     \"guid\": {       \"title\": \"Guid\",       \"type\": \"string\"     },     \"mode\": {       \"maximum\": 2147483647,       \"minimum\": -2147483648,       \"title\": \"Mode\",       \"type\": \"integer\"     },     \"request_guid_queue\": {       \"items\": {         \"type\": \"string\"       },       \"title\": \"Request Guid Queue\",       \"type\": \"array\"     },     \"seconds_remaining\": {       \"title\": \"Seconds Remaining\",       \"type\": \"number\"     }   },   \"required\": [     \"time\",     \"guid\",     \"mode\",     \"request_guid_queue\",     \"seconds_remaining\"   ],   \"title\": \"DispenserState\",   \"type\": \"object\" } ```   ### /dispensers/{guid}/health   ``` {   \"$defs\": {     \"HealthStatus\": {       \"enum\": [         \"Healthy\",         \"Unhealthy\",         \"Dead\"       ],       \"title\": \"HealthStatus\",       \"type\": \"string\"     }   },   \"properties\": {     \"id_\": {       \"title\": \"Id \",       \"type\": \"string\"     },     \"health_status\": {       \"$ref\": \"#/$defs/HealthStatus\"     },     \"health_message\": {       \"anyOf\": [         {           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"title\": \"Health Message\"     }   },   \"required\": [     \"id_\",     \"health_status\",     \"health_message\"   ],   \"title\": \"DispenserHealth\",   \"type\": \"object\" } ```   ### /ingestors/{guid}/state   ``` {   \"$defs\": {     \"Time\": {       \"properties\": {         \"sec\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Sec\",           \"type\": \"integer\"         },         \"nanosec\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Nanosec\",           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ],       \"title\": \"Time\",       \"type\": \"object\"     }   },   \"properties\": {     \"time\": {       \"$ref\": \"#/$defs/Time\"     },     \"guid\": {       \"title\": \"Guid\",       \"type\": \"string\"     },     \"mode\": {       \"maximum\": 2147483647,       \"minimum\": -2147483648,       \"title\": \"Mode\",       \"type\": \"integer\"     },     \"request_guid_queue\": {       \"items\": {         \"type\": \"string\"       },       \"title\": \"Request Guid Queue\",       \"type\": \"array\"     },     \"seconds_remaining\": {       \"title\": \"Seconds Remaining\",       \"type\": \"number\"     }   },   \"required\": [     \"time\",     \"guid\",     \"mode\",     \"request_guid_queue\",     \"seconds_remaining\"   ],   \"title\": \"IngestorState\",   \"type\": \"object\" } ```   ### /ingestors/{guid}/health   ``` {   \"$defs\": {     \"HealthStatus\": {       \"enum\": [         \"Healthy\",         \"Unhealthy\",         \"Dead\"       ],       \"title\": \"HealthStatus\",       \"type\": \"string\"     }   },   \"properties\": {     \"id_\": {       \"title\": \"Id \",       \"type\": \"string\"     },     \"health_status\": {       \"$ref\": \"#/$defs/HealthStatus\"     },     \"health_message\": {       \"anyOf\": [         {           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"title\": \"Health Message\"     }   },   \"required\": [     \"id_\",     \"health_status\",     \"health_message\"   ],   \"title\": \"IngestorHealth\",   \"type\": \"object\" } ```   ### /fleets/{name}/state   ``` {   \"$defs\": {     \"Issue\": {       \"properties\": {         \"category\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Category of the robot\'s issue\",           \"title\": \"Category\"         },         \"detail\": {           \"anyOf\": [             {               \"type\": \"object\"             },             {               \"items\": {},               \"type\": \"array\"             },             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Detailed information about the issue\",           \"title\": \"Detail\"         }       },       \"title\": \"Issue\",       \"type\": \"object\"     },     \"Location2D\": {       \"properties\": {         \"map\": {           \"title\": \"Map\",           \"type\": \"string\"         },         \"x\": {           \"title\": \"X\",           \"type\": \"number\"         },         \"y\": {           \"title\": \"Y\",           \"type\": \"number\"         },         \"yaw\": {           \"title\": \"Yaw\",           \"type\": \"number\"         }       },       \"required\": [         \"map\",         \"x\",         \"y\",         \"yaw\"       ],       \"title\": \"Location2D\",       \"type\": \"object\"     },     \"RobotState\": {       \"properties\": {         \"name\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Name\"         },         \"status\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Status\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A simple token representing the status of the robot\"         },         \"task_id\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"The ID of the task this robot is currently working on. Empty string if the robot is not working on a task.\",           \"title\": \"Task Id\"         },         \"unix_millis_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Unix Millis Time\"         },         \"location\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Location2D\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"battery\": {           \"anyOf\": [             {               \"maximum\": 1.0,               \"minimum\": 0.0,               \"type\": \"number\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"State of charge of the battery. Values range from 0.0 (depleted) to 1.0 (fully charged)\",           \"title\": \"Battery\"         },         \"issues\": {           \"anyOf\": [             {               \"items\": {                 \"$ref\": \"#/$defs/Issue\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A list of issues with the robot that operators need to address\",           \"title\": \"Issues\"         }       },       \"title\": \"RobotState\",       \"type\": \"object\"     },     \"Status\": {       \"enum\": [         \"uninitialized\",         \"offline\",         \"shutdown\",         \"idle\",         \"charging\",         \"working\",         \"error\"       ],       \"title\": \"Status\",       \"type\": \"string\"     }   },   \"properties\": {     \"name\": {       \"anyOf\": [         {           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"title\": \"Name\"     },     \"robots\": {       \"anyOf\": [         {           \"additionalProperties\": {             \"$ref\": \"#/$defs/RobotState\"           },           \"type\": \"object\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"A dictionary of the states of the robots that belong to this fleet\",       \"title\": \"Robots\"     }   },   \"title\": \"FleetState\",   \"type\": \"object\" } ```   ### /fleets/{name}/log   ``` {   \"$defs\": {     \"LogEntry\": {       \"properties\": {         \"seq\": {           \"description\": \"Sequence number for this entry. Each entry has a unique sequence number which monotonically increase, until integer overflow causes a wrap around.\",           \"exclusiveMaximum\": 4294967296,           \"minimum\": 0,           \"title\": \"Seq\",           \"type\": \"integer\"         },         \"tier\": {           \"allOf\": [             {               \"$ref\": \"#/$defs/Tier\"             }           ],           \"description\": \"The importance level of the log entry\"         },         \"unix_millis_time\": {           \"title\": \"Unix Millis Time\",           \"type\": \"integer\"         },         \"text\": {           \"description\": \"The text of the log entry\",           \"title\": \"Text\",           \"type\": \"string\"         }       },       \"required\": [         \"seq\",         \"tier\",         \"unix_millis_time\",         \"text\"       ],       \"title\": \"LogEntry\",       \"type\": \"object\"     },     \"Tier\": {       \"enum\": [         \"uninitialized\",         \"info\",         \"warning\",         \"error\"       ],       \"title\": \"Tier\",       \"type\": \"string\"     }   },   \"properties\": {     \"name\": {       \"anyOf\": [         {           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"title\": \"Name\"     },     \"log\": {       \"anyOf\": [         {           \"items\": {             \"$ref\": \"#/$defs/LogEntry\"           },           \"type\": \"array\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"Log for the overall fleet\",       \"title\": \"Log\"     },     \"robots\": {       \"anyOf\": [         {           \"additionalProperties\": {             \"items\": {               \"$ref\": \"#/$defs/LogEntry\"             },             \"type\": \"array\"           },           \"type\": \"object\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"Dictionary of logs for the individual robots. The keys (property names) are the robot names.\",       \"title\": \"Robots\"     }   },   \"title\": \"FleetLog\",   \"type\": \"object\" } ```
     * @summary Socket.io endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lambdaSocketIoGet(options?: any): AxiosPromise<any> {
      return localVarFp.lambdaSocketIoGet(options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   * Get the effective permissions of the current user
   * @summary Get Effective Permissions
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getEffectivePermissionsPermissionsGet(
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .getEffectivePermissionsPermissionsGet(authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get the current rmf time in unix milliseconds
   * @summary Get Time
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getTimeTimeGet(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getTimeTimeGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get the currently logged in user
   * @summary Get User
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getUserUserGet(authorization?: string | null, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getUserUserGet(authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * # NOTE: This endpoint is here for documentation purposes only, this is _not_ a REST endpoint.  ## About This exposes a minimal pubsub system built on top of socket.io. It works similar to a normal socket.io endpoint, except that are 2 special rooms which control subscriptions.  ## Rooms ### subscribe Clients must send a message to this room to start receiving messages on other rooms. The message must be of the form:  ``` {     \"room\": \"<room_name>\" } ```  ### unsubscribe Clients can send a message to this room to stop receiving messages on other rooms. The message must be of the form:  ``` {     \"room\": \"<room_name>\" } ``` ### /alerts   ``` {   \"additionalProperties\": false,   \"description\": \"General alert that can be triggered by events.\",   \"properties\": {     \"id\": {       \"maxLength\": 255,       \"title\": \"Id\",       \"type\": \"string\"     },     \"original_id\": {       \"maxLength\": 255,       \"title\": \"Original Id\",       \"type\": \"string\"     },     \"category\": {       \"description\": \"Default: default<br/>Task: task<br/>Fleet: fleet<br/>Robot: robot\",       \"maxLength\": 7,       \"title\": \"Category\",       \"type\": \"string\"     },     \"unix_millis_created_time\": {       \"maximum\": 9223372036854775807,       \"minimum\": -9223372036854775808,       \"title\": \"Unix Millis Created Time\",       \"type\": \"integer\"     },     \"acknowledged_by\": {       \"anyOf\": [         {           \"maxLength\": 255,           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"nullable\": true,       \"title\": \"Acknowledged By\"     },     \"unix_millis_acknowledged_time\": {       \"anyOf\": [         {           \"maximum\": 9223372036854775807,           \"minimum\": -9223372036854775808,           \"type\": \"integer\"         },         {           \"type\": \"null\"         }       ],       \"nullable\": true,       \"title\": \"Unix Millis Acknowledged Time\"     }   },   \"required\": [     \"id\",     \"original_id\",     \"category\",     \"unix_millis_created_time\",     \"acknowledged_by\",     \"unix_millis_acknowledged_time\"   ],   \"title\": \"Alert\",   \"type\": \"object\" } ```   ### /beacons   ``` {   \"additionalProperties\": false,   \"properties\": {     \"id\": {       \"maxLength\": 255,       \"title\": \"Id\",       \"type\": \"string\"     },     \"online\": {       \"title\": \"Online\",       \"type\": \"boolean\"     },     \"category\": {       \"anyOf\": [         {           \"maxLength\": 255,           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"nullable\": true,       \"title\": \"Category\"     },     \"activated\": {       \"title\": \"Activated\",       \"type\": \"boolean\"     },     \"level\": {       \"anyOf\": [         {           \"maxLength\": 255,           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"nullable\": true,       \"title\": \"Level\"     }   },   \"required\": [     \"id\",     \"online\",     \"category\",     \"activated\",     \"level\"   ],   \"title\": \"BeaconState\",   \"type\": \"object\" } ```   ### /building_map   ``` {   \"$defs\": {     \"AffineImage\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"x_offset\": {           \"title\": \"X Offset\",           \"type\": \"number\"         },         \"y_offset\": {           \"title\": \"Y Offset\",           \"type\": \"number\"         },         \"yaw\": {           \"title\": \"Yaw\",           \"type\": \"number\"         },         \"scale\": {           \"title\": \"Scale\",           \"type\": \"number\"         },         \"encoding\": {           \"title\": \"Encoding\",           \"type\": \"string\"         },         \"data\": {           \"title\": \"Data\",           \"type\": \"string\"         }       },       \"required\": [         \"name\",         \"x_offset\",         \"y_offset\",         \"yaw\",         \"scale\",         \"encoding\",         \"data\"       ],       \"title\": \"AffineImage\",       \"type\": \"object\"     },     \"Door\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"v1_x\": {           \"title\": \"V1 X\",           \"type\": \"number\"         },         \"v1_y\": {           \"title\": \"V1 Y\",           \"type\": \"number\"         },         \"v2_x\": {           \"title\": \"V2 X\",           \"type\": \"number\"         },         \"v2_y\": {           \"title\": \"V2 Y\",           \"type\": \"number\"         },         \"door_type\": {           \"maximum\": 255,           \"minimum\": 0,           \"title\": \"Door Type\",           \"type\": \"integer\"         },         \"motion_range\": {           \"title\": \"Motion Range\",           \"type\": \"number\"         },         \"motion_direction\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Motion Direction\",           \"type\": \"integer\"         }       },       \"required\": [         \"name\",         \"v1_x\",         \"v1_y\",         \"v2_x\",         \"v2_y\",         \"door_type\",         \"motion_range\",         \"motion_direction\"       ],       \"title\": \"Door\",       \"type\": \"object\"     },     \"Graph\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"vertices\": {           \"items\": {             \"$ref\": \"#/$defs/GraphNode\"           },           \"title\": \"Vertices\",           \"type\": \"array\"         },         \"edges\": {           \"items\": {             \"$ref\": \"#/$defs/GraphEdge\"           },           \"title\": \"Edges\",           \"type\": \"array\"         },         \"params\": {           \"items\": {             \"$ref\": \"#/$defs/Param\"           },           \"title\": \"Params\",           \"type\": \"array\"         }       },       \"required\": [         \"name\",         \"vertices\",         \"edges\",         \"params\"       ],       \"title\": \"Graph\",       \"type\": \"object\"     },     \"GraphEdge\": {       \"properties\": {         \"v1_idx\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"V1 Idx\",           \"type\": \"integer\"         },         \"v2_idx\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"V2 Idx\",           \"type\": \"integer\"         },         \"params\": {           \"items\": {             \"$ref\": \"#/$defs/Param\"           },           \"title\": \"Params\",           \"type\": \"array\"         },         \"edge_type\": {           \"maximum\": 255,           \"minimum\": 0,           \"title\": \"Edge Type\",           \"type\": \"integer\"         }       },       \"required\": [         \"v1_idx\",         \"v2_idx\",         \"params\",         \"edge_type\"       ],       \"title\": \"GraphEdge\",       \"type\": \"object\"     },     \"GraphNode\": {       \"properties\": {         \"x\": {           \"title\": \"X\",           \"type\": \"number\"         },         \"y\": {           \"title\": \"Y\",           \"type\": \"number\"         },         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"params\": {           \"items\": {             \"$ref\": \"#/$defs/Param\"           },           \"title\": \"Params\",           \"type\": \"array\"         }       },       \"required\": [         \"x\",         \"y\",         \"name\",         \"params\"       ],       \"title\": \"GraphNode\",       \"type\": \"object\"     },     \"Level\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"elevation\": {           \"title\": \"Elevation\",           \"type\": \"number\"         },         \"images\": {           \"items\": {             \"$ref\": \"#/$defs/AffineImage\"           },           \"title\": \"Images\",           \"type\": \"array\"         },         \"places\": {           \"items\": {             \"$ref\": \"#/$defs/Place\"           },           \"title\": \"Places\",           \"type\": \"array\"         },         \"doors\": {           \"items\": {             \"$ref\": \"#/$defs/Door\"           },           \"title\": \"Doors\",           \"type\": \"array\"         },         \"nav_graphs\": {           \"items\": {             \"$ref\": \"#/$defs/Graph\"           },           \"title\": \"Nav Graphs\",           \"type\": \"array\"         },         \"wall_graph\": {           \"$ref\": \"#/$defs/Graph\"         }       },       \"required\": [         \"name\",         \"elevation\",         \"images\",         \"places\",         \"doors\",         \"nav_graphs\",         \"wall_graph\"       ],       \"title\": \"Level\",       \"type\": \"object\"     },     \"Lift\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"levels\": {           \"items\": {             \"type\": \"string\"           },           \"title\": \"Levels\",           \"type\": \"array\"         },         \"doors\": {           \"items\": {             \"$ref\": \"#/$defs/Door\"           },           \"title\": \"Doors\",           \"type\": \"array\"         },         \"wall_graph\": {           \"$ref\": \"#/$defs/Graph\"         },         \"ref_x\": {           \"title\": \"Ref X\",           \"type\": \"number\"         },         \"ref_y\": {           \"title\": \"Ref Y\",           \"type\": \"number\"         },         \"ref_yaw\": {           \"title\": \"Ref Yaw\",           \"type\": \"number\"         },         \"width\": {           \"title\": \"Width\",           \"type\": \"number\"         },         \"depth\": {           \"title\": \"Depth\",           \"type\": \"number\"         }       },       \"required\": [         \"name\",         \"levels\",         \"doors\",         \"wall_graph\",         \"ref_x\",         \"ref_y\",         \"ref_yaw\",         \"width\",         \"depth\"       ],       \"title\": \"Lift\",       \"type\": \"object\"     },     \"Param\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"type\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Type\",           \"type\": \"integer\"         },         \"value_int\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Value Int\",           \"type\": \"integer\"         },         \"value_float\": {           \"title\": \"Value Float\",           \"type\": \"number\"         },         \"value_string\": {           \"title\": \"Value String\",           \"type\": \"string\"         },         \"value_bool\": {           \"title\": \"Value Bool\",           \"type\": \"boolean\"         }       },       \"required\": [         \"name\",         \"type\",         \"value_int\",         \"value_float\",         \"value_string\",         \"value_bool\"       ],       \"title\": \"Param\",       \"type\": \"object\"     },     \"Place\": {       \"properties\": {         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         },         \"x\": {           \"title\": \"X\",           \"type\": \"number\"         },         \"y\": {           \"title\": \"Y\",           \"type\": \"number\"         },         \"yaw\": {           \"title\": \"Yaw\",           \"type\": \"number\"         },         \"position_tolerance\": {           \"title\": \"Position Tolerance\",           \"type\": \"number\"         },         \"yaw_tolerance\": {           \"title\": \"Yaw Tolerance\",           \"type\": \"number\"         }       },       \"required\": [         \"name\",         \"x\",         \"y\",         \"yaw\",         \"position_tolerance\",         \"yaw_tolerance\"       ],       \"title\": \"Place\",       \"type\": \"object\"     }   },   \"properties\": {     \"name\": {       \"title\": \"Name\",       \"type\": \"string\"     },     \"levels\": {       \"items\": {         \"$ref\": \"#/$defs/Level\"       },       \"title\": \"Levels\",       \"type\": \"array\"     },     \"lifts\": {       \"items\": {         \"$ref\": \"#/$defs/Lift\"       },       \"title\": \"Lifts\",       \"type\": \"array\"     }   },   \"required\": [     \"name\",     \"levels\",     \"lifts\"   ],   \"title\": \"BuildingMap\",   \"type\": \"object\" } ```   ### /doors/{door_name}/state   ``` {   \"$defs\": {     \"DoorMode\": {       \"properties\": {         \"value\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Value\",           \"type\": \"integer\"         }       },       \"required\": [         \"value\"       ],       \"title\": \"DoorMode\",       \"type\": \"object\"     },     \"Time\": {       \"properties\": {         \"sec\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Sec\",           \"type\": \"integer\"         },         \"nanosec\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Nanosec\",           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ],       \"title\": \"Time\",       \"type\": \"object\"     }   },   \"properties\": {     \"door_time\": {       \"$ref\": \"#/$defs/Time\"     },     \"door_name\": {       \"title\": \"Door Name\",       \"type\": \"string\"     },     \"current_mode\": {       \"$ref\": \"#/$defs/DoorMode\"     }   },   \"required\": [     \"door_time\",     \"door_name\",     \"current_mode\"   ],   \"title\": \"DoorState\",   \"type\": \"object\" } ```   ### /doors/{door_name}/health   ``` {   \"$defs\": {     \"HealthStatus\": {       \"enum\": [         \"Healthy\",         \"Unhealthy\",         \"Dead\"       ],       \"title\": \"HealthStatus\",       \"type\": \"string\"     }   },   \"properties\": {     \"id_\": {       \"title\": \"Id \",       \"type\": \"string\"     },     \"health_status\": {       \"$ref\": \"#/$defs/HealthStatus\"     },     \"health_message\": {       \"anyOf\": [         {           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"title\": \"Health Message\"     }   },   \"required\": [     \"id_\",     \"health_status\",     \"health_message\"   ],   \"title\": \"DoorHealth\",   \"type\": \"object\" } ```   ### /lifts/{lift_name}/state   ``` {   \"$defs\": {     \"Time\": {       \"properties\": {         \"sec\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Sec\",           \"type\": \"integer\"         },         \"nanosec\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Nanosec\",           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ],       \"title\": \"Time\",       \"type\": \"object\"     }   },   \"properties\": {     \"lift_time\": {       \"$ref\": \"#/$defs/Time\"     },     \"lift_name\": {       \"title\": \"Lift Name\",       \"type\": \"string\"     },     \"available_floors\": {       \"items\": {         \"type\": \"string\"       },       \"title\": \"Available Floors\",       \"type\": \"array\"     },     \"current_floor\": {       \"title\": \"Current Floor\",       \"type\": \"string\"     },     \"destination_floor\": {       \"title\": \"Destination Floor\",       \"type\": \"string\"     },     \"door_state\": {       \"maximum\": 255,       \"minimum\": 0,       \"title\": \"Door State\",       \"type\": \"integer\"     },     \"motion_state\": {       \"maximum\": 255,       \"minimum\": 0,       \"title\": \"Motion State\",       \"type\": \"integer\"     },     \"available_modes\": {       \"items\": {         \"type\": \"integer\"       },       \"title\": \"Available Modes\",       \"type\": \"array\"     },     \"current_mode\": {       \"maximum\": 255,       \"minimum\": 0,       \"title\": \"Current Mode\",       \"type\": \"integer\"     },     \"session_id\": {       \"title\": \"Session Id\",       \"type\": \"string\"     }   },   \"required\": [     \"lift_time\",     \"lift_name\",     \"available_floors\",     \"current_floor\",     \"destination_floor\",     \"door_state\",     \"motion_state\",     \"available_modes\",     \"current_mode\",     \"session_id\"   ],   \"title\": \"LiftState\",   \"type\": \"object\" } ```   ### /lifts/{lift_name}/health   ``` {   \"$defs\": {     \"HealthStatus\": {       \"enum\": [         \"Healthy\",         \"Unhealthy\",         \"Dead\"       ],       \"title\": \"HealthStatus\",       \"type\": \"string\"     }   },   \"properties\": {     \"id_\": {       \"title\": \"Id \",       \"type\": \"string\"     },     \"health_status\": {       \"$ref\": \"#/$defs/HealthStatus\"     },     \"health_message\": {       \"anyOf\": [         {           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"title\": \"Health Message\"     }   },   \"required\": [     \"id_\",     \"health_status\",     \"health_message\"   ],   \"title\": \"LiftHealth\",   \"type\": \"object\" } ```   ### /tasks/{task_id}/state   ``` {   \"$defs\": {     \"AssignedTo\": {       \"properties\": {         \"group\": {           \"title\": \"Group\",           \"type\": \"string\"         },         \"name\": {           \"title\": \"Name\",           \"type\": \"string\"         }       },       \"required\": [         \"group\",         \"name\"       ],       \"title\": \"AssignedTo\",       \"type\": \"object\"     },     \"Assignment\": {       \"properties\": {         \"fleet_name\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Fleet Name\"         },         \"expected_robot_name\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Expected Robot Name\"         }       },       \"title\": \"Assignment\",       \"type\": \"object\"     },     \"Booking\": {       \"properties\": {         \"id\": {           \"description\": \"The unique identifier for this task\",           \"title\": \"Id\",           \"type\": \"string\"         },         \"unix_millis_earliest_start_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Unix Millis Earliest Start Time\"         },         \"unix_millis_request_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Unix Millis Request Time\"         },         \"priority\": {           \"anyOf\": [             {               \"type\": \"object\"             },             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Priority information about this task\",           \"title\": \"Priority\"         },         \"labels\": {           \"anyOf\": [             {               \"items\": {                 \"type\": \"string\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Information about how and why this task was booked\",           \"title\": \"Labels\"         },         \"requester\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"(Optional) An identifier for the entity that requested this task\",           \"title\": \"Requester\"         }       },       \"required\": [         \"id\"       ],       \"title\": \"Booking\",       \"type\": \"object\"     },     \"Cancellation\": {       \"properties\": {         \"unix_millis_request_time\": {           \"description\": \"The time that the cancellation request arrived\",           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"labels\": {           \"description\": \"Labels to describe the cancel request\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ],       \"title\": \"Cancellation\",       \"type\": \"object\"     },     \"Category\": {       \"title\": \"Category\",       \"type\": \"string\"     },     \"Detail\": {       \"anyOf\": [         {           \"type\": \"object\"         },         {           \"items\": {},           \"type\": \"array\"         },         {           \"type\": \"string\"         }       ],       \"title\": \"Detail\"     },     \"Dispatch\": {       \"properties\": {         \"status\": {           \"$ref\": \"#/$defs/Status2\"         },         \"assignment\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Assignment\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"errors\": {           \"anyOf\": [             {               \"items\": {                 \"$ref\": \"#/$defs/Error\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Errors\"         }       },       \"required\": [         \"status\"       ],       \"title\": \"Dispatch\",       \"type\": \"object\"     },     \"Error\": {       \"properties\": {         \"code\": {           \"anyOf\": [             {               \"minimum\": 0,               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A standard code for the kind of error that has occurred\",           \"title\": \"Code\"         },         \"category\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"The category of the error\",           \"title\": \"Category\"         },         \"detail\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Details about the error\",           \"title\": \"Detail\"         }       },       \"title\": \"Error\",       \"type\": \"object\"     },     \"EstimateMillis\": {       \"minimum\": 0,       \"title\": \"EstimateMillis\",       \"type\": \"integer\"     },     \"EventState\": {       \"properties\": {         \"id\": {           \"$ref\": \"#/$defs/Id\"         },         \"status\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Status\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"name\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"The brief name of the event\",           \"title\": \"Name\"         },         \"detail\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Detail\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Detailed information about the event\"         },         \"deps\": {           \"anyOf\": [             {               \"items\": {                 \"minimum\": 0,                 \"type\": \"integer\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"This event may depend on other events. This array contains the IDs of those other event dependencies.\",           \"title\": \"Deps\"         }       },       \"required\": [         \"id\"       ],       \"title\": \"EventState\",       \"type\": \"object\"     },     \"Id\": {       \"minimum\": 0,       \"title\": \"Id\",       \"type\": \"integer\"     },     \"Interruption\": {       \"properties\": {         \"unix_millis_request_time\": {           \"description\": \"The time that the interruption request arrived\",           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"labels\": {           \"description\": \"Labels to describe the purpose of the interruption\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         },         \"resumed_by\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/ResumedBy\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Information about the resume request that ended this interruption. This field will be missing if the interruption is still active.\"         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ],       \"title\": \"Interruption\",       \"type\": \"object\"     },     \"Killed\": {       \"properties\": {         \"unix_millis_request_time\": {           \"description\": \"The time that the cancellation request arrived\",           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"labels\": {           \"description\": \"Labels to describe the kill request\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ],       \"title\": \"Killed\",       \"type\": \"object\"     },     \"Phase\": {       \"properties\": {         \"id\": {           \"$ref\": \"#/$defs/Id\"         },         \"category\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Category\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"detail\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Detail\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"unix_millis_start_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Unix Millis Start Time\"         },         \"unix_millis_finish_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Unix Millis Finish Time\"         },         \"original_estimate_millis\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/EstimateMillis\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"estimate_millis\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/EstimateMillis\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"final_event_id\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Id\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"events\": {           \"anyOf\": [             {               \"additionalProperties\": {                 \"$ref\": \"#/$defs/EventState\"               },               \"type\": \"object\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A dictionary of events for this phase. The keys (property names) are the event IDs, which are integers.\",           \"title\": \"Events\"         },         \"skip_requests\": {           \"anyOf\": [             {               \"additionalProperties\": {                 \"$ref\": \"#/$defs/SkipPhaseRequest\"               },               \"type\": \"object\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Information about any skip requests that have been received\",           \"title\": \"Skip Requests\"         }       },       \"required\": [         \"id\"       ],       \"title\": \"Phase\",       \"type\": \"object\"     },     \"ResumedBy\": {       \"properties\": {         \"unix_millis_request_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"The time that the resume request arrived\",           \"title\": \"Unix Millis Request Time\"         },         \"labels\": {           \"description\": \"Labels to describe the resume request\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         }       },       \"required\": [         \"labels\"       ],       \"title\": \"ResumedBy\",       \"type\": \"object\"     },     \"SkipPhaseRequest\": {       \"properties\": {         \"unix_millis_request_time\": {           \"description\": \"The time that the skip request arrived\",           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"labels\": {           \"description\": \"Labels to describe the purpose of the skip request\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         },         \"undo\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Undo\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Information about an undo skip request that applied to this request\"         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ],       \"title\": \"SkipPhaseRequest\",       \"type\": \"object\"     },     \"Status\": {       \"enum\": [         \"uninitialized\",         \"blocked\",         \"error\",         \"failed\",         \"queued\",         \"standby\",         \"underway\",         \"delayed\",         \"skipped\",         \"canceled\",         \"killed\",         \"completed\"       ],       \"title\": \"Status\",       \"type\": \"string\"     },     \"Status2\": {       \"enum\": [         \"queued\",         \"selected\",         \"dispatched\",         \"failed_to_assign\",         \"canceled_in_flight\"       ],       \"title\": \"Status2\",       \"type\": \"string\"     },     \"Undo\": {       \"properties\": {         \"unix_millis_request_time\": {           \"description\": \"The time that the undo skip request arrived\",           \"title\": \"Unix Millis Request Time\",           \"type\": \"integer\"         },         \"labels\": {           \"description\": \"Labels to describe the undo skip request\",           \"items\": {             \"type\": \"string\"           },           \"title\": \"Labels\",           \"type\": \"array\"         }       },       \"required\": [         \"unix_millis_request_time\",         \"labels\"       ],       \"title\": \"Undo\",       \"type\": \"object\"     }   },   \"properties\": {     \"booking\": {       \"$ref\": \"#/$defs/Booking\"     },     \"category\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Category\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"detail\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Detail\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"unix_millis_start_time\": {       \"anyOf\": [         {           \"type\": \"integer\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"title\": \"Unix Millis Start Time\"     },     \"unix_millis_finish_time\": {       \"anyOf\": [         {           \"type\": \"integer\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"title\": \"Unix Millis Finish Time\"     },     \"original_estimate_millis\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/EstimateMillis\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"estimate_millis\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/EstimateMillis\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"assigned_to\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/AssignedTo\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"Which agent (robot) is the task assigned to\"     },     \"status\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Status\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"dispatch\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Dispatch\"         },         {           \"type\": \"null\"         }       ],       \"default\": null     },     \"phases\": {       \"anyOf\": [         {           \"additionalProperties\": {             \"$ref\": \"#/$defs/Phase\"           },           \"type\": \"object\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"A dictionary of the states of the phases of the task. The keys (property names) are phase IDs, which are integers.\",       \"title\": \"Phases\"     },     \"completed\": {       \"anyOf\": [         {           \"items\": {             \"$ref\": \"#/$defs/Id\"           },           \"type\": \"array\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"An array of the IDs of completed phases of this task\",       \"title\": \"Completed\"     },     \"active\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Id\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"The ID of the active phase for this task\"     },     \"pending\": {       \"anyOf\": [         {           \"items\": {             \"$ref\": \"#/$defs/Id\"           },           \"type\": \"array\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"An array of the pending phases of this task\",       \"title\": \"Pending\"     },     \"interruptions\": {       \"anyOf\": [         {           \"additionalProperties\": {             \"$ref\": \"#/$defs/Interruption\"           },           \"type\": \"object\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"A dictionary of interruptions that have been applied to this task. The keys (property names) are the unique token of the interruption request.\",       \"title\": \"Interruptions\"     },     \"cancellation\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Cancellation\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"If the task was cancelled, this will describe information about the request.\"     },     \"killed\": {       \"anyOf\": [         {           \"$ref\": \"#/$defs/Killed\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"If the task was killed, this will describe information about the request.\"     }   },   \"required\": [     \"booking\"   ],   \"title\": \"TaskState\",   \"type\": \"object\" } ```   ### /tasks/{task_id}/log   ``` {   \"$defs\": {     \"LogEntry\": {       \"properties\": {         \"seq\": {           \"description\": \"Sequence number for this entry. Each entry has a unique sequence number which monotonically increase, until integer overflow causes a wrap around.\",           \"exclusiveMaximum\": 4294967296,           \"minimum\": 0,           \"title\": \"Seq\",           \"type\": \"integer\"         },         \"tier\": {           \"allOf\": [             {               \"$ref\": \"#/$defs/Tier\"             }           ],           \"description\": \"The importance level of the log entry\"         },         \"unix_millis_time\": {           \"title\": \"Unix Millis Time\",           \"type\": \"integer\"         },         \"text\": {           \"description\": \"The text of the log entry\",           \"title\": \"Text\",           \"type\": \"string\"         }       },       \"required\": [         \"seq\",         \"tier\",         \"unix_millis_time\",         \"text\"       ],       \"title\": \"LogEntry\",       \"type\": \"object\"     },     \"Phases\": {       \"additionalProperties\": false,       \"properties\": {         \"log\": {           \"anyOf\": [             {               \"items\": {                 \"$ref\": \"#/$defs/LogEntry\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Log entries related to the overall phase\",           \"title\": \"Log\"         },         \"events\": {           \"anyOf\": [             {               \"additionalProperties\": {                 \"items\": {                   \"$ref\": \"#/$defs/LogEntry\"                 },                 \"type\": \"array\"               },               \"type\": \"object\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A dictionary whose keys (property names) are the indices of an event in the phase\",           \"title\": \"Events\"         }       },       \"title\": \"Phases\",       \"type\": \"object\"     },     \"Tier\": {       \"enum\": [         \"uninitialized\",         \"info\",         \"warning\",         \"error\"       ],       \"title\": \"Tier\",       \"type\": \"string\"     }   },   \"additionalProperties\": false,   \"properties\": {     \"task_id\": {       \"title\": \"Task Id\",       \"type\": \"string\"     },     \"log\": {       \"anyOf\": [         {           \"items\": {             \"$ref\": \"#/$defs/LogEntry\"           },           \"type\": \"array\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"Log entries related to the overall task\",       \"title\": \"Log\"     },     \"phases\": {       \"anyOf\": [         {           \"additionalProperties\": {             \"$ref\": \"#/$defs/Phases\"           },           \"type\": \"object\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"A dictionary whose keys (property names) are the indices of a phase\",       \"title\": \"Phases\"     }   },   \"required\": [     \"task_id\"   ],   \"title\": \"TaskEventLog\",   \"type\": \"object\" } ```   ### /dispensers/{guid}/state   ``` {   \"$defs\": {     \"Time\": {       \"properties\": {         \"sec\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Sec\",           \"type\": \"integer\"         },         \"nanosec\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Nanosec\",           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ],       \"title\": \"Time\",       \"type\": \"object\"     }   },   \"properties\": {     \"time\": {       \"$ref\": \"#/$defs/Time\"     },     \"guid\": {       \"title\": \"Guid\",       \"type\": \"string\"     },     \"mode\": {       \"maximum\": 2147483647,       \"minimum\": -2147483648,       \"title\": \"Mode\",       \"type\": \"integer\"     },     \"request_guid_queue\": {       \"items\": {         \"type\": \"string\"       },       \"title\": \"Request Guid Queue\",       \"type\": \"array\"     },     \"seconds_remaining\": {       \"title\": \"Seconds Remaining\",       \"type\": \"number\"     }   },   \"required\": [     \"time\",     \"guid\",     \"mode\",     \"request_guid_queue\",     \"seconds_remaining\"   ],   \"title\": \"DispenserState\",   \"type\": \"object\" } ```   ### /dispensers/{guid}/health   ``` {   \"$defs\": {     \"HealthStatus\": {       \"enum\": [         \"Healthy\",         \"Unhealthy\",         \"Dead\"       ],       \"title\": \"HealthStatus\",       \"type\": \"string\"     }   },   \"properties\": {     \"id_\": {       \"title\": \"Id \",       \"type\": \"string\"     },     \"health_status\": {       \"$ref\": \"#/$defs/HealthStatus\"     },     \"health_message\": {       \"anyOf\": [         {           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"title\": \"Health Message\"     }   },   \"required\": [     \"id_\",     \"health_status\",     \"health_message\"   ],   \"title\": \"DispenserHealth\",   \"type\": \"object\" } ```   ### /ingestors/{guid}/state   ``` {   \"$defs\": {     \"Time\": {       \"properties\": {         \"sec\": {           \"maximum\": 2147483647,           \"minimum\": -2147483648,           \"title\": \"Sec\",           \"type\": \"integer\"         },         \"nanosec\": {           \"maximum\": 4294967295,           \"minimum\": 0,           \"title\": \"Nanosec\",           \"type\": \"integer\"         }       },       \"required\": [         \"sec\",         \"nanosec\"       ],       \"title\": \"Time\",       \"type\": \"object\"     }   },   \"properties\": {     \"time\": {       \"$ref\": \"#/$defs/Time\"     },     \"guid\": {       \"title\": \"Guid\",       \"type\": \"string\"     },     \"mode\": {       \"maximum\": 2147483647,       \"minimum\": -2147483648,       \"title\": \"Mode\",       \"type\": \"integer\"     },     \"request_guid_queue\": {       \"items\": {         \"type\": \"string\"       },       \"title\": \"Request Guid Queue\",       \"type\": \"array\"     },     \"seconds_remaining\": {       \"title\": \"Seconds Remaining\",       \"type\": \"number\"     }   },   \"required\": [     \"time\",     \"guid\",     \"mode\",     \"request_guid_queue\",     \"seconds_remaining\"   ],   \"title\": \"IngestorState\",   \"type\": \"object\" } ```   ### /ingestors/{guid}/health   ``` {   \"$defs\": {     \"HealthStatus\": {       \"enum\": [         \"Healthy\",         \"Unhealthy\",         \"Dead\"       ],       \"title\": \"HealthStatus\",       \"type\": \"string\"     }   },   \"properties\": {     \"id_\": {       \"title\": \"Id \",       \"type\": \"string\"     },     \"health_status\": {       \"$ref\": \"#/$defs/HealthStatus\"     },     \"health_message\": {       \"anyOf\": [         {           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"title\": \"Health Message\"     }   },   \"required\": [     \"id_\",     \"health_status\",     \"health_message\"   ],   \"title\": \"IngestorHealth\",   \"type\": \"object\" } ```   ### /fleets/{name}/state   ``` {   \"$defs\": {     \"Issue\": {       \"properties\": {         \"category\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Category of the robot\'s issue\",           \"title\": \"Category\"         },         \"detail\": {           \"anyOf\": [             {               \"type\": \"object\"             },             {               \"items\": {},               \"type\": \"array\"             },             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"Detailed information about the issue\",           \"title\": \"Detail\"         }       },       \"title\": \"Issue\",       \"type\": \"object\"     },     \"Location2D\": {       \"properties\": {         \"map\": {           \"title\": \"Map\",           \"type\": \"string\"         },         \"x\": {           \"title\": \"X\",           \"type\": \"number\"         },         \"y\": {           \"title\": \"Y\",           \"type\": \"number\"         },         \"yaw\": {           \"title\": \"Yaw\",           \"type\": \"number\"         }       },       \"required\": [         \"map\",         \"x\",         \"y\",         \"yaw\"       ],       \"title\": \"Location2D\",       \"type\": \"object\"     },     \"RobotState\": {       \"properties\": {         \"name\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Name\"         },         \"status\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Status\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A simple token representing the status of the robot\"         },         \"task_id\": {           \"anyOf\": [             {               \"type\": \"string\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"The ID of the task this robot is currently working on. Empty string if the robot is not working on a task.\",           \"title\": \"Task Id\"         },         \"unix_millis_time\": {           \"anyOf\": [             {               \"type\": \"integer\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"title\": \"Unix Millis Time\"         },         \"location\": {           \"anyOf\": [             {               \"$ref\": \"#/$defs/Location2D\"             },             {               \"type\": \"null\"             }           ],           \"default\": null         },         \"battery\": {           \"anyOf\": [             {               \"maximum\": 1.0,               \"minimum\": 0.0,               \"type\": \"number\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"State of charge of the battery. Values range from 0.0 (depleted) to 1.0 (fully charged)\",           \"title\": \"Battery\"         },         \"issues\": {           \"anyOf\": [             {               \"items\": {                 \"$ref\": \"#/$defs/Issue\"               },               \"type\": \"array\"             },             {               \"type\": \"null\"             }           ],           \"default\": null,           \"description\": \"A list of issues with the robot that operators need to address\",           \"title\": \"Issues\"         }       },       \"title\": \"RobotState\",       \"type\": \"object\"     },     \"Status\": {       \"enum\": [         \"uninitialized\",         \"offline\",         \"shutdown\",         \"idle\",         \"charging\",         \"working\",         \"error\"       ],       \"title\": \"Status\",       \"type\": \"string\"     }   },   \"properties\": {     \"name\": {       \"anyOf\": [         {           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"title\": \"Name\"     },     \"robots\": {       \"anyOf\": [         {           \"additionalProperties\": {             \"$ref\": \"#/$defs/RobotState\"           },           \"type\": \"object\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"A dictionary of the states of the robots that belong to this fleet\",       \"title\": \"Robots\"     }   },   \"title\": \"FleetState\",   \"type\": \"object\" } ```   ### /fleets/{name}/log   ``` {   \"$defs\": {     \"LogEntry\": {       \"properties\": {         \"seq\": {           \"description\": \"Sequence number for this entry. Each entry has a unique sequence number which monotonically increase, until integer overflow causes a wrap around.\",           \"exclusiveMaximum\": 4294967296,           \"minimum\": 0,           \"title\": \"Seq\",           \"type\": \"integer\"         },         \"tier\": {           \"allOf\": [             {               \"$ref\": \"#/$defs/Tier\"             }           ],           \"description\": \"The importance level of the log entry\"         },         \"unix_millis_time\": {           \"title\": \"Unix Millis Time\",           \"type\": \"integer\"         },         \"text\": {           \"description\": \"The text of the log entry\",           \"title\": \"Text\",           \"type\": \"string\"         }       },       \"required\": [         \"seq\",         \"tier\",         \"unix_millis_time\",         \"text\"       ],       \"title\": \"LogEntry\",       \"type\": \"object\"     },     \"Tier\": {       \"enum\": [         \"uninitialized\",         \"info\",         \"warning\",         \"error\"       ],       \"title\": \"Tier\",       \"type\": \"string\"     }   },   \"properties\": {     \"name\": {       \"anyOf\": [         {           \"type\": \"string\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"title\": \"Name\"     },     \"log\": {       \"anyOf\": [         {           \"items\": {             \"$ref\": \"#/$defs/LogEntry\"           },           \"type\": \"array\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"Log for the overall fleet\",       \"title\": \"Log\"     },     \"robots\": {       \"anyOf\": [         {           \"additionalProperties\": {             \"items\": {               \"$ref\": \"#/$defs/LogEntry\"             },             \"type\": \"array\"           },           \"type\": \"object\"         },         {           \"type\": \"null\"         }       ],       \"default\": null,       \"description\": \"Dictionary of logs for the individual robots. The keys (property names) are the robot names.\",       \"title\": \"Robots\"     }   },   \"title\": \"FleetLog\",   \"type\": \"object\" } ```
   * @summary Socket.io endpoint
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public lambdaSocketIoGet(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .lambdaSocketIoGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * DispensersApi - axios parameter creator
 * @export
 */
export const DispensersApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Available in socket.io
     * @summary Get Dispenser Health
     * @param {string} guid
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDispenserHealthDispensersGuidHealthGet: async (
      guid: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guid' is not null or undefined
      assertParamExists('getDispenserHealthDispensersGuidHealthGet', 'guid', guid);
      const localVarPath = `/dispensers/{guid}/health`.replace(
        `{${'guid'}}`,
        encodeURIComponent(String(guid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Available in socket.io
     * @summary Get Dispenser State
     * @param {string} guid
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDispenserStateDispensersGuidStateGet: async (
      guid: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guid' is not null or undefined
      assertParamExists('getDispenserStateDispensersGuidStateGet', 'guid', guid);
      const localVarPath = `/dispensers/{guid}/state`.replace(
        `{${'guid'}}`,
        encodeURIComponent(String(guid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Dispensers
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDispensersDispensersGet: async (
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/dispensers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DispensersApi - functional programming interface
 * @export
 */
export const DispensersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DispensersApiAxiosParamCreator(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Dispenser Health
     * @param {string} guid
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDispenserHealthDispensersGuidHealthGet(
      guid: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DispenserHealth>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getDispenserHealthDispensersGuidHealthGet(
          guid,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DispensersApi.getDispenserHealthDispensersGuidHealthGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Available in socket.io
     * @summary Get Dispenser State
     * @param {string} guid
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDispenserStateDispensersGuidStateGet(
      guid: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DispenserState>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getDispenserStateDispensersGuidStateGet(
          guid,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DispensersApi.getDispenserStateDispensersGuidStateGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get Dispensers
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDispensersDispensersGet(
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dispenser>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDispensersDispensersGet(
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DispensersApi.getDispensersDispensersGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * DispensersApi - factory interface
 * @export
 */
export const DispensersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DispensersApiFp(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Dispenser Health
     * @param {string} guid
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDispenserHealthDispensersGuidHealthGet(
      guid: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<DispenserHealth> {
      return localVarFp
        .getDispenserHealthDispensersGuidHealthGet(guid, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Available in socket.io
     * @summary Get Dispenser State
     * @param {string} guid
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDispenserStateDispensersGuidStateGet(
      guid: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<DispenserState> {
      return localVarFp
        .getDispenserStateDispensersGuidStateGet(guid, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Dispensers
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDispensersDispensersGet(
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<Array<Dispenser>> {
      return localVarFp
        .getDispensersDispensersGet(authorization, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * DispensersApi - object-oriented interface
 * @export
 * @class DispensersApi
 * @extends {BaseAPI}
 */
export class DispensersApi extends BaseAPI {
  /**
   * Available in socket.io
   * @summary Get Dispenser Health
   * @param {string} guid
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DispensersApi
   */
  public getDispenserHealthDispensersGuidHealthGet(
    guid: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return DispensersApiFp(this.configuration)
      .getDispenserHealthDispensersGuidHealthGet(guid, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Available in socket.io
   * @summary Get Dispenser State
   * @param {string} guid
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DispensersApi
   */
  public getDispenserStateDispensersGuidStateGet(
    guid: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return DispensersApiFp(this.configuration)
      .getDispenserStateDispensersGuidStateGet(guid, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Dispensers
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DispensersApi
   */
  public getDispensersDispensersGet(
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return DispensersApiFp(this.configuration)
      .getDispensersDispensersGet(authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * DoorsApi - axios parameter creator
 * @export
 */
export const DoorsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Available in socket.io
     * @summary Get Door Health
     * @param {string} doorName
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDoorHealthDoorsDoorNameHealthGet: async (
      doorName: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'doorName' is not null or undefined
      assertParamExists('getDoorHealthDoorsDoorNameHealthGet', 'doorName', doorName);
      const localVarPath = `/doors/{door_name}/health`.replace(
        `{${'door_name'}}`,
        encodeURIComponent(String(doorName)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Available in socket.io
     * @summary Get Door State
     * @param {string} doorName
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDoorStateDoorsDoorNameStateGet: async (
      doorName: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'doorName' is not null or undefined
      assertParamExists('getDoorStateDoorsDoorNameStateGet', 'doorName', doorName);
      const localVarPath = `/doors/{door_name}/state`.replace(
        `{${'door_name'}}`,
        encodeURIComponent(String(doorName)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Doors
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDoorsDoorsGet: async (
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/doors`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post Door Request
     * @param {string} doorName
     * @param {DoorRequest} doorRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postDoorRequestDoorsDoorNameRequestPost: async (
      doorName: string,
      doorRequest: DoorRequest,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'doorName' is not null or undefined
      assertParamExists('postDoorRequestDoorsDoorNameRequestPost', 'doorName', doorName);
      // verify required parameter 'doorRequest' is not null or undefined
      assertParamExists('postDoorRequestDoorsDoorNameRequestPost', 'doorRequest', doorRequest);
      const localVarPath = `/doors/{door_name}/request`.replace(
        `{${'door_name'}}`,
        encodeURIComponent(String(doorName)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        doorRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DoorsApi - functional programming interface
 * @export
 */
export const DoorsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DoorsApiAxiosParamCreator(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Door Health
     * @param {string} doorName
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDoorHealthDoorsDoorNameHealthGet(
      doorName: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DoorHealth>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDoorHealthDoorsDoorNameHealthGet(
        doorName,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DoorsApi.getDoorHealthDoorsDoorNameHealthGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Available in socket.io
     * @summary Get Door State
     * @param {string} doorName
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDoorStateDoorsDoorNameStateGet(
      doorName: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DoorState>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDoorStateDoorsDoorNameStateGet(
        doorName,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DoorsApi.getDoorStateDoorsDoorNameStateGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get Doors
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDoorsDoorsGet(
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Door>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDoorsDoorsGet(
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DoorsApi.getDoorsDoorsGet']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Post Door Request
     * @param {string} doorName
     * @param {DoorRequest} doorRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postDoorRequestDoorsDoorNameRequestPost(
      doorName: string,
      doorRequest: DoorRequest,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postDoorRequestDoorsDoorNameRequestPost(
          doorName,
          doorRequest,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DoorsApi.postDoorRequestDoorsDoorNameRequestPost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * DoorsApi - factory interface
 * @export
 */
export const DoorsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DoorsApiFp(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Door Health
     * @param {string} doorName
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDoorHealthDoorsDoorNameHealthGet(
      doorName: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<DoorHealth> {
      return localVarFp
        .getDoorHealthDoorsDoorNameHealthGet(doorName, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Available in socket.io
     * @summary Get Door State
     * @param {string} doorName
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDoorStateDoorsDoorNameStateGet(
      doorName: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<DoorState> {
      return localVarFp
        .getDoorStateDoorsDoorNameStateGet(doorName, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Doors
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDoorsDoorsGet(authorization?: string | null, options?: any): AxiosPromise<Array<Door>> {
      return localVarFp
        .getDoorsDoorsGet(authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Post Door Request
     * @param {string} doorName
     * @param {DoorRequest} doorRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postDoorRequestDoorsDoorNameRequestPost(
      doorName: string,
      doorRequest: DoorRequest,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .postDoorRequestDoorsDoorNameRequestPost(doorName, doorRequest, authorization, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * DoorsApi - object-oriented interface
 * @export
 * @class DoorsApi
 * @extends {BaseAPI}
 */
export class DoorsApi extends BaseAPI {
  /**
   * Available in socket.io
   * @summary Get Door Health
   * @param {string} doorName
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DoorsApi
   */
  public getDoorHealthDoorsDoorNameHealthGet(
    doorName: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return DoorsApiFp(this.configuration)
      .getDoorHealthDoorsDoorNameHealthGet(doorName, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Available in socket.io
   * @summary Get Door State
   * @param {string} doorName
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DoorsApi
   */
  public getDoorStateDoorsDoorNameStateGet(
    doorName: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return DoorsApiFp(this.configuration)
      .getDoorStateDoorsDoorNameStateGet(doorName, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Doors
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DoorsApi
   */
  public getDoorsDoorsGet(authorization?: string | null, options?: RawAxiosRequestConfig) {
    return DoorsApiFp(this.configuration)
      .getDoorsDoorsGet(authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Post Door Request
   * @param {string} doorName
   * @param {DoorRequest} doorRequest
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DoorsApi
   */
  public postDoorRequestDoorsDoorNameRequestPost(
    doorName: string,
    doorRequest: DoorRequest,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return DoorsApiFp(this.configuration)
      .postDoorRequestDoorsDoorNameRequestPost(doorName, doorRequest, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * FleetsApi - axios parameter creator
 * @export
 */
export const FleetsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Available in socket.io
     * @summary Get Fleet Log
     * @param {string} name
     * @param {string} [between]          The period of time to fetch, in unix millis.          This can be either a comma separated string or a string prefixed with \&#39;-\&#39; to fetch the last X millis.          Example:             \&quot;1000,2000\&quot; - Fetches logs between unix millis 1000 and 2000.             \&quot;-60000\&quot; - Fetches logs in the last minute.
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFleetLogFleetsNameLogGet: async (
      name: string,
      between?: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getFleetLogFleetsNameLogGet', 'name', name);
      const localVarPath = `/fleets/{name}/log`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (between !== undefined) {
        localVarQueryParameter['between'] = between;
      }

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Available in socket.io
     * @summary Get Fleet State
     * @param {string} name
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFleetStateFleetsNameStateGet: async (
      name: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getFleetStateFleetsNameStateGet', 'name', name);
      const localVarPath = `/fleets/{name}/state`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Fleets
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFleetsFleetsGet: async (
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/fleets`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FleetsApi - functional programming interface
 * @export
 */
export const FleetsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FleetsApiAxiosParamCreator(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Fleet Log
     * @param {string} name
     * @param {string} [between]          The period of time to fetch, in unix millis.          This can be either a comma separated string or a string prefixed with \&#39;-\&#39; to fetch the last X millis.          Example:             \&quot;1000,2000\&quot; - Fetches logs between unix millis 1000 and 2000.             \&quot;-60000\&quot; - Fetches logs in the last minute.
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFleetLogFleetsNameLogGet(
      name: string,
      between?: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FleetLog>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFleetLogFleetsNameLogGet(
        name,
        between,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['FleetsApi.getFleetLogFleetsNameLogGet']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Available in socket.io
     * @summary Get Fleet State
     * @param {string} name
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFleetStateFleetsNameStateGet(
      name: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FleetState>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFleetStateFleetsNameStateGet(
        name,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['FleetsApi.getFleetStateFleetsNameStateGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get Fleets
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFleetsFleetsGet(
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FleetState>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFleetsFleetsGet(
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['FleetsApi.getFleetsFleetsGet']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * FleetsApi - factory interface
 * @export
 */
export const FleetsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = FleetsApiFp(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Fleet Log
     * @param {string} name
     * @param {string} [between]          The period of time to fetch, in unix millis.          This can be either a comma separated string or a string prefixed with \&#39;-\&#39; to fetch the last X millis.          Example:             \&quot;1000,2000\&quot; - Fetches logs between unix millis 1000 and 2000.             \&quot;-60000\&quot; - Fetches logs in the last minute.
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFleetLogFleetsNameLogGet(
      name: string,
      between?: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<FleetLog> {
      return localVarFp
        .getFleetLogFleetsNameLogGet(name, between, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Available in socket.io
     * @summary Get Fleet State
     * @param {string} name
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFleetStateFleetsNameStateGet(
      name: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<FleetState> {
      return localVarFp
        .getFleetStateFleetsNameStateGet(name, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Fleets
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFleetsFleetsGet(
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<Array<FleetState>> {
      return localVarFp
        .getFleetsFleetsGet(authorization, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * FleetsApi - object-oriented interface
 * @export
 * @class FleetsApi
 * @extends {BaseAPI}
 */
export class FleetsApi extends BaseAPI {
  /**
   * Available in socket.io
   * @summary Get Fleet Log
   * @param {string} name
   * @param {string} [between]          The period of time to fetch, in unix millis.          This can be either a comma separated string or a string prefixed with \&#39;-\&#39; to fetch the last X millis.          Example:             \&quot;1000,2000\&quot; - Fetches logs between unix millis 1000 and 2000.             \&quot;-60000\&quot; - Fetches logs in the last minute.
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetsApi
   */
  public getFleetLogFleetsNameLogGet(
    name: string,
    between?: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return FleetsApiFp(this.configuration)
      .getFleetLogFleetsNameLogGet(name, between, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Available in socket.io
   * @summary Get Fleet State
   * @param {string} name
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetsApi
   */
  public getFleetStateFleetsNameStateGet(
    name: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return FleetsApiFp(this.configuration)
      .getFleetStateFleetsNameStateGet(name, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Fleets
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetsApi
   */
  public getFleetsFleetsGet(authorization?: string | null, options?: RawAxiosRequestConfig) {
    return FleetsApiFp(this.configuration)
      .getFleetsFleetsGet(authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * IngestorsApi - axios parameter creator
 * @export
 */
export const IngestorsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Available in socket.io
     * @summary Get Ingestor Health
     * @param {string} guid
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIngestorHealthIngestorsGuidHealthGet: async (
      guid: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guid' is not null or undefined
      assertParamExists('getIngestorHealthIngestorsGuidHealthGet', 'guid', guid);
      const localVarPath = `/ingestors/{guid}/health`.replace(
        `{${'guid'}}`,
        encodeURIComponent(String(guid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Available in socket.io
     * @summary Get Ingestor State
     * @param {string} guid
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIngestorStateIngestorsGuidStateGet: async (
      guid: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guid' is not null or undefined
      assertParamExists('getIngestorStateIngestorsGuidStateGet', 'guid', guid);
      const localVarPath = `/ingestors/{guid}/state`.replace(
        `{${'guid'}}`,
        encodeURIComponent(String(guid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Ingestors
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIngestorsIngestorsGet: async (
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/ingestors`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * IngestorsApi - functional programming interface
 * @export
 */
export const IngestorsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = IngestorsApiAxiosParamCreator(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Ingestor Health
     * @param {string} guid
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getIngestorHealthIngestorsGuidHealthGet(
      guid: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IngestorHealth>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getIngestorHealthIngestorsGuidHealthGet(
          guid,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['IngestorsApi.getIngestorHealthIngestorsGuidHealthGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Available in socket.io
     * @summary Get Ingestor State
     * @param {string} guid
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getIngestorStateIngestorsGuidStateGet(
      guid: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IngestorState>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getIngestorStateIngestorsGuidStateGet(
          guid,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['IngestorsApi.getIngestorStateIngestorsGuidStateGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get Ingestors
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getIngestorsIngestorsGet(
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Ingestor>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getIngestorsIngestorsGet(
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['IngestorsApi.getIngestorsIngestorsGet']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * IngestorsApi - factory interface
 * @export
 */
export const IngestorsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = IngestorsApiFp(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Ingestor Health
     * @param {string} guid
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIngestorHealthIngestorsGuidHealthGet(
      guid: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<IngestorHealth> {
      return localVarFp
        .getIngestorHealthIngestorsGuidHealthGet(guid, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Available in socket.io
     * @summary Get Ingestor State
     * @param {string} guid
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIngestorStateIngestorsGuidStateGet(
      guid: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<IngestorState> {
      return localVarFp
        .getIngestorStateIngestorsGuidStateGet(guid, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Ingestors
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIngestorsIngestorsGet(
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<Array<Ingestor>> {
      return localVarFp
        .getIngestorsIngestorsGet(authorization, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * IngestorsApi - object-oriented interface
 * @export
 * @class IngestorsApi
 * @extends {BaseAPI}
 */
export class IngestorsApi extends BaseAPI {
  /**
   * Available in socket.io
   * @summary Get Ingestor Health
   * @param {string} guid
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IngestorsApi
   */
  public getIngestorHealthIngestorsGuidHealthGet(
    guid: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return IngestorsApiFp(this.configuration)
      .getIngestorHealthIngestorsGuidHealthGet(guid, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Available in socket.io
   * @summary Get Ingestor State
   * @param {string} guid
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IngestorsApi
   */
  public getIngestorStateIngestorsGuidStateGet(
    guid: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return IngestorsApiFp(this.configuration)
      .getIngestorStateIngestorsGuidStateGet(guid, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Ingestors
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IngestorsApi
   */
  public getIngestorsIngestorsGet(authorization?: string | null, options?: RawAxiosRequestConfig) {
    return IngestorsApiFp(this.configuration)
      .getIngestorsIngestorsGet(authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * LiftsApi - axios parameter creator
 * @export
 */
export const LiftsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Available in socket.io
     * @summary Get Lift Health
     * @param {string} liftName
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLiftHealthLiftsLiftNameHealthGet: async (
      liftName: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'liftName' is not null or undefined
      assertParamExists('getLiftHealthLiftsLiftNameHealthGet', 'liftName', liftName);
      const localVarPath = `/lifts/{lift_name}/health`.replace(
        `{${'lift_name'}}`,
        encodeURIComponent(String(liftName)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Available in socket.io
     * @summary Get Lift State
     * @param {string} liftName
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLiftStateLiftsLiftNameStateGet: async (
      liftName: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'liftName' is not null or undefined
      assertParamExists('getLiftStateLiftsLiftNameStateGet', 'liftName', liftName);
      const localVarPath = `/lifts/{lift_name}/state`.replace(
        `{${'lift_name'}}`,
        encodeURIComponent(String(liftName)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Lifts
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLiftsLiftsGet: async (
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/lifts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary  Post Lift Request
     * @param {string} liftName
     * @param {LiftRequest} liftRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postLiftRequestLiftsLiftNameRequestPost: async (
      liftName: string,
      liftRequest: LiftRequest,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'liftName' is not null or undefined
      assertParamExists('postLiftRequestLiftsLiftNameRequestPost', 'liftName', liftName);
      // verify required parameter 'liftRequest' is not null or undefined
      assertParamExists('postLiftRequestLiftsLiftNameRequestPost', 'liftRequest', liftRequest);
      const localVarPath = `/lifts/{lift_name}/request`.replace(
        `{${'lift_name'}}`,
        encodeURIComponent(String(liftName)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        liftRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LiftsApi - functional programming interface
 * @export
 */
export const LiftsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = LiftsApiAxiosParamCreator(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Lift Health
     * @param {string} liftName
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLiftHealthLiftsLiftNameHealthGet(
      liftName: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiftHealth>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLiftHealthLiftsLiftNameHealthGet(
        liftName,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['LiftsApi.getLiftHealthLiftsLiftNameHealthGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Available in socket.io
     * @summary Get Lift State
     * @param {string} liftName
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLiftStateLiftsLiftNameStateGet(
      liftName: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiftState>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLiftStateLiftsLiftNameStateGet(
        liftName,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['LiftsApi.getLiftStateLiftsLiftNameStateGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get Lifts
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLiftsLiftsGet(
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Lift>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLiftsLiftsGet(
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['LiftsApi.getLiftsLiftsGet']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary  Post Lift Request
     * @param {string} liftName
     * @param {LiftRequest} liftRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postLiftRequestLiftsLiftNameRequestPost(
      liftName: string,
      liftRequest: LiftRequest,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postLiftRequestLiftsLiftNameRequestPost(
          liftName,
          liftRequest,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['LiftsApi.postLiftRequestLiftsLiftNameRequestPost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * LiftsApi - factory interface
 * @export
 */
export const LiftsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = LiftsApiFp(configuration);
  return {
    /**
     * Available in socket.io
     * @summary Get Lift Health
     * @param {string} liftName
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLiftHealthLiftsLiftNameHealthGet(
      liftName: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<LiftHealth> {
      return localVarFp
        .getLiftHealthLiftsLiftNameHealthGet(liftName, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Available in socket.io
     * @summary Get Lift State
     * @param {string} liftName
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLiftStateLiftsLiftNameStateGet(
      liftName: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<LiftState> {
      return localVarFp
        .getLiftStateLiftsLiftNameStateGet(liftName, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Lifts
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLiftsLiftsGet(authorization?: string | null, options?: any): AxiosPromise<Array<Lift>> {
      return localVarFp
        .getLiftsLiftsGet(authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary  Post Lift Request
     * @param {string} liftName
     * @param {LiftRequest} liftRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postLiftRequestLiftsLiftNameRequestPost(
      liftName: string,
      liftRequest: LiftRequest,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .postLiftRequestLiftsLiftNameRequestPost(liftName, liftRequest, authorization, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * LiftsApi - object-oriented interface
 * @export
 * @class LiftsApi
 * @extends {BaseAPI}
 */
export class LiftsApi extends BaseAPI {
  /**
   * Available in socket.io
   * @summary Get Lift Health
   * @param {string} liftName
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LiftsApi
   */
  public getLiftHealthLiftsLiftNameHealthGet(
    liftName: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return LiftsApiFp(this.configuration)
      .getLiftHealthLiftsLiftNameHealthGet(liftName, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Available in socket.io
   * @summary Get Lift State
   * @param {string} liftName
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LiftsApi
   */
  public getLiftStateLiftsLiftNameStateGet(
    liftName: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return LiftsApiFp(this.configuration)
      .getLiftStateLiftsLiftNameStateGet(liftName, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Lifts
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LiftsApi
   */
  public getLiftsLiftsGet(authorization?: string | null, options?: RawAxiosRequestConfig) {
    return LiftsApiFp(this.configuration)
      .getLiftsLiftsGet(authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary  Post Lift Request
   * @param {string} liftName
   * @param {LiftRequest} liftRequest
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LiftsApi
   */
  public postLiftRequestLiftsLiftNameRequestPost(
    liftName: string,
    liftRequest: LiftRequest,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return LiftsApiFp(this.configuration)
      .postLiftRequestLiftsLiftNameRequestPost(liftName, liftRequest, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TasksApi - axios parameter creator
 * @export
 */
export const TasksApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Del Scheduled Tasks Event
     * @param {number} taskId
     * @param {string} eventDate
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    delScheduledTasksEventScheduledTasksTaskIdClearPut: async (
      taskId: number,
      eventDate: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskId' is not null or undefined
      assertParamExists('delScheduledTasksEventScheduledTasksTaskIdClearPut', 'taskId', taskId);
      // verify required parameter 'eventDate' is not null or undefined
      assertParamExists(
        'delScheduledTasksEventScheduledTasksTaskIdClearPut',
        'eventDate',
        eventDate,
      );
      const localVarPath = `/scheduled_tasks/{task_id}/clear`.replace(
        `{${'task_id'}}`,
        encodeURIComponent(String(taskId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (eventDate !== undefined) {
        localVarQueryParameter['event_date'] =
          (eventDate as any) instanceof Date ? (eventDate as any).toISOString() : eventDate;
      }

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Del Scheduled Tasks
     * @param {number} taskId
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    delScheduledTasksScheduledTasksTaskIdDelete: async (
      taskId: number,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskId' is not null or undefined
      assertParamExists('delScheduledTasksScheduledTasksTaskIdDelete', 'taskId', taskId);
      const localVarPath = `/scheduled_tasks/{task_id}`.replace(
        `{${'task_id'}}`,
        encodeURIComponent(String(taskId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete Favorite Task
     * @param {string} favoriteTaskId
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFavoriteTaskFavoriteTasksFavoriteTaskIdDelete: async (
      favoriteTaskId: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'favoriteTaskId' is not null or undefined
      assertParamExists(
        'deleteFavoriteTaskFavoriteTasksFavoriteTaskIdDelete',
        'favoriteTaskId',
        favoriteTaskId,
      );
      const localVarPath = `/favorite_tasks/{favorite_task_id}`.replace(
        `{${'favorite_task_id'}}`,
        encodeURIComponent(String(favoriteTaskId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Favorites Tasks
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFavoritesTasksFavoriteTasksGet: async (
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/favorite_tasks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Scheduled Task
     * @param {number} taskId
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getScheduledTaskScheduledTasksTaskIdGet: async (
      taskId: number,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskId' is not null or undefined
      assertParamExists('getScheduledTaskScheduledTasksTaskIdGet', 'taskId', taskId);
      const localVarPath = `/scheduled_tasks/{task_id}`.replace(
        `{${'task_id'}}`,
        encodeURIComponent(String(taskId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Scheduled Tasks
     * @param {string} startBefore Only return scheduled tasks that start before given timestamp
     * @param {string} untilAfter Only return scheduled tasks that stop after given timestamp
     * @param {number | null} [limit] defaults to 100
     * @param {number | null} [offset] defaults to 0
     * @param {string | null} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getScheduledTasksScheduledTasksGet: async (
      startBefore: string,
      untilAfter: string,
      limit?: number | null,
      offset?: number | null,
      orderBy?: string | null,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'startBefore' is not null or undefined
      assertParamExists('getScheduledTasksScheduledTasksGet', 'startBefore', startBefore);
      // verify required parameter 'untilAfter' is not null or undefined
      assertParamExists('getScheduledTasksScheduledTasksGet', 'untilAfter', untilAfter);
      const localVarPath = `/scheduled_tasks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (startBefore !== undefined) {
        localVarQueryParameter['start_before'] =
          (startBefore as any) instanceof Date ? (startBefore as any).toISOString() : startBefore;
      }

      if (untilAfter !== undefined) {
        localVarQueryParameter['until_after'] =
          (untilAfter as any) instanceof Date ? (untilAfter as any).toISOString() : untilAfter;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['order_by'] = orderBy;
      }

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Available in socket.io
     * @summary Get Task Log
     * @param {string} taskId task_id
     * @param {string} [between]          The period of time to fetch, in unix millis.          This can be either a comma separated string or a string prefixed with \&#39;-\&#39; to fetch the last X millis.          Example:             \&quot;1000,2000\&quot; - Fetches logs between unix millis 1000 and 2000.             \&quot;-60000\&quot; - Fetches logs in the last minute.
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskLogTasksTaskIdLogGet: async (
      taskId: string,
      between?: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskId' is not null or undefined
      assertParamExists('getTaskLogTasksTaskIdLogGet', 'taskId', taskId);
      const localVarPath = `/tasks/{task_id}/log`.replace(
        `{${'task_id'}}`,
        encodeURIComponent(String(taskId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (between !== undefined) {
        localVarQueryParameter['between'] = between;
      }

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Task Request
     * @param {string} taskId task_id
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskRequestTasksTaskIdRequestGet: async (
      taskId: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskId' is not null or undefined
      assertParamExists('getTaskRequestTasksTaskIdRequestGet', 'taskId', taskId);
      const localVarPath = `/tasks/{task_id}/request`.replace(
        `{${'task_id'}}`,
        encodeURIComponent(String(taskId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Available in socket.io
     * @summary Get Task State
     * @param {string} taskId task_id
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskStateTasksTaskIdStateGet: async (
      taskId: string,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskId' is not null or undefined
      assertParamExists('getTaskStateTasksTaskIdStateGet', 'taskId', taskId);
      const localVarPath = `/tasks/{task_id}/state`.replace(
        `{${'task_id'}}`,
        encodeURIComponent(String(taskId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post Activity Discovery
     * @param {ActivityDiscoveryRequest} activityDiscoveryRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postActivityDiscoveryTasksActivityDiscoveryPost: async (
      activityDiscoveryRequest: ActivityDiscoveryRequest,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'activityDiscoveryRequest' is not null or undefined
      assertParamExists(
        'postActivityDiscoveryTasksActivityDiscoveryPost',
        'activityDiscoveryRequest',
        activityDiscoveryRequest,
      );
      const localVarPath = `/tasks/activity_discovery`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        activityDiscoveryRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post Cancel Task
     * @param {CancelTaskRequest} cancelTaskRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postCancelTaskTasksCancelTaskPost: async (
      cancelTaskRequest: CancelTaskRequest,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'cancelTaskRequest' is not null or undefined
      assertParamExists(
        'postCancelTaskTasksCancelTaskPost',
        'cancelTaskRequest',
        cancelTaskRequest,
      );
      const localVarPath = `/tasks/cancel_task`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        cancelTaskRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post Dispatch Task
     * @param {DispatchTaskRequest} dispatchTaskRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postDispatchTaskTasksDispatchTaskPost: async (
      dispatchTaskRequest: DispatchTaskRequest,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'dispatchTaskRequest' is not null or undefined
      assertParamExists(
        'postDispatchTaskTasksDispatchTaskPost',
        'dispatchTaskRequest',
        dispatchTaskRequest,
      );
      const localVarPath = `/tasks/dispatch_task`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        dispatchTaskRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post Favorite Task
     * @param {TaskFavoritePydantic} taskFavoritePydantic
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postFavoriteTaskFavoriteTasksPost: async (
      taskFavoritePydantic: TaskFavoritePydantic,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskFavoritePydantic' is not null or undefined
      assertParamExists(
        'postFavoriteTaskFavoriteTasksPost',
        'taskFavoritePydantic',
        taskFavoritePydantic,
      );
      const localVarPath = `/favorite_tasks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        taskFavoritePydantic,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post Interrupt Task
     * @param {TaskInterruptionRequest} taskInterruptionRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postInterruptTaskTasksInterruptTaskPost: async (
      taskInterruptionRequest: TaskInterruptionRequest,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskInterruptionRequest' is not null or undefined
      assertParamExists(
        'postInterruptTaskTasksInterruptTaskPost',
        'taskInterruptionRequest',
        taskInterruptionRequest,
      );
      const localVarPath = `/tasks/interrupt_task`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        taskInterruptionRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post Kill Task
     * @param {TaskKillRequest} taskKillRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postKillTaskTasksKillTaskPost: async (
      taskKillRequest: TaskKillRequest,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskKillRequest' is not null or undefined
      assertParamExists('postKillTaskTasksKillTaskPost', 'taskKillRequest', taskKillRequest);
      const localVarPath = `/tasks/kill_task`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        taskKillRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post Resume Task
     * @param {TaskResumeRequest} taskResumeRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postResumeTaskTasksResumeTaskPost: async (
      taskResumeRequest: TaskResumeRequest,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskResumeRequest' is not null or undefined
      assertParamExists(
        'postResumeTaskTasksResumeTaskPost',
        'taskResumeRequest',
        taskResumeRequest,
      );
      const localVarPath = `/tasks/resume_task`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        taskResumeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post Rewind Task
     * @param {TaskRewindRequest} taskRewindRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postRewindTaskTasksRewindTaskPost: async (
      taskRewindRequest: TaskRewindRequest,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskRewindRequest' is not null or undefined
      assertParamExists(
        'postRewindTaskTasksRewindTaskPost',
        'taskRewindRequest',
        taskRewindRequest,
      );
      const localVarPath = `/tasks/rewind_task`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        taskRewindRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post Robot Task
     * @param {RobotTaskRequest} robotTaskRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postRobotTaskTasksRobotTaskPost: async (
      robotTaskRequest: RobotTaskRequest,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'robotTaskRequest' is not null or undefined
      assertParamExists('postRobotTaskTasksRobotTaskPost', 'robotTaskRequest', robotTaskRequest);
      const localVarPath = `/tasks/robot_task`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        robotTaskRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a scheduled task. Below are some examples of how the schedules are represented. For more examples, check the docs of the underlying library used [here](https://github.com/dbader/schedule/blob/6eb0b5346b1ce35ece5050e65789fa6e44368175/docs/examples.rst).  | every | to | period | at | description | | - | - | - | - | - | | 10 | - | minutes | - | Every 10 minutes | | - | - | hour | - | Every hour | | - | - | day | 10:30 | Every day at 10:30am | | - | - | monday | - | Every monday | | - | - | wednesday | 13:15 | Every wednesday at 01:15pm | | - | - | minute | :17 | Every 17th sec of a mintue | | 5 | 10 | seconds | - | Every 5-10 seconds (randomly) |
     * @summary Post Scheduled Task
     * @param {PostScheduledTaskRequest} postScheduledTaskRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postScheduledTaskScheduledTasksPost: async (
      postScheduledTaskRequest: PostScheduledTaskRequest,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'postScheduledTaskRequest' is not null or undefined
      assertParamExists(
        'postScheduledTaskScheduledTasksPost',
        'postScheduledTaskRequest',
        postScheduledTaskRequest,
      );
      const localVarPath = `/scheduled_tasks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        postScheduledTaskRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post Skip Phase
     * @param {TaskPhaseSkipRequest} taskPhaseSkipRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postSkipPhaseTasksSkipPhasePost: async (
      taskPhaseSkipRequest: TaskPhaseSkipRequest,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskPhaseSkipRequest' is not null or undefined
      assertParamExists(
        'postSkipPhaseTasksSkipPhasePost',
        'taskPhaseSkipRequest',
        taskPhaseSkipRequest,
      );
      const localVarPath = `/tasks/skip_phase`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        taskPhaseSkipRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post Task Discovery
     * @param {TaskDiscoveryRequest} taskDiscoveryRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postTaskDiscoveryTasksTaskDiscoveryPost: async (
      taskDiscoveryRequest: TaskDiscoveryRequest,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskDiscoveryRequest' is not null or undefined
      assertParamExists(
        'postTaskDiscoveryTasksTaskDiscoveryPost',
        'taskDiscoveryRequest',
        taskDiscoveryRequest,
      );
      const localVarPath = `/tasks/task_discovery`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        taskDiscoveryRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post Undo Skip Phase
     * @param {UndoPhaseSkipRequest} undoPhaseSkipRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUndoSkipPhaseTasksUndoSkipPhasePost: async (
      undoPhaseSkipRequest: UndoPhaseSkipRequest,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'undoPhaseSkipRequest' is not null or undefined
      assertParamExists(
        'postUndoSkipPhaseTasksUndoSkipPhasePost',
        'undoPhaseSkipRequest',
        undoPhaseSkipRequest,
      );
      const localVarPath = `/tasks/undo_skip_phase`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        undoPhaseSkipRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Query Task States
     * @param {string | null} [taskId] comma separated list of task ids
     * @param {string | null} [category] comma separated list of task categories
     * @param {string | null} [assignedTo] comma separated list of assigned robot names
     * @param {string | null} [status] comma separated list of statuses
     * @param {string | null} [label] comma separated list of labels, each item must be in the form &lt;key&gt;&#x3D;&lt;value&gt;, multiple items will filter tasks with all the labels
     * @param {string} [startTimeBetween]          The period of starting time to fetch, in unix millis.          This must be a comma separated string, \&#39;X,Y\&#39; to fetch between X millis and Y millis inclusive.          Example:             \&quot;1000,2000\&quot; - Fetches logs between unix millis 1000 and 2000.
     * @param {string} [finishTimeBetween]          The period of finishing time to fetch, in unix millis.          This must be a comma separated string, \&#39;X,Y\&#39; to fetch between X millis and Y millis inclusive.          Example:             \&quot;1000,2000\&quot; - Fetches logs between unix millis 1000 and 2000.             \&quot;-60000\&quot; - Fetches logs in the last minute.
     * @param {number | null} [limit] defaults to 100
     * @param {number | null} [offset] defaults to 0
     * @param {string | null} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryTaskStatesTasksGet: async (
      taskId?: string | null,
      category?: string | null,
      assignedTo?: string | null,
      status?: string | null,
      label?: string | null,
      startTimeBetween?: string,
      finishTimeBetween?: string,
      limit?: number | null,
      offset?: number | null,
      orderBy?: string | null,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/tasks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (taskId !== undefined) {
        localVarQueryParameter['task_id'] = taskId;
      }

      if (category !== undefined) {
        localVarQueryParameter['category'] = category;
      }

      if (assignedTo !== undefined) {
        localVarQueryParameter['assigned_to'] = assignedTo;
      }

      if (status !== undefined) {
        localVarQueryParameter['status'] = status;
      }

      if (label !== undefined) {
        localVarQueryParameter['label'] = label;
      }

      if (startTimeBetween !== undefined) {
        localVarQueryParameter['start_time_between'] = startTimeBetween;
      }

      if (finishTimeBetween !== undefined) {
        localVarQueryParameter['finish_time_between'] = finishTimeBetween;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['order_by'] = orderBy;
      }

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update Schedule Task
     * @param {number} taskId
     * @param {PostScheduledTaskRequest} postScheduledTaskRequest
     * @param {string | null} [exceptDate]
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateScheduleTaskScheduledTasksTaskIdUpdatePost: async (
      taskId: number,
      postScheduledTaskRequest: PostScheduledTaskRequest,
      exceptDate?: string | null,
      authorization?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taskId' is not null or undefined
      assertParamExists('updateScheduleTaskScheduledTasksTaskIdUpdatePost', 'taskId', taskId);
      // verify required parameter 'postScheduledTaskRequest' is not null or undefined
      assertParamExists(
        'updateScheduleTaskScheduledTasksTaskIdUpdatePost',
        'postScheduledTaskRequest',
        postScheduledTaskRequest,
      );
      const localVarPath = `/scheduled_tasks/{task_id}/update`.replace(
        `{${'task_id'}}`,
        encodeURIComponent(String(taskId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (exceptDate !== undefined) {
        localVarQueryParameter['except_date'] =
          (exceptDate as any) instanceof Date ? (exceptDate as any).toISOString() : exceptDate;
      }

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        postScheduledTaskRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TasksApi - functional programming interface
 * @export
 */
export const TasksApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TasksApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Del Scheduled Tasks Event
     * @param {number} taskId
     * @param {string} eventDate
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async delScheduledTasksEventScheduledTasksTaskIdClearPut(
      taskId: number,
      eventDate: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.delScheduledTasksEventScheduledTasksTaskIdClearPut(
          taskId,
          eventDate,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.delScheduledTasksEventScheduledTasksTaskIdClearPut']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Del Scheduled Tasks
     * @param {number} taskId
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async delScheduledTasksScheduledTasksTaskIdDelete(
      taskId: number,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.delScheduledTasksScheduledTasksTaskIdDelete(
          taskId,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.delScheduledTasksScheduledTasksTaskIdDelete']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Delete Favorite Task
     * @param {string} favoriteTaskId
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFavoriteTaskFavoriteTasksFavoriteTaskIdDelete(
      favoriteTaskId: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteFavoriteTaskFavoriteTasksFavoriteTaskIdDelete(
          favoriteTaskId,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.deleteFavoriteTaskFavoriteTasksFavoriteTaskIdDelete']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get Favorites Tasks
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFavoritesTasksFavoriteTasksGet(
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskFavoritePydantic>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFavoritesTasksFavoriteTasksGet(
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.getFavoritesTasksFavoriteTasksGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get Scheduled Task
     * @param {number} taskId
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getScheduledTaskScheduledTasksTaskIdGet(
      taskId: number,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduledTask>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getScheduledTaskScheduledTasksTaskIdGet(
          taskId,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.getScheduledTaskScheduledTasksTaskIdGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get Scheduled Tasks
     * @param {string} startBefore Only return scheduled tasks that start before given timestamp
     * @param {string} untilAfter Only return scheduled tasks that stop after given timestamp
     * @param {number | null} [limit] defaults to 100
     * @param {number | null} [offset] defaults to 0
     * @param {string | null} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getScheduledTasksScheduledTasksGet(
      startBefore: string,
      untilAfter: string,
      limit?: number | null,
      offset?: number | null,
      orderBy?: string | null,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScheduledTask>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getScheduledTasksScheduledTasksGet(
        startBefore,
        untilAfter,
        limit,
        offset,
        orderBy,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.getScheduledTasksScheduledTasksGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Available in socket.io
     * @summary Get Task Log
     * @param {string} taskId task_id
     * @param {string} [between]          The period of time to fetch, in unix millis.          This can be either a comma separated string or a string prefixed with \&#39;-\&#39; to fetch the last X millis.          Example:             \&quot;1000,2000\&quot; - Fetches logs between unix millis 1000 and 2000.             \&quot;-60000\&quot; - Fetches logs in the last minute.
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTaskLogTasksTaskIdLogGet(
      taskId: string,
      between?: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskEventLog>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskLogTasksTaskIdLogGet(
        taskId,
        between,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.getTaskLogTasksTaskIdLogGet']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get Task Request
     * @param {string} taskId task_id
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTaskRequestTasksTaskIdRequestGet(
      taskId: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskRequest>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskRequestTasksTaskIdRequestGet(
        taskId,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.getTaskRequestTasksTaskIdRequestGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Available in socket.io
     * @summary Get Task State
     * @param {string} taskId task_id
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTaskStateTasksTaskIdStateGet(
      taskId: string,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskState>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskStateTasksTaskIdStateGet(
        taskId,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.getTaskStateTasksTaskIdStateGet']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Post Activity Discovery
     * @param {ActivityDiscoveryRequest} activityDiscoveryRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postActivityDiscoveryTasksActivityDiscoveryPost(
      activityDiscoveryRequest: ActivityDiscoveryRequest,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivityDiscovery>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postActivityDiscoveryTasksActivityDiscoveryPost(
          activityDiscoveryRequest,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.postActivityDiscoveryTasksActivityDiscoveryPost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Post Cancel Task
     * @param {CancelTaskRequest} cancelTaskRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postCancelTaskTasksCancelTaskPost(
      cancelTaskRequest: CancelTaskRequest,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskCancelResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postCancelTaskTasksCancelTaskPost(
        cancelTaskRequest,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.postCancelTaskTasksCancelTaskPost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Post Dispatch Task
     * @param {DispatchTaskRequest} dispatchTaskRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postDispatchTaskTasksDispatchTaskPost(
      dispatchTaskRequest: DispatchTaskRequest,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskDispatchResponse>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postDispatchTaskTasksDispatchTaskPost(
          dispatchTaskRequest,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.postDispatchTaskTasksDispatchTaskPost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Post Favorite Task
     * @param {TaskFavoritePydantic} taskFavoritePydantic
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postFavoriteTaskFavoriteTasksPost(
      taskFavoritePydantic: TaskFavoritePydantic,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postFavoriteTaskFavoriteTasksPost(
        taskFavoritePydantic,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.postFavoriteTaskFavoriteTasksPost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Post Interrupt Task
     * @param {TaskInterruptionRequest} taskInterruptionRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postInterruptTaskTasksInterruptTaskPost(
      taskInterruptionRequest: TaskInterruptionRequest,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskInterruptionResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postInterruptTaskTasksInterruptTaskPost(
          taskInterruptionRequest,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.postInterruptTaskTasksInterruptTaskPost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Post Kill Task
     * @param {TaskKillRequest} taskKillRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postKillTaskTasksKillTaskPost(
      taskKillRequest: TaskKillRequest,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskKillResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postKillTaskTasksKillTaskPost(
        taskKillRequest,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.postKillTaskTasksKillTaskPost']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Post Resume Task
     * @param {TaskResumeRequest} taskResumeRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postResumeTaskTasksResumeTaskPost(
      taskResumeRequest: TaskResumeRequest,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResumeResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postResumeTaskTasksResumeTaskPost(
        taskResumeRequest,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.postResumeTaskTasksResumeTaskPost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Post Rewind Task
     * @param {TaskRewindRequest} taskRewindRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postRewindTaskTasksRewindTaskPost(
      taskRewindRequest: TaskRewindRequest,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskRewindResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postRewindTaskTasksRewindTaskPost(
        taskRewindRequest,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.postRewindTaskTasksRewindTaskPost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Post Robot Task
     * @param {RobotTaskRequest} robotTaskRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postRobotTaskTasksRobotTaskPost(
      robotTaskRequest: RobotTaskRequest,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RobotTaskResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postRobotTaskTasksRobotTaskPost(
        robotTaskRequest,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.postRobotTaskTasksRobotTaskPost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Create a scheduled task. Below are some examples of how the schedules are represented. For more examples, check the docs of the underlying library used [here](https://github.com/dbader/schedule/blob/6eb0b5346b1ce35ece5050e65789fa6e44368175/docs/examples.rst).  | every | to | period | at | description | | - | - | - | - | - | | 10 | - | minutes | - | Every 10 minutes | | - | - | hour | - | Every hour | | - | - | day | 10:30 | Every day at 10:30am | | - | - | monday | - | Every monday | | - | - | wednesday | 13:15 | Every wednesday at 01:15pm | | - | - | minute | :17 | Every 17th sec of a mintue | | 5 | 10 | seconds | - | Every 5-10 seconds (randomly) |
     * @summary Post Scheduled Task
     * @param {PostScheduledTaskRequest} postScheduledTaskRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postScheduledTaskScheduledTasksPost(
      postScheduledTaskRequest: PostScheduledTaskRequest,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduledTask>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postScheduledTaskScheduledTasksPost(
        postScheduledTaskRequest,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.postScheduledTaskScheduledTasksPost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Post Skip Phase
     * @param {TaskPhaseSkipRequest} taskPhaseSkipRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postSkipPhaseTasksSkipPhasePost(
      taskPhaseSkipRequest: TaskPhaseSkipRequest,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SkipPhaseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postSkipPhaseTasksSkipPhasePost(
        taskPhaseSkipRequest,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.postSkipPhaseTasksSkipPhasePost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Post Task Discovery
     * @param {TaskDiscoveryRequest} taskDiscoveryRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postTaskDiscoveryTasksTaskDiscoveryPost(
      taskDiscoveryRequest: TaskDiscoveryRequest,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskDiscovery>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postTaskDiscoveryTasksTaskDiscoveryPost(
          taskDiscoveryRequest,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.postTaskDiscoveryTasksTaskDiscoveryPost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Post Undo Skip Phase
     * @param {UndoPhaseSkipRequest} undoPhaseSkipRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postUndoSkipPhaseTasksUndoSkipPhasePost(
      undoPhaseSkipRequest: UndoPhaseSkipRequest,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UndoPhaseSkipResponse>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postUndoSkipPhaseTasksUndoSkipPhasePost(
          undoPhaseSkipRequest,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.postUndoSkipPhaseTasksUndoSkipPhasePost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Query Task States
     * @param {string | null} [taskId] comma separated list of task ids
     * @param {string | null} [category] comma separated list of task categories
     * @param {string | null} [assignedTo] comma separated list of assigned robot names
     * @param {string | null} [status] comma separated list of statuses
     * @param {string | null} [label] comma separated list of labels, each item must be in the form &lt;key&gt;&#x3D;&lt;value&gt;, multiple items will filter tasks with all the labels
     * @param {string} [startTimeBetween]          The period of starting time to fetch, in unix millis.          This must be a comma separated string, \&#39;X,Y\&#39; to fetch between X millis and Y millis inclusive.          Example:             \&quot;1000,2000\&quot; - Fetches logs between unix millis 1000 and 2000.
     * @param {string} [finishTimeBetween]          The period of finishing time to fetch, in unix millis.          This must be a comma separated string, \&#39;X,Y\&#39; to fetch between X millis and Y millis inclusive.          Example:             \&quot;1000,2000\&quot; - Fetches logs between unix millis 1000 and 2000.             \&quot;-60000\&quot; - Fetches logs in the last minute.
     * @param {number | null} [limit] defaults to 100
     * @param {number | null} [offset] defaults to 0
     * @param {string | null} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async queryTaskStatesTasksGet(
      taskId?: string | null,
      category?: string | null,
      assignedTo?: string | null,
      status?: string | null,
      label?: string | null,
      startTimeBetween?: string,
      finishTimeBetween?: string,
      limit?: number | null,
      offset?: number | null,
      orderBy?: string | null,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskState>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.queryTaskStatesTasksGet(
        taskId,
        category,
        assignedTo,
        status,
        label,
        startTimeBetween,
        finishTimeBetween,
        limit,
        offset,
        orderBy,
        authorization,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.queryTaskStatesTasksGet']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Update Schedule Task
     * @param {number} taskId
     * @param {PostScheduledTaskRequest} postScheduledTaskRequest
     * @param {string | null} [exceptDate]
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateScheduleTaskScheduledTasksTaskIdUpdatePost(
      taskId: number,
      postScheduledTaskRequest: PostScheduledTaskRequest,
      exceptDate?: string | null,
      authorization?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduledTask>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateScheduleTaskScheduledTasksTaskIdUpdatePost(
          taskId,
          postScheduledTaskRequest,
          exceptDate,
          authorization,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TasksApi.updateScheduleTaskScheduledTasksTaskIdUpdatePost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * TasksApi - factory interface
 * @export
 */
export const TasksApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = TasksApiFp(configuration);
  return {
    /**
     *
     * @summary Del Scheduled Tasks Event
     * @param {number} taskId
     * @param {string} eventDate
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    delScheduledTasksEventScheduledTasksTaskIdClearPut(
      taskId: number,
      eventDate: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .delScheduledTasksEventScheduledTasksTaskIdClearPut(
          taskId,
          eventDate,
          authorization,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Del Scheduled Tasks
     * @param {number} taskId
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    delScheduledTasksScheduledTasksTaskIdDelete(
      taskId: number,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .delScheduledTasksScheduledTasksTaskIdDelete(taskId, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete Favorite Task
     * @param {string} favoriteTaskId
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFavoriteTaskFavoriteTasksFavoriteTaskIdDelete(
      favoriteTaskId: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .deleteFavoriteTaskFavoriteTasksFavoriteTaskIdDelete(favoriteTaskId, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Favorites Tasks
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFavoritesTasksFavoriteTasksGet(
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<Array<TaskFavoritePydantic>> {
      return localVarFp
        .getFavoritesTasksFavoriteTasksGet(authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Scheduled Task
     * @param {number} taskId
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getScheduledTaskScheduledTasksTaskIdGet(
      taskId: number,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<ScheduledTask> {
      return localVarFp
        .getScheduledTaskScheduledTasksTaskIdGet(taskId, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Scheduled Tasks
     * @param {string} startBefore Only return scheduled tasks that start before given timestamp
     * @param {string} untilAfter Only return scheduled tasks that stop after given timestamp
     * @param {number | null} [limit] defaults to 100
     * @param {number | null} [offset] defaults to 0
     * @param {string | null} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getScheduledTasksScheduledTasksGet(
      startBefore: string,
      untilAfter: string,
      limit?: number | null,
      offset?: number | null,
      orderBy?: string | null,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<Array<ScheduledTask>> {
      return localVarFp
        .getScheduledTasksScheduledTasksGet(
          startBefore,
          untilAfter,
          limit,
          offset,
          orderBy,
          authorization,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Available in socket.io
     * @summary Get Task Log
     * @param {string} taskId task_id
     * @param {string} [between]          The period of time to fetch, in unix millis.          This can be either a comma separated string or a string prefixed with \&#39;-\&#39; to fetch the last X millis.          Example:             \&quot;1000,2000\&quot; - Fetches logs between unix millis 1000 and 2000.             \&quot;-60000\&quot; - Fetches logs in the last minute.
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskLogTasksTaskIdLogGet(
      taskId: string,
      between?: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<TaskEventLog> {
      return localVarFp
        .getTaskLogTasksTaskIdLogGet(taskId, between, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Task Request
     * @param {string} taskId task_id
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskRequestTasksTaskIdRequestGet(
      taskId: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<TaskRequest> {
      return localVarFp
        .getTaskRequestTasksTaskIdRequestGet(taskId, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Available in socket.io
     * @summary Get Task State
     * @param {string} taskId task_id
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskStateTasksTaskIdStateGet(
      taskId: string,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<TaskState> {
      return localVarFp
        .getTaskStateTasksTaskIdStateGet(taskId, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Post Activity Discovery
     * @param {ActivityDiscoveryRequest} activityDiscoveryRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postActivityDiscoveryTasksActivityDiscoveryPost(
      activityDiscoveryRequest: ActivityDiscoveryRequest,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<ActivityDiscovery> {
      return localVarFp
        .postActivityDiscoveryTasksActivityDiscoveryPost(
          activityDiscoveryRequest,
          authorization,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Post Cancel Task
     * @param {CancelTaskRequest} cancelTaskRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postCancelTaskTasksCancelTaskPost(
      cancelTaskRequest: CancelTaskRequest,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<TaskCancelResponse> {
      return localVarFp
        .postCancelTaskTasksCancelTaskPost(cancelTaskRequest, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Post Dispatch Task
     * @param {DispatchTaskRequest} dispatchTaskRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postDispatchTaskTasksDispatchTaskPost(
      dispatchTaskRequest: DispatchTaskRequest,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<TaskDispatchResponse> {
      return localVarFp
        .postDispatchTaskTasksDispatchTaskPost(dispatchTaskRequest, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Post Favorite Task
     * @param {TaskFavoritePydantic} taskFavoritePydantic
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postFavoriteTaskFavoriteTasksPost(
      taskFavoritePydantic: TaskFavoritePydantic,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .postFavoriteTaskFavoriteTasksPost(taskFavoritePydantic, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Post Interrupt Task
     * @param {TaskInterruptionRequest} taskInterruptionRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postInterruptTaskTasksInterruptTaskPost(
      taskInterruptionRequest: TaskInterruptionRequest,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<TaskInterruptionResponse> {
      return localVarFp
        .postInterruptTaskTasksInterruptTaskPost(taskInterruptionRequest, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Post Kill Task
     * @param {TaskKillRequest} taskKillRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postKillTaskTasksKillTaskPost(
      taskKillRequest: TaskKillRequest,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<TaskKillResponse> {
      return localVarFp
        .postKillTaskTasksKillTaskPost(taskKillRequest, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Post Resume Task
     * @param {TaskResumeRequest} taskResumeRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postResumeTaskTasksResumeTaskPost(
      taskResumeRequest: TaskResumeRequest,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<TaskResumeResponse> {
      return localVarFp
        .postResumeTaskTasksResumeTaskPost(taskResumeRequest, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Post Rewind Task
     * @param {TaskRewindRequest} taskRewindRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postRewindTaskTasksRewindTaskPost(
      taskRewindRequest: TaskRewindRequest,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<TaskRewindResponse> {
      return localVarFp
        .postRewindTaskTasksRewindTaskPost(taskRewindRequest, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Post Robot Task
     * @param {RobotTaskRequest} robotTaskRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postRobotTaskTasksRobotTaskPost(
      robotTaskRequest: RobotTaskRequest,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<RobotTaskResponse> {
      return localVarFp
        .postRobotTaskTasksRobotTaskPost(robotTaskRequest, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a scheduled task. Below are some examples of how the schedules are represented. For more examples, check the docs of the underlying library used [here](https://github.com/dbader/schedule/blob/6eb0b5346b1ce35ece5050e65789fa6e44368175/docs/examples.rst).  | every | to | period | at | description | | - | - | - | - | - | | 10 | - | minutes | - | Every 10 minutes | | - | - | hour | - | Every hour | | - | - | day | 10:30 | Every day at 10:30am | | - | - | monday | - | Every monday | | - | - | wednesday | 13:15 | Every wednesday at 01:15pm | | - | - | minute | :17 | Every 17th sec of a mintue | | 5 | 10 | seconds | - | Every 5-10 seconds (randomly) |
     * @summary Post Scheduled Task
     * @param {PostScheduledTaskRequest} postScheduledTaskRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postScheduledTaskScheduledTasksPost(
      postScheduledTaskRequest: PostScheduledTaskRequest,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<ScheduledTask> {
      return localVarFp
        .postScheduledTaskScheduledTasksPost(postScheduledTaskRequest, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Post Skip Phase
     * @param {TaskPhaseSkipRequest} taskPhaseSkipRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postSkipPhaseTasksSkipPhasePost(
      taskPhaseSkipRequest: TaskPhaseSkipRequest,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<SkipPhaseResponse> {
      return localVarFp
        .postSkipPhaseTasksSkipPhasePost(taskPhaseSkipRequest, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Post Task Discovery
     * @param {TaskDiscoveryRequest} taskDiscoveryRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postTaskDiscoveryTasksTaskDiscoveryPost(
      taskDiscoveryRequest: TaskDiscoveryRequest,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<TaskDiscovery> {
      return localVarFp
        .postTaskDiscoveryTasksTaskDiscoveryPost(taskDiscoveryRequest, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Post Undo Skip Phase
     * @param {UndoPhaseSkipRequest} undoPhaseSkipRequest
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUndoSkipPhaseTasksUndoSkipPhasePost(
      undoPhaseSkipRequest: UndoPhaseSkipRequest,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<UndoPhaseSkipResponse> {
      return localVarFp
        .postUndoSkipPhaseTasksUndoSkipPhasePost(undoPhaseSkipRequest, authorization, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Query Task States
     * @param {string | null} [taskId] comma separated list of task ids
     * @param {string | null} [category] comma separated list of task categories
     * @param {string | null} [assignedTo] comma separated list of assigned robot names
     * @param {string | null} [status] comma separated list of statuses
     * @param {string | null} [label] comma separated list of labels, each item must be in the form &lt;key&gt;&#x3D;&lt;value&gt;, multiple items will filter tasks with all the labels
     * @param {string} [startTimeBetween]          The period of starting time to fetch, in unix millis.          This must be a comma separated string, \&#39;X,Y\&#39; to fetch between X millis and Y millis inclusive.          Example:             \&quot;1000,2000\&quot; - Fetches logs between unix millis 1000 and 2000.
     * @param {string} [finishTimeBetween]          The period of finishing time to fetch, in unix millis.          This must be a comma separated string, \&#39;X,Y\&#39; to fetch between X millis and Y millis inclusive.          Example:             \&quot;1000,2000\&quot; - Fetches logs between unix millis 1000 and 2000.             \&quot;-60000\&quot; - Fetches logs in the last minute.
     * @param {number | null} [limit] defaults to 100
     * @param {number | null} [offset] defaults to 0
     * @param {string | null} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryTaskStatesTasksGet(
      taskId?: string | null,
      category?: string | null,
      assignedTo?: string | null,
      status?: string | null,
      label?: string | null,
      startTimeBetween?: string,
      finishTimeBetween?: string,
      limit?: number | null,
      offset?: number | null,
      orderBy?: string | null,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<Array<TaskState>> {
      return localVarFp
        .queryTaskStatesTasksGet(
          taskId,
          category,
          assignedTo,
          status,
          label,
          startTimeBetween,
          finishTimeBetween,
          limit,
          offset,
          orderBy,
          authorization,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update Schedule Task
     * @param {number} taskId
     * @param {PostScheduledTaskRequest} postScheduledTaskRequest
     * @param {string | null} [exceptDate]
     * @param {string | null} [authorization]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateScheduleTaskScheduledTasksTaskIdUpdatePost(
      taskId: number,
      postScheduledTaskRequest: PostScheduledTaskRequest,
      exceptDate?: string | null,
      authorization?: string | null,
      options?: any,
    ): AxiosPromise<ScheduledTask> {
      return localVarFp
        .updateScheduleTaskScheduledTasksTaskIdUpdatePost(
          taskId,
          postScheduledTaskRequest,
          exceptDate,
          authorization,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
export class TasksApi extends BaseAPI {
  /**
   *
   * @summary Del Scheduled Tasks Event
   * @param {number} taskId
   * @param {string} eventDate
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public delScheduledTasksEventScheduledTasksTaskIdClearPut(
    taskId: number,
    eventDate: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .delScheduledTasksEventScheduledTasksTaskIdClearPut(taskId, eventDate, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Del Scheduled Tasks
   * @param {number} taskId
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public delScheduledTasksScheduledTasksTaskIdDelete(
    taskId: number,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .delScheduledTasksScheduledTasksTaskIdDelete(taskId, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete Favorite Task
   * @param {string} favoriteTaskId
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public deleteFavoriteTaskFavoriteTasksFavoriteTaskIdDelete(
    favoriteTaskId: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .deleteFavoriteTaskFavoriteTasksFavoriteTaskIdDelete(favoriteTaskId, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Favorites Tasks
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public getFavoritesTasksFavoriteTasksGet(
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .getFavoritesTasksFavoriteTasksGet(authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Scheduled Task
   * @param {number} taskId
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public getScheduledTaskScheduledTasksTaskIdGet(
    taskId: number,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .getScheduledTaskScheduledTasksTaskIdGet(taskId, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Scheduled Tasks
   * @param {string} startBefore Only return scheduled tasks that start before given timestamp
   * @param {string} untilAfter Only return scheduled tasks that stop after given timestamp
   * @param {number | null} [limit] defaults to 100
   * @param {number | null} [offset] defaults to 0
   * @param {string | null} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public getScheduledTasksScheduledTasksGet(
    startBefore: string,
    untilAfter: string,
    limit?: number | null,
    offset?: number | null,
    orderBy?: string | null,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .getScheduledTasksScheduledTasksGet(
        startBefore,
        untilAfter,
        limit,
        offset,
        orderBy,
        authorization,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Available in socket.io
   * @summary Get Task Log
   * @param {string} taskId task_id
   * @param {string} [between]          The period of time to fetch, in unix millis.          This can be either a comma separated string or a string prefixed with \&#39;-\&#39; to fetch the last X millis.          Example:             \&quot;1000,2000\&quot; - Fetches logs between unix millis 1000 and 2000.             \&quot;-60000\&quot; - Fetches logs in the last minute.
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public getTaskLogTasksTaskIdLogGet(
    taskId: string,
    between?: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .getTaskLogTasksTaskIdLogGet(taskId, between, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Task Request
   * @param {string} taskId task_id
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public getTaskRequestTasksTaskIdRequestGet(
    taskId: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .getTaskRequestTasksTaskIdRequestGet(taskId, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Available in socket.io
   * @summary Get Task State
   * @param {string} taskId task_id
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public getTaskStateTasksTaskIdStateGet(
    taskId: string,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .getTaskStateTasksTaskIdStateGet(taskId, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Post Activity Discovery
   * @param {ActivityDiscoveryRequest} activityDiscoveryRequest
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public postActivityDiscoveryTasksActivityDiscoveryPost(
    activityDiscoveryRequest: ActivityDiscoveryRequest,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .postActivityDiscoveryTasksActivityDiscoveryPost(
        activityDiscoveryRequest,
        authorization,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Post Cancel Task
   * @param {CancelTaskRequest} cancelTaskRequest
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public postCancelTaskTasksCancelTaskPost(
    cancelTaskRequest: CancelTaskRequest,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .postCancelTaskTasksCancelTaskPost(cancelTaskRequest, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Post Dispatch Task
   * @param {DispatchTaskRequest} dispatchTaskRequest
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public postDispatchTaskTasksDispatchTaskPost(
    dispatchTaskRequest: DispatchTaskRequest,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .postDispatchTaskTasksDispatchTaskPost(dispatchTaskRequest, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Post Favorite Task
   * @param {TaskFavoritePydantic} taskFavoritePydantic
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public postFavoriteTaskFavoriteTasksPost(
    taskFavoritePydantic: TaskFavoritePydantic,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .postFavoriteTaskFavoriteTasksPost(taskFavoritePydantic, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Post Interrupt Task
   * @param {TaskInterruptionRequest} taskInterruptionRequest
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public postInterruptTaskTasksInterruptTaskPost(
    taskInterruptionRequest: TaskInterruptionRequest,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .postInterruptTaskTasksInterruptTaskPost(taskInterruptionRequest, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Post Kill Task
   * @param {TaskKillRequest} taskKillRequest
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public postKillTaskTasksKillTaskPost(
    taskKillRequest: TaskKillRequest,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .postKillTaskTasksKillTaskPost(taskKillRequest, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Post Resume Task
   * @param {TaskResumeRequest} taskResumeRequest
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public postResumeTaskTasksResumeTaskPost(
    taskResumeRequest: TaskResumeRequest,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .postResumeTaskTasksResumeTaskPost(taskResumeRequest, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Post Rewind Task
   * @param {TaskRewindRequest} taskRewindRequest
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public postRewindTaskTasksRewindTaskPost(
    taskRewindRequest: TaskRewindRequest,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .postRewindTaskTasksRewindTaskPost(taskRewindRequest, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Post Robot Task
   * @param {RobotTaskRequest} robotTaskRequest
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public postRobotTaskTasksRobotTaskPost(
    robotTaskRequest: RobotTaskRequest,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .postRobotTaskTasksRobotTaskPost(robotTaskRequest, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a scheduled task. Below are some examples of how the schedules are represented. For more examples, check the docs of the underlying library used [here](https://github.com/dbader/schedule/blob/6eb0b5346b1ce35ece5050e65789fa6e44368175/docs/examples.rst).  | every | to | period | at | description | | - | - | - | - | - | | 10 | - | minutes | - | Every 10 minutes | | - | - | hour | - | Every hour | | - | - | day | 10:30 | Every day at 10:30am | | - | - | monday | - | Every monday | | - | - | wednesday | 13:15 | Every wednesday at 01:15pm | | - | - | minute | :17 | Every 17th sec of a mintue | | 5 | 10 | seconds | - | Every 5-10 seconds (randomly) |
   * @summary Post Scheduled Task
   * @param {PostScheduledTaskRequest} postScheduledTaskRequest
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public postScheduledTaskScheduledTasksPost(
    postScheduledTaskRequest: PostScheduledTaskRequest,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .postScheduledTaskScheduledTasksPost(postScheduledTaskRequest, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Post Skip Phase
   * @param {TaskPhaseSkipRequest} taskPhaseSkipRequest
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public postSkipPhaseTasksSkipPhasePost(
    taskPhaseSkipRequest: TaskPhaseSkipRequest,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .postSkipPhaseTasksSkipPhasePost(taskPhaseSkipRequest, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Post Task Discovery
   * @param {TaskDiscoveryRequest} taskDiscoveryRequest
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public postTaskDiscoveryTasksTaskDiscoveryPost(
    taskDiscoveryRequest: TaskDiscoveryRequest,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .postTaskDiscoveryTasksTaskDiscoveryPost(taskDiscoveryRequest, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Post Undo Skip Phase
   * @param {UndoPhaseSkipRequest} undoPhaseSkipRequest
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public postUndoSkipPhaseTasksUndoSkipPhasePost(
    undoPhaseSkipRequest: UndoPhaseSkipRequest,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .postUndoSkipPhaseTasksUndoSkipPhasePost(undoPhaseSkipRequest, authorization, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Query Task States
   * @param {string | null} [taskId] comma separated list of task ids
   * @param {string | null} [category] comma separated list of task categories
   * @param {string | null} [assignedTo] comma separated list of assigned robot names
   * @param {string | null} [status] comma separated list of statuses
   * @param {string | null} [label] comma separated list of labels, each item must be in the form &lt;key&gt;&#x3D;&lt;value&gt;, multiple items will filter tasks with all the labels
   * @param {string} [startTimeBetween]          The period of starting time to fetch, in unix millis.          This must be a comma separated string, \&#39;X,Y\&#39; to fetch between X millis and Y millis inclusive.          Example:             \&quot;1000,2000\&quot; - Fetches logs between unix millis 1000 and 2000.
   * @param {string} [finishTimeBetween]          The period of finishing time to fetch, in unix millis.          This must be a comma separated string, \&#39;X,Y\&#39; to fetch between X millis and Y millis inclusive.          Example:             \&quot;1000,2000\&quot; - Fetches logs between unix millis 1000 and 2000.             \&quot;-60000\&quot; - Fetches logs in the last minute.
   * @param {number | null} [limit] defaults to 100
   * @param {number | null} [offset] defaults to 0
   * @param {string | null} [orderBy] common separated list of fields to order by, prefix with \&#39;-\&#39; to sort descendingly.
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public queryTaskStatesTasksGet(
    taskId?: string | null,
    category?: string | null,
    assignedTo?: string | null,
    status?: string | null,
    label?: string | null,
    startTimeBetween?: string,
    finishTimeBetween?: string,
    limit?: number | null,
    offset?: number | null,
    orderBy?: string | null,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .queryTaskStatesTasksGet(
        taskId,
        category,
        assignedTo,
        status,
        label,
        startTimeBetween,
        finishTimeBetween,
        limit,
        offset,
        orderBy,
        authorization,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update Schedule Task
   * @param {number} taskId
   * @param {PostScheduledTaskRequest} postScheduledTaskRequest
   * @param {string | null} [exceptDate]
   * @param {string | null} [authorization]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public updateScheduleTaskScheduledTasksTaskIdUpdatePost(
    taskId: number,
    postScheduledTaskRequest: PostScheduledTaskRequest,
    exceptDate?: string | null,
    authorization?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return TasksApiFp(this.configuration)
      .updateScheduleTaskScheduledTasksTaskIdUpdatePost(
        taskId,
        postScheduledTaskRequest,
        exceptDate,
        authorization,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}
