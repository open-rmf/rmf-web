import { AppEvents } from '../app-events';
import { Subscription } from 'rxjs';
import { useFrame, useThree } from '@react-three/fiber';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import React, { useEffect, useRef } from 'react';
import { MOUSE, Vector3 } from 'three';
import { ResourcesContext } from '../app-contexts';
import { findSceneBoundingBoxFromThreeFiber } from 'react-components';

const DEFAULT_ZOOM_IN_CONSTANT = 1.2;
const DEFAULT_ZOOM_OUT_CONSTANT = 0.8;
export const DEFAULT_ZOOM_LEVEL = 20;

interface CameraControlProps {
  zoom: number;
}

export const CameraControl: React.FC<CameraControlProps> = ({ zoom }) => {
  const { camera, gl } = useThree();
  const controlsRef = useRef<OrbitControls | null>(null);
  const resourceManager = React.useContext(ResourcesContext);

  useEffect(() => {
    const subs: Subscription[] = [];
    subs.push(
      AppEvents.zoomIn.subscribe(() => {
        AppEvents.zoom.next(camera.zoom * DEFAULT_ZOOM_IN_CONSTANT);
      }),
    );
    subs.push(
      AppEvents.zoomOut.subscribe(() => {
        AppEvents.zoom.next(camera.zoom * DEFAULT_ZOOM_OUT_CONSTANT);
      }),
    );
    subs.push(
      AppEvents.levelSelect.subscribe((level) => {
        if (!level) {
          return;
        }
        const sceneBoundingBox = findSceneBoundingBoxFromThreeFiber(level);
        if (!sceneBoundingBox) {
          return;
        }
        const center = sceneBoundingBox.getCenter(new Vector3());
        const size = sceneBoundingBox.getSize(new Vector3());
        const distance = Math.max(size.x, size.y, size.z) * 0.7;
        camera.position.set(center.x, center.y, center.z + distance);
        camera.zoom = resourceManager?.defaultZoom || DEFAULT_ZOOM_LEVEL;
        camera.updateProjectionMatrix();
      }),
    );

    const handleScroll = (event: WheelEvent) => {
      const SENSITIVITY = 0.9;
      /**
       * event.deltaY represents the vertical scroll amount generated by the mouse wheel,
       * with positive values indicating downward scroll (toward the user)
       * and negative values indicating upward scroll (away from the user).
       */
      const newZoom =
        event.deltaY > 0
          ? camera.zoom * DEFAULT_ZOOM_OUT_CONSTANT
          : camera.zoom * DEFAULT_ZOOM_IN_CONSTANT;
      AppEvents.zoom.next(newZoom * SENSITIVITY);
    };

    gl.domElement.addEventListener('wheel', handleScroll);

    return () => {
      for (const sub of subs) {
        sub.unsubscribe();
      }
      gl.domElement.removeEventListener('wheel', handleScroll);
    };
  }, [camera, resourceManager?.defaultZoom, gl.domElement]);

  useEffect(() => {
    const controls = new OrbitControls(camera, gl.domElement);
    controls.target = new Vector3(0, 0, -1000);
    controls.enableRotate = false;
    controls.enableDamping = false;
    controls.enableZoom = true;
    camera.zoom = zoom;
    controls.mouseButtons = {
      LEFT: MOUSE.PAN,
      MIDDLE: undefined,
      RIGHT: undefined,
    };

    if (AppEvents.cameraPosition.value) {
      camera.position.set(
        AppEvents.cameraPosition.value.x,
        AppEvents.cameraPosition.value.y,
        AppEvents.cameraPosition.value.z,
      );
    }

    controlsRef.current = controls;

    return () => {
      controls.dispose();
    };
  }, [camera, gl.domElement, zoom]);

  useFrame(() => {
    if (controlsRef.current) {
      controlsRef.current.update();
      AppEvents.cameraPosition.next(new Vector3().copy(camera.position));
    }
  });

  return null;
};
